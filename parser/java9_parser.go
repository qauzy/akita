// Code generated from Java9Parser.g4 by ANTLR 4.7.2. DO NOT EDIT.

package parser // Java9Parser

import (
	"fmt"
	"reflect"
	"strconv"

	"github.com/antlr/antlr4/runtime/Go/antlr"
)

// Suppress unused import errors
var _ = fmt.Printf
var _ = reflect.Copy
var _ = strconv.Itoa

var parserATN = []uint16{
	3, 24715, 42794, 33075, 47597, 16764, 15335, 30598, 22884, 3, 120, 2983,
	4, 2, 9, 2, 4, 3, 9, 3, 4, 4, 9, 4, 4, 5, 9, 5, 4, 6, 9, 6, 4, 7, 9, 7,
	4, 8, 9, 8, 4, 9, 9, 9, 4, 10, 9, 10, 4, 11, 9, 11, 4, 12, 9, 12, 4, 13,
	9, 13, 4, 14, 9, 14, 4, 15, 9, 15, 4, 16, 9, 16, 4, 17, 9, 17, 4, 18, 9,
	18, 4, 19, 9, 19, 4, 20, 9, 20, 4, 21, 9, 21, 4, 22, 9, 22, 4, 23, 9, 23,
	4, 24, 9, 24, 4, 25, 9, 25, 4, 26, 9, 26, 4, 27, 9, 27, 4, 28, 9, 28, 4,
	29, 9, 29, 4, 30, 9, 30, 4, 31, 9, 31, 4, 32, 9, 32, 4, 33, 9, 33, 4, 34,
	9, 34, 4, 35, 9, 35, 4, 36, 9, 36, 4, 37, 9, 37, 4, 38, 9, 38, 4, 39, 9,
	39, 4, 40, 9, 40, 4, 41, 9, 41, 4, 42, 9, 42, 4, 43, 9, 43, 4, 44, 9, 44,
	4, 45, 9, 45, 4, 46, 9, 46, 4, 47, 9, 47, 4, 48, 9, 48, 4, 49, 9, 49, 4,
	50, 9, 50, 4, 51, 9, 51, 4, 52, 9, 52, 4, 53, 9, 53, 4, 54, 9, 54, 4, 55,
	9, 55, 4, 56, 9, 56, 4, 57, 9, 57, 4, 58, 9, 58, 4, 59, 9, 59, 4, 60, 9,
	60, 4, 61, 9, 61, 4, 62, 9, 62, 4, 63, 9, 63, 4, 64, 9, 64, 4, 65, 9, 65,
	4, 66, 9, 66, 4, 67, 9, 67, 4, 68, 9, 68, 4, 69, 9, 69, 4, 70, 9, 70, 4,
	71, 9, 71, 4, 72, 9, 72, 4, 73, 9, 73, 4, 74, 9, 74, 4, 75, 9, 75, 4, 76,
	9, 76, 4, 77, 9, 77, 4, 78, 9, 78, 4, 79, 9, 79, 4, 80, 9, 80, 4, 81, 9,
	81, 4, 82, 9, 82, 4, 83, 9, 83, 4, 84, 9, 84, 4, 85, 9, 85, 4, 86, 9, 86,
	4, 87, 9, 87, 4, 88, 9, 88, 4, 89, 9, 89, 4, 90, 9, 90, 4, 91, 9, 91, 4,
	92, 9, 92, 4, 93, 9, 93, 4, 94, 9, 94, 4, 95, 9, 95, 4, 96, 9, 96, 4, 97,
	9, 97, 4, 98, 9, 98, 4, 99, 9, 99, 4, 100, 9, 100, 4, 101, 9, 101, 4, 102,
	9, 102, 4, 103, 9, 103, 4, 104, 9, 104, 4, 105, 9, 105, 4, 106, 9, 106,
	4, 107, 9, 107, 4, 108, 9, 108, 4, 109, 9, 109, 4, 110, 9, 110, 4, 111,
	9, 111, 4, 112, 9, 112, 4, 113, 9, 113, 4, 114, 9, 114, 4, 115, 9, 115,
	4, 116, 9, 116, 4, 117, 9, 117, 4, 118, 9, 118, 4, 119, 9, 119, 4, 120,
	9, 120, 4, 121, 9, 121, 4, 122, 9, 122, 4, 123, 9, 123, 4, 124, 9, 124,
	4, 125, 9, 125, 4, 126, 9, 126, 4, 127, 9, 127, 4, 128, 9, 128, 4, 129,
	9, 129, 4, 130, 9, 130, 4, 131, 9, 131, 4, 132, 9, 132, 4, 133, 9, 133,
	4, 134, 9, 134, 4, 135, 9, 135, 4, 136, 9, 136, 4, 137, 9, 137, 4, 138,
	9, 138, 4, 139, 9, 139, 4, 140, 9, 140, 4, 141, 9, 141, 4, 142, 9, 142,
	4, 143, 9, 143, 4, 144, 9, 144, 4, 145, 9, 145, 4, 146, 9, 146, 4, 147,
	9, 147, 4, 148, 9, 148, 4, 149, 9, 149, 4, 150, 9, 150, 4, 151, 9, 151,
	4, 152, 9, 152, 4, 153, 9, 153, 4, 154, 9, 154, 4, 155, 9, 155, 4, 156,
	9, 156, 4, 157, 9, 157, 4, 158, 9, 158, 4, 159, 9, 159, 4, 160, 9, 160,
	4, 161, 9, 161, 4, 162, 9, 162, 4, 163, 9, 163, 4, 164, 9, 164, 4, 165,
	9, 165, 4, 166, 9, 166, 4, 167, 9, 167, 4, 168, 9, 168, 4, 169, 9, 169,
	4, 170, 9, 170, 4, 171, 9, 171, 4, 172, 9, 172, 4, 173, 9, 173, 4, 174,
	9, 174, 4, 175, 9, 175, 4, 176, 9, 176, 4, 177, 9, 177, 4, 178, 9, 178,
	4, 179, 9, 179, 4, 180, 9, 180, 4, 181, 9, 181, 4, 182, 9, 182, 4, 183,
	9, 183, 4, 184, 9, 184, 4, 185, 9, 185, 4, 186, 9, 186, 4, 187, 9, 187,
	4, 188, 9, 188, 4, 189, 9, 189, 4, 190, 9, 190, 4, 191, 9, 191, 4, 192,
	9, 192, 4, 193, 9, 193, 4, 194, 9, 194, 4, 195, 9, 195, 4, 196, 9, 196,
	4, 197, 9, 197, 4, 198, 9, 198, 4, 199, 9, 199, 4, 200, 9, 200, 4, 201,
	9, 201, 4, 202, 9, 202, 4, 203, 9, 203, 4, 204, 9, 204, 4, 205, 9, 205,
	4, 206, 9, 206, 4, 207, 9, 207, 4, 208, 9, 208, 4, 209, 9, 209, 4, 210,
	9, 210, 4, 211, 9, 211, 4, 212, 9, 212, 4, 213, 9, 213, 4, 214, 9, 214,
	4, 215, 9, 215, 4, 216, 9, 216, 4, 217, 9, 217, 4, 218, 9, 218, 4, 219,
	9, 219, 4, 220, 9, 220, 4, 221, 9, 221, 4, 222, 9, 222, 4, 223, 9, 223,
	4, 224, 9, 224, 4, 225, 9, 225, 4, 226, 9, 226, 4, 227, 9, 227, 4, 228,
	9, 228, 4, 229, 9, 229, 4, 230, 9, 230, 4, 231, 9, 231, 4, 232, 9, 232,
	4, 233, 9, 233, 4, 234, 9, 234, 4, 235, 9, 235, 4, 236, 9, 236, 4, 237,
	9, 237, 4, 238, 9, 238, 4, 239, 9, 239, 4, 240, 9, 240, 4, 241, 9, 241,
	4, 242, 9, 242, 4, 243, 9, 243, 4, 244, 9, 244, 4, 245, 9, 245, 4, 246,
	9, 246, 3, 2, 3, 2, 3, 3, 7, 3, 496, 10, 3, 12, 3, 14, 3, 499, 11, 3, 3,
	3, 3, 3, 7, 3, 503, 10, 3, 12, 3, 14, 3, 506, 11, 3, 3, 3, 5, 3, 509, 10,
	3, 3, 4, 3, 4, 5, 4, 513, 10, 4, 3, 5, 3, 5, 3, 6, 3, 6, 3, 7, 3, 7, 3,
	7, 5, 7, 522, 10, 7, 3, 8, 3, 8, 5, 8, 526, 10, 8, 3, 8, 3, 8, 7, 8, 530,
	10, 8, 12, 8, 14, 8, 533, 11, 8, 3, 9, 7, 9, 536, 10, 9, 12, 9, 14, 9,
	539, 11, 9, 3, 9, 3, 9, 5, 9, 543, 10, 9, 3, 9, 3, 9, 3, 9, 7, 9, 548,
	10, 9, 12, 9, 14, 9, 551, 11, 9, 3, 9, 3, 9, 5, 9, 555, 10, 9, 5, 9, 557,
	10, 9, 3, 10, 3, 10, 7, 10, 561, 10, 10, 12, 10, 14, 10, 564, 11, 10, 3,
	10, 3, 10, 5, 10, 568, 10, 10, 3, 11, 7, 11, 571, 10, 11, 12, 11, 14, 11,
	574, 11, 11, 3, 11, 3, 11, 5, 11, 578, 10, 11, 3, 12, 3, 12, 3, 13, 3,
	13, 3, 14, 3, 14, 3, 15, 7, 15, 587, 10, 15, 12, 15, 14, 15, 590, 11, 15,
	3, 15, 3, 15, 3, 16, 3, 16, 3, 16, 3, 16, 3, 16, 3, 16, 3, 16, 3, 16, 3,
	16, 5, 16, 603, 10, 16, 3, 17, 7, 17, 606, 10, 17, 12, 17, 14, 17, 609,
	11, 17, 3, 17, 3, 17, 3, 17, 7, 17, 614, 10, 17, 12, 17, 14, 17, 617, 11,
	17, 3, 17, 3, 17, 7, 17, 621, 10, 17, 12, 17, 14, 17, 624, 11, 17, 3, 18,
	7, 18, 627, 10, 18, 12, 18, 14, 18, 630, 11, 18, 3, 18, 3, 18, 5, 18, 634,
	10, 18, 3, 19, 3, 19, 3, 20, 3, 20, 3, 20, 3, 20, 3, 20, 7, 20, 643, 10,
	20, 12, 20, 14, 20, 646, 11, 20, 5, 20, 648, 10, 20, 3, 21, 3, 21, 3, 21,
	3, 22, 3, 22, 3, 22, 3, 22, 3, 23, 3, 23, 3, 23, 7, 23, 660, 10, 23, 12,
	23, 14, 23, 663, 11, 23, 3, 24, 3, 24, 5, 24, 667, 10, 24, 3, 25, 7, 25,
	670, 10, 25, 12, 25, 14, 25, 673, 11, 25, 3, 25, 3, 25, 5, 25, 677, 10,
	25, 3, 26, 3, 26, 3, 26, 3, 26, 5, 26, 683, 10, 26, 3, 27, 3, 27, 3, 27,
	3, 27, 3, 27, 3, 27, 7, 27, 691, 10, 27, 12, 27, 14, 27, 694, 11, 27, 3,
	28, 3, 28, 3, 28, 3, 28, 3, 28, 3, 28, 7, 28, 702, 10, 28, 12, 28, 14,
	28, 705, 11, 28, 3, 29, 3, 29, 3, 29, 3, 29, 3, 29, 5, 29, 712, 10, 29,
	3, 30, 3, 30, 3, 30, 3, 30, 3, 30, 3, 30, 7, 30, 720, 10, 30, 12, 30, 14,
	30, 723, 11, 30, 3, 31, 3, 31, 3, 31, 3, 31, 3, 31, 5, 31, 730, 10, 31,
	3, 32, 3, 32, 3, 33, 3, 33, 3, 33, 3, 33, 3, 33, 3, 33, 7, 33, 740, 10,
	33, 12, 33, 14, 33, 743, 11, 33, 3, 34, 3, 34, 5, 34, 747, 10, 34, 3, 35,
	5, 35, 750, 10, 35, 3, 35, 7, 35, 753, 10, 35, 12, 35, 14, 35, 756, 11,
	35, 3, 35, 7, 35, 759, 10, 35, 12, 35, 14, 35, 762, 11, 35, 3, 35, 3, 35,
	3, 36, 7, 36, 767, 10, 36, 12, 36, 14, 36, 770, 11, 36, 3, 36, 3, 36, 3,
	37, 7, 37, 775, 10, 37, 12, 37, 14, 37, 778, 11, 37, 3, 37, 3, 37, 3, 37,
	3, 37, 3, 38, 3, 38, 3, 39, 3, 39, 3, 39, 3, 39, 5, 39, 790, 10, 39, 3,
	40, 3, 40, 3, 40, 3, 40, 3, 41, 3, 41, 3, 41, 3, 41, 3, 41, 3, 41, 3, 42,
	3, 42, 3, 42, 3, 42, 3, 42, 3, 42, 3, 42, 3, 43, 3, 43, 3, 43, 3, 43, 3,
	43, 3, 43, 3, 43, 3, 44, 3, 44, 3, 44, 5, 44, 819, 10, 44, 3, 45, 7, 45,
	822, 10, 45, 12, 45, 14, 45, 825, 11, 45, 3, 45, 5, 45, 828, 10, 45, 3,
	45, 3, 45, 3, 45, 3, 45, 7, 45, 834, 10, 45, 12, 45, 14, 45, 837, 11, 45,
	3, 45, 3, 45, 3, 46, 3, 46, 7, 46, 843, 10, 46, 12, 46, 14, 46, 846, 11,
	46, 3, 46, 3, 46, 3, 46, 3, 46, 3, 46, 3, 46, 3, 46, 3, 46, 3, 46, 7, 46,
	857, 10, 46, 12, 46, 14, 46, 860, 11, 46, 5, 46, 862, 10, 46, 3, 46, 3,
	46, 3, 46, 3, 46, 3, 46, 3, 46, 3, 46, 3, 46, 7, 46, 872, 10, 46, 12, 46,
	14, 46, 875, 11, 46, 5, 46, 877, 10, 46, 3, 46, 3, 46, 3, 46, 3, 46, 3,
	46, 3, 46, 3, 46, 3, 46, 3, 46, 3, 46, 3, 46, 3, 46, 7, 46, 891, 10, 46,
	12, 46, 14, 46, 894, 11, 46, 3, 46, 3, 46, 5, 46, 898, 10, 46, 3, 47, 3,
	47, 3, 48, 3, 48, 5, 48, 904, 10, 48, 3, 49, 7, 49, 907, 10, 49, 12, 49,
	14, 49, 910, 11, 49, 3, 49, 3, 49, 3, 49, 5, 49, 915, 10, 49, 3, 49, 5,
	49, 918, 10, 49, 3, 49, 5, 49, 921, 10, 49, 3, 49, 3, 49, 3, 50, 3, 50,
	3, 50, 3, 50, 3, 50, 3, 50, 3, 50, 3, 50, 5, 50, 933, 10, 50, 3, 51, 3,
	51, 3, 51, 3, 51, 3, 52, 3, 52, 3, 52, 7, 52, 942, 10, 52, 12, 52, 14,
	52, 945, 11, 52, 3, 53, 3, 53, 3, 53, 3, 54, 3, 54, 3, 54, 3, 55, 3, 55,
	3, 55, 7, 55, 956, 10, 55, 12, 55, 14, 55, 959, 11, 55, 3, 56, 3, 56, 7,
	56, 963, 10, 56, 12, 56, 14, 56, 966, 11, 56, 3, 56, 3, 56, 3, 57, 3, 57,
	3, 57, 3, 57, 5, 57, 974, 10, 57, 3, 58, 3, 58, 3, 58, 3, 58, 3, 58, 5,
	58, 981, 10, 58, 3, 59, 7, 59, 984, 10, 59, 12, 59, 14, 59, 987, 11, 59,
	3, 59, 3, 59, 3, 59, 3, 59, 3, 60, 3, 60, 3, 60, 3, 60, 3, 60, 3, 60, 3,
	60, 3, 60, 5, 60, 1001, 10, 60, 3, 61, 3, 61, 3, 61, 7, 61, 1006, 10, 61,
	12, 61, 14, 61, 1009, 11, 61, 3, 62, 3, 62, 3, 62, 5, 62, 1014, 10, 62,
	3, 63, 3, 63, 5, 63, 1018, 10, 63, 3, 64, 3, 64, 5, 64, 1022, 10, 64, 3,
	65, 3, 65, 5, 65, 1026, 10, 65, 3, 66, 3, 66, 5, 66, 1030, 10, 66, 3, 67,
	3, 67, 3, 67, 5, 67, 1035, 10, 67, 3, 68, 3, 68, 5, 68, 1039, 10, 68, 3,
	68, 3, 68, 7, 68, 1043, 10, 68, 12, 68, 14, 68, 1046, 11, 68, 3, 69, 3,
	69, 5, 69, 1050, 10, 69, 3, 69, 3, 69, 3, 69, 7, 69, 1055, 10, 69, 12,
	69, 14, 69, 1058, 11, 69, 3, 69, 3, 69, 5, 69, 1062, 10, 69, 5, 69, 1064,
	10, 69, 3, 70, 3, 70, 7, 70, 1068, 10, 70, 12, 70, 14, 70, 1071, 11, 70,
	3, 70, 3, 70, 5, 70, 1075, 10, 70, 3, 71, 3, 71, 5, 71, 1079, 10, 71, 3,
	72, 3, 72, 3, 73, 3, 73, 3, 74, 3, 74, 3, 75, 3, 75, 3, 76, 3, 76, 3, 76,
	3, 76, 3, 76, 3, 76, 3, 76, 3, 76, 3, 76, 5, 76, 1098, 10, 76, 3, 77, 7,
	77, 1101, 10, 77, 12, 77, 14, 77, 1104, 11, 77, 3, 77, 3, 77, 3, 77, 3,
	78, 3, 78, 3, 78, 3, 78, 3, 78, 3, 78, 3, 78, 3, 78, 3, 78, 3, 78, 5, 78,
	1119, 10, 78, 3, 79, 3, 79, 3, 79, 5, 79, 1124, 10, 79, 3, 79, 3, 79, 7,
	79, 1128, 10, 79, 12, 79, 14, 79, 1131, 11, 79, 3, 79, 3, 79, 3, 79, 5,
	79, 1136, 10, 79, 5, 79, 1138, 10, 79, 3, 80, 3, 80, 5, 80, 1142, 10, 80,
	3, 81, 3, 81, 3, 81, 5, 81, 1147, 10, 81, 3, 81, 3, 81, 5, 81, 1151, 10,
	81, 3, 82, 3, 82, 3, 82, 3, 82, 3, 82, 3, 82, 5, 82, 1159, 10, 82, 3, 83,
	3, 83, 3, 83, 7, 83, 1164, 10, 83, 12, 83, 14, 83, 1167, 11, 83, 3, 83,
	3, 83, 3, 83, 7, 83, 1172, 10, 83, 12, 83, 14, 83, 1175, 11, 83, 5, 83,
	1177, 10, 83, 3, 84, 7, 84, 1180, 10, 84, 12, 84, 14, 84, 1183, 11, 84,
	3, 84, 3, 84, 3, 84, 3, 85, 3, 85, 5, 85, 1190, 10, 85, 3, 86, 7, 86, 1193,
	10, 86, 12, 86, 14, 86, 1196, 11, 86, 3, 86, 3, 86, 7, 86, 1200, 10, 86,
	12, 86, 14, 86, 1203, 11, 86, 3, 86, 3, 86, 3, 86, 3, 86, 5, 86, 1209,
	10, 86, 3, 87, 7, 87, 1212, 10, 87, 12, 87, 14, 87, 1215, 11, 87, 3, 87,
	3, 87, 3, 87, 3, 87, 5, 87, 1221, 10, 87, 3, 87, 3, 87, 3, 88, 3, 88, 3,
	88, 3, 89, 3, 89, 3, 89, 7, 89, 1231, 10, 89, 12, 89, 14, 89, 1234, 11,
	89, 3, 90, 3, 90, 5, 90, 1238, 10, 90, 3, 91, 3, 91, 5, 91, 1242, 10, 91,
	3, 92, 3, 92, 3, 93, 3, 93, 3, 93, 3, 94, 7, 94, 1250, 10, 94, 12, 94,
	14, 94, 1253, 11, 94, 3, 94, 3, 94, 5, 94, 1257, 10, 94, 3, 94, 3, 94,
	3, 95, 3, 95, 3, 95, 3, 95, 5, 95, 1265, 10, 95, 3, 96, 5, 96, 1268, 10,
	96, 3, 96, 3, 96, 3, 96, 5, 96, 1273, 10, 96, 3, 96, 3, 96, 3, 97, 3, 97,
	3, 98, 3, 98, 5, 98, 1281, 10, 98, 3, 98, 5, 98, 1284, 10, 98, 3, 98, 3,
	98, 3, 99, 5, 99, 1289, 10, 99, 3, 99, 3, 99, 3, 99, 5, 99, 1294, 10, 99,
	3, 99, 3, 99, 3, 99, 5, 99, 1299, 10, 99, 3, 99, 3, 99, 3, 99, 5, 99, 1304,
	10, 99, 3, 99, 3, 99, 3, 99, 3, 99, 3, 99, 5, 99, 1311, 10, 99, 3, 99,
	3, 99, 3, 99, 5, 99, 1316, 10, 99, 3, 99, 3, 99, 3, 99, 3, 99, 3, 99, 3,
	99, 5, 99, 1324, 10, 99, 3, 99, 3, 99, 3, 99, 5, 99, 1329, 10, 99, 3, 99,
	3, 99, 3, 99, 5, 99, 1334, 10, 99, 3, 100, 7, 100, 1337, 10, 100, 12, 100,
	14, 100, 1340, 11, 100, 3, 100, 3, 100, 3, 100, 5, 100, 1345, 10, 100,
	3, 100, 3, 100, 3, 101, 3, 101, 5, 101, 1351, 10, 101, 3, 101, 5, 101,
	1354, 10, 101, 3, 101, 5, 101, 1357, 10, 101, 3, 101, 3, 101, 3, 102, 3,
	102, 3, 102, 7, 102, 1364, 10, 102, 12, 102, 14, 102, 1367, 11, 102, 3,
	103, 7, 103, 1370, 10, 103, 12, 103, 14, 103, 1373, 11, 103, 3, 103, 3,
	103, 3, 103, 5, 103, 1378, 10, 103, 3, 103, 5, 103, 1381, 10, 103, 3, 103,
	5, 103, 1384, 10, 103, 3, 104, 3, 104, 3, 105, 3, 105, 7, 105, 1390, 10,
	105, 12, 105, 14, 105, 1393, 11, 105, 3, 106, 3, 106, 5, 106, 1397, 10,
	106, 3, 107, 7, 107, 1400, 10, 107, 12, 107, 14, 107, 1403, 11, 107, 3,
	107, 3, 107, 3, 107, 5, 107, 1408, 10, 107, 3, 107, 5, 107, 1411, 10, 107,
	3, 107, 3, 107, 3, 108, 3, 108, 3, 108, 3, 108, 3, 108, 3, 108, 3, 108,
	5, 108, 1422, 10, 108, 3, 109, 3, 109, 3, 109, 3, 110, 3, 110, 7, 110,
	1429, 10, 110, 12, 110, 14, 110, 1432, 11, 110, 3, 110, 3, 110, 3, 111,
	3, 111, 3, 111, 3, 111, 3, 111, 5, 111, 1441, 10, 111, 3, 112, 7, 112,
	1444, 10, 112, 12, 112, 14, 112, 1447, 11, 112, 3, 112, 3, 112, 3, 112,
	3, 112, 3, 113, 3, 113, 3, 113, 3, 113, 5, 113, 1457, 10, 113, 3, 114,
	7, 114, 1460, 10, 114, 12, 114, 14, 114, 1463, 11, 114, 3, 114, 3, 114,
	3, 114, 3, 115, 3, 115, 3, 115, 3, 115, 3, 115, 3, 115, 3, 115, 5, 115,
	1475, 10, 115, 3, 116, 7, 116, 1478, 10, 116, 12, 116, 14, 116, 1481, 11,
	116, 3, 116, 3, 116, 3, 116, 3, 116, 3, 116, 3, 117, 3, 117, 7, 117, 1490,
	10, 117, 12, 117, 14, 117, 1493, 11, 117, 3, 117, 3, 117, 3, 118, 3, 118,
	3, 118, 3, 118, 3, 118, 5, 118, 1502, 10, 118, 3, 119, 7, 119, 1505, 10,
	119, 12, 119, 14, 119, 1508, 11, 119, 3, 119, 3, 119, 3, 119, 3, 119, 3,
	119, 5, 119, 1515, 10, 119, 3, 119, 5, 119, 1518, 10, 119, 3, 119, 3, 119,
	3, 120, 3, 120, 3, 120, 5, 120, 1525, 10, 120, 3, 121, 3, 121, 3, 121,
	3, 122, 3, 122, 3, 122, 5, 122, 1533, 10, 122, 3, 123, 3, 123, 3, 123,
	3, 123, 5, 123, 1539, 10, 123, 3, 123, 3, 123, 3, 124, 3, 124, 3, 124,
	7, 124, 1546, 10, 124, 12, 124, 14, 124, 1549, 11, 124, 3, 125, 3, 125,
	3, 125, 3, 125, 3, 126, 3, 126, 3, 126, 5, 126, 1558, 10, 126, 3, 127,
	3, 127, 5, 127, 1562, 10, 127, 3, 127, 5, 127, 1565, 10, 127, 3, 127, 3,
	127, 3, 128, 3, 128, 3, 128, 7, 128, 1572, 10, 128, 12, 128, 14, 128, 1575,
	11, 128, 3, 129, 3, 129, 3, 129, 3, 130, 3, 130, 3, 130, 3, 130, 3, 130,
	3, 130, 3, 131, 3, 131, 5, 131, 1588, 10, 131, 3, 131, 5, 131, 1591, 10,
	131, 3, 131, 3, 131, 3, 132, 3, 132, 3, 132, 7, 132, 1598, 10, 132, 12,
	132, 14, 132, 1601, 11, 132, 3, 133, 3, 133, 5, 133, 1605, 10, 133, 3,
	133, 3, 133, 3, 134, 6, 134, 1610, 10, 134, 13, 134, 14, 134, 1611, 3,
	135, 3, 135, 3, 135, 5, 135, 1617, 10, 135, 3, 136, 3, 136, 3, 136, 3,
	137, 7, 137, 1623, 10, 137, 12, 137, 14, 137, 1626, 11, 137, 3, 137, 3,
	137, 3, 137, 3, 138, 3, 138, 3, 138, 3, 138, 3, 138, 3, 138, 5, 138, 1637,
	10, 138, 3, 139, 3, 139, 3, 139, 3, 139, 3, 139, 5, 139, 1644, 10, 139,
	3, 140, 3, 140, 3, 140, 3, 140, 3, 140, 3, 140, 3, 140, 3, 140, 3, 140,
	3, 140, 3, 140, 3, 140, 5, 140, 1658, 10, 140, 3, 141, 3, 141, 3, 142,
	3, 142, 3, 142, 3, 142, 3, 143, 3, 143, 3, 143, 3, 143, 3, 144, 3, 144,
	3, 144, 3, 145, 3, 145, 3, 145, 3, 145, 3, 145, 3, 145, 3, 145, 5, 145,
	1680, 10, 145, 3, 146, 3, 146, 3, 146, 3, 146, 3, 146, 3, 146, 3, 147,
	3, 147, 3, 147, 3, 147, 3, 147, 3, 147, 3, 147, 3, 147, 3, 148, 3, 148,
	3, 148, 3, 148, 3, 148, 3, 148, 3, 148, 3, 148, 3, 149, 3, 149, 3, 149,
	3, 149, 3, 149, 3, 149, 3, 149, 3, 149, 3, 149, 3, 149, 5, 149, 1714, 10,
	149, 3, 150, 3, 150, 3, 150, 3, 150, 3, 150, 3, 150, 3, 151, 3, 151, 7,
	151, 1724, 10, 151, 12, 151, 14, 151, 1727, 11, 151, 3, 151, 7, 151, 1730,
	10, 151, 12, 151, 14, 151, 1733, 11, 151, 3, 151, 3, 151, 3, 152, 3, 152,
	3, 152, 3, 153, 6, 153, 1741, 10, 153, 13, 153, 14, 153, 1742, 3, 154,
	3, 154, 3, 154, 3, 154, 3, 154, 3, 154, 3, 154, 3, 154, 3, 154, 3, 154,
	5, 154, 1755, 10, 154, 3, 155, 3, 155, 3, 156, 3, 156, 3, 156, 3, 156,
	3, 156, 3, 156, 3, 157, 3, 157, 3, 157, 3, 157, 3, 157, 3, 157, 3, 158,
	3, 158, 3, 158, 3, 158, 3, 158, 3, 158, 3, 158, 3, 158, 3, 159, 3, 159,
	5, 159, 1781, 10, 159, 3, 160, 3, 160, 5, 160, 1785, 10, 160, 3, 161, 3,
	161, 3, 161, 5, 161, 1790, 10, 161, 3, 161, 3, 161, 5, 161, 1794, 10, 161,
	3, 161, 3, 161, 5, 161, 1798, 10, 161, 3, 161, 3, 161, 3, 161, 3, 162,
	3, 162, 3, 162, 5, 162, 1806, 10, 162, 3, 162, 3, 162, 5, 162, 1810, 10,
	162, 3, 162, 3, 162, 5, 162, 1814, 10, 162, 3, 162, 3, 162, 3, 162, 3,
	163, 3, 163, 5, 163, 1821, 10, 163, 3, 164, 3, 164, 3, 165, 3, 165, 3,
	165, 7, 165, 1828, 10, 165, 12, 165, 14, 165, 1831, 11, 165, 3, 166, 3,
	166, 3, 166, 7, 166, 1836, 10, 166, 12, 166, 14, 166, 1839, 11, 166, 3,
	166, 3, 166, 3, 166, 3, 166, 3, 166, 3, 166, 3, 166, 3, 167, 3, 167, 3,
	167, 7, 167, 1851, 10, 167, 12, 167, 14, 167, 1854, 11, 167, 3, 167, 3,
	167, 3, 167, 3, 167, 3, 167, 3, 167, 3, 167, 3, 168, 3, 168, 5, 168, 1865,
	10, 168, 3, 168, 3, 168, 3, 169, 3, 169, 5, 169, 1871, 10, 169, 3, 169,
	3, 169, 3, 170, 3, 170, 5, 170, 1877, 10, 170, 3, 170, 3, 170, 3, 171,
	3, 171, 3, 171, 3, 171, 3, 172, 3, 172, 3, 172, 3, 172, 3, 172, 3, 172,
	3, 173, 3, 173, 3, 173, 3, 173, 3, 173, 3, 173, 3, 173, 5, 173, 1898, 10,
	173, 3, 173, 3, 173, 3, 173, 5, 173, 1903, 10, 173, 3, 174, 6, 174, 1906,
	10, 174, 13, 174, 14, 174, 1907, 3, 175, 3, 175, 3, 175, 3, 175, 3, 175,
	3, 175, 3, 176, 7, 176, 1917, 10, 176, 12, 176, 14, 176, 1920, 11, 176,
	3, 176, 3, 176, 3, 176, 3, 177, 3, 177, 3, 177, 7, 177, 1928, 10, 177,
	12, 177, 14, 177, 1931, 11, 177, 3, 178, 3, 178, 3, 178, 3, 179, 3, 179,
	3, 179, 3, 179, 5, 179, 1940, 10, 179, 3, 179, 5, 179, 1943, 10, 179, 3,
	180, 3, 180, 3, 180, 5, 180, 1948, 10, 180, 3, 180, 3, 180, 3, 181, 3,
	181, 3, 181, 7, 181, 1955, 10, 181, 12, 181, 14, 181, 1958, 11, 181, 3,
	182, 7, 182, 1961, 10, 182, 12, 182, 14, 182, 1964, 11, 182, 3, 182, 3,
	182, 3, 182, 3, 182, 3, 182, 3, 182, 5, 182, 1972, 10, 182, 3, 183, 3,
	183, 5, 183, 1976, 10, 183, 3, 184, 3, 184, 5, 184, 1980, 10, 184, 3, 184,
	7, 184, 1983, 10, 184, 12, 184, 14, 184, 1986, 11, 184, 3, 185, 3, 185,
	3, 185, 3, 185, 3, 185, 3, 185, 3, 185, 3, 185, 3, 185, 3, 185, 3, 185,
	3, 185, 3, 185, 3, 185, 3, 185, 3, 185, 5, 185, 2004, 10, 185, 3, 186,
	3, 186, 3, 187, 3, 187, 3, 187, 3, 187, 7, 187, 2012, 10, 187, 12, 187,
	14, 187, 2015, 11, 187, 3, 187, 3, 187, 3, 187, 3, 187, 3, 187, 3, 187,
	3, 187, 3, 187, 3, 187, 3, 187, 3, 187, 3, 187, 3, 187, 3, 187, 3, 187,
	3, 187, 3, 187, 3, 187, 3, 187, 5, 187, 2036, 10, 187, 3, 188, 3, 188,
	3, 188, 3, 188, 3, 188, 5, 188, 2043, 10, 188, 3, 189, 3, 189, 3, 190,
	3, 190, 3, 190, 3, 190, 5, 190, 2051, 10, 190, 3, 191, 3, 191, 3, 191,
	3, 191, 7, 191, 2057, 10, 191, 12, 191, 14, 191, 2060, 11, 191, 3, 191,
	3, 191, 3, 191, 3, 191, 3, 191, 3, 191, 7, 191, 2068, 10, 191, 12, 191,
	14, 191, 2071, 11, 191, 3, 191, 3, 191, 3, 191, 3, 191, 3, 191, 3, 191,
	3, 191, 3, 191, 3, 191, 3, 191, 3, 191, 3, 191, 3, 191, 3, 191, 3, 191,
	3, 191, 3, 191, 3, 191, 3, 191, 3, 191, 5, 191, 2093, 10, 191, 3, 192,
	3, 192, 3, 193, 3, 193, 3, 193, 3, 193, 7, 193, 2101, 10, 193, 12, 193,
	14, 193, 2104, 11, 193, 3, 193, 3, 193, 3, 193, 3, 193, 3, 193, 3, 193,
	7, 193, 2112, 10, 193, 12, 193, 14, 193, 2115, 11, 193, 3, 193, 3, 193,
	3, 193, 3, 193, 3, 193, 3, 193, 3, 193, 3, 193, 3, 193, 3, 193, 3, 193,
	3, 193, 3, 193, 3, 193, 3, 193, 3, 193, 3, 193, 3, 193, 3, 193, 5, 193,
	2136, 10, 193, 3, 194, 3, 194, 3, 194, 5, 194, 2141, 10, 194, 3, 194, 3,
	194, 7, 194, 2145, 10, 194, 12, 194, 14, 194, 2148, 11, 194, 3, 194, 3,
	194, 3, 194, 3, 194, 3, 194, 5, 194, 2155, 10, 194, 3, 195, 3, 195, 5,
	195, 2159, 10, 195, 3, 195, 7, 195, 2162, 10, 195, 12, 195, 14, 195, 2165,
	11, 195, 3, 195, 3, 195, 3, 195, 7, 195, 2170, 10, 195, 12, 195, 14, 195,
	2173, 11, 195, 3, 195, 7, 195, 2176, 10, 195, 12, 195, 14, 195, 2179, 11,
	195, 3, 195, 5, 195, 2182, 10, 195, 3, 195, 3, 195, 5, 195, 2186, 10, 195,
	3, 195, 3, 195, 5, 195, 2190, 10, 195, 3, 195, 3, 195, 3, 195, 3, 195,
	5, 195, 2196, 10, 195, 3, 195, 7, 195, 2199, 10, 195, 12, 195, 14, 195,
	2202, 11, 195, 3, 195, 3, 195, 5, 195, 2206, 10, 195, 3, 195, 3, 195, 5,
	195, 2210, 10, 195, 3, 195, 3, 195, 5, 195, 2214, 10, 195, 3, 195, 3, 195,
	3, 195, 3, 195, 5, 195, 2220, 10, 195, 3, 195, 7, 195, 2223, 10, 195, 12,
	195, 14, 195, 2226, 11, 195, 3, 195, 3, 195, 5, 195, 2230, 10, 195, 3,
	195, 3, 195, 5, 195, 2234, 10, 195, 3, 195, 3, 195, 5, 195, 2238, 10, 195,
	5, 195, 2240, 10, 195, 3, 196, 3, 196, 3, 196, 5, 196, 2245, 10, 196, 3,
	196, 7, 196, 2248, 10, 196, 12, 196, 14, 196, 2251, 11, 196, 3, 196, 3,
	196, 5, 196, 2255, 10, 196, 3, 196, 3, 196, 5, 196, 2259, 10, 196, 3, 196,
	3, 196, 5, 196, 2263, 10, 196, 3, 197, 3, 197, 5, 197, 2267, 10, 197, 3,
	197, 7, 197, 2270, 10, 197, 12, 197, 14, 197, 2273, 11, 197, 3, 197, 3,
	197, 3, 197, 7, 197, 2278, 10, 197, 12, 197, 14, 197, 2281, 11, 197, 3,
	197, 7, 197, 2284, 10, 197, 12, 197, 14, 197, 2287, 11, 197, 3, 197, 5,
	197, 2290, 10, 197, 3, 197, 3, 197, 5, 197, 2294, 10, 197, 3, 197, 3, 197,
	5, 197, 2298, 10, 197, 3, 197, 3, 197, 3, 197, 3, 197, 5, 197, 2304, 10,
	197, 3, 197, 7, 197, 2307, 10, 197, 12, 197, 14, 197, 2310, 11, 197, 3,
	197, 3, 197, 5, 197, 2314, 10, 197, 3, 197, 3, 197, 5, 197, 2318, 10, 197,
	3, 197, 3, 197, 5, 197, 2322, 10, 197, 5, 197, 2324, 10, 197, 3, 198, 3,
	198, 3, 198, 5, 198, 2329, 10, 198, 3, 199, 3, 199, 3, 199, 3, 199, 3,
	199, 3, 199, 3, 199, 3, 199, 3, 199, 3, 199, 3, 199, 3, 199, 3, 199, 5,
	199, 2344, 10, 199, 3, 200, 3, 200, 3, 200, 3, 201, 3, 201, 3, 201, 3,
	201, 3, 201, 3, 201, 3, 201, 3, 201, 3, 201, 5, 201, 2358, 10, 201, 3,
	202, 3, 202, 3, 202, 3, 202, 3, 202, 3, 202, 3, 202, 3, 202, 3, 202, 3,
	202, 5, 202, 2370, 10, 202, 3, 202, 3, 202, 3, 202, 3, 202, 3, 202, 7,
	202, 2377, 10, 202, 12, 202, 14, 202, 2380, 11, 202, 3, 203, 3, 203, 3,
	203, 3, 203, 3, 203, 3, 203, 3, 203, 3, 203, 3, 203, 3, 203, 7, 203, 2392,
	10, 203, 12, 203, 14, 203, 2395, 11, 203, 3, 204, 3, 204, 3, 204, 3, 204,
	3, 204, 3, 204, 3, 204, 3, 204, 3, 204, 3, 204, 5, 204, 2407, 10, 204,
	3, 204, 3, 204, 3, 204, 3, 204, 3, 204, 7, 204, 2414, 10, 204, 12, 204,
	14, 204, 2417, 11, 204, 3, 205, 3, 205, 3, 205, 5, 205, 2422, 10, 205,
	3, 205, 3, 205, 3, 205, 3, 205, 3, 205, 5, 205, 2429, 10, 205, 3, 205,
	3, 205, 3, 205, 5, 205, 2434, 10, 205, 3, 205, 3, 205, 3, 205, 3, 205,
	3, 205, 5, 205, 2441, 10, 205, 3, 205, 3, 205, 3, 205, 5, 205, 2446, 10,
	205, 3, 205, 3, 205, 3, 205, 3, 205, 3, 205, 5, 205, 2453, 10, 205, 3,
	205, 3, 205, 3, 205, 5, 205, 2458, 10, 205, 3, 205, 3, 205, 3, 205, 3,
	205, 3, 205, 5, 205, 2465, 10, 205, 3, 205, 3, 205, 3, 205, 5, 205, 2470,
	10, 205, 3, 205, 3, 205, 3, 205, 3, 205, 3, 205, 3, 205, 3, 205, 5, 205,
	2479, 10, 205, 3, 205, 3, 205, 3, 205, 5, 205, 2484, 10, 205, 3, 205, 3,
	205, 5, 205, 2488, 10, 205, 3, 206, 3, 206, 5, 206, 2492, 10, 206, 3, 206,
	3, 206, 3, 206, 5, 206, 2497, 10, 206, 3, 206, 3, 206, 3, 207, 3, 207,
	3, 207, 5, 207, 2504, 10, 207, 3, 207, 3, 207, 3, 207, 3, 207, 3, 207,
	5, 207, 2511, 10, 207, 3, 207, 3, 207, 3, 207, 5, 207, 2516, 10, 207, 3,
	207, 3, 207, 3, 207, 3, 207, 3, 207, 5, 207, 2523, 10, 207, 3, 207, 3,
	207, 3, 207, 5, 207, 2528, 10, 207, 3, 207, 3, 207, 3, 207, 3, 207, 3,
	207, 5, 207, 2535, 10, 207, 3, 207, 3, 207, 3, 207, 5, 207, 2540, 10, 207,
	3, 207, 3, 207, 3, 207, 3, 207, 3, 207, 3, 207, 3, 207, 5, 207, 2549, 10,
	207, 3, 207, 3, 207, 3, 207, 5, 207, 2554, 10, 207, 3, 207, 3, 207, 5,
	207, 2558, 10, 207, 3, 208, 3, 208, 3, 208, 7, 208, 2563, 10, 208, 12,
	208, 14, 208, 2566, 11, 208, 3, 209, 3, 209, 3, 209, 5, 209, 2571, 10,
	209, 3, 209, 3, 209, 3, 209, 3, 209, 3, 209, 5, 209, 2578, 10, 209, 3,
	209, 3, 209, 3, 209, 3, 209, 3, 209, 5, 209, 2585, 10, 209, 3, 209, 3,
	209, 3, 209, 3, 209, 3, 209, 5, 209, 2592, 10, 209, 3, 209, 3, 209, 3,
	209, 3, 209, 3, 209, 3, 209, 5, 209, 2600, 10, 209, 3, 209, 3, 209, 3,
	209, 3, 209, 3, 209, 5, 209, 2607, 10, 209, 3, 209, 3, 209, 3, 209, 3,
	209, 3, 209, 3, 209, 5, 209, 2615, 10, 209, 3, 210, 3, 210, 5, 210, 2619,
	10, 210, 3, 210, 3, 210, 3, 211, 3, 211, 3, 211, 5, 211, 2626, 10, 211,
	3, 211, 3, 211, 3, 211, 3, 211, 3, 211, 5, 211, 2633, 10, 211, 3, 211,
	3, 211, 3, 211, 3, 211, 3, 211, 5, 211, 2640, 10, 211, 3, 211, 3, 211,
	3, 211, 3, 211, 3, 211, 3, 211, 5, 211, 2648, 10, 211, 3, 211, 3, 211,
	3, 211, 3, 211, 3, 211, 5, 211, 2655, 10, 211, 3, 211, 3, 211, 3, 211,
	3, 211, 3, 211, 3, 211, 5, 211, 2663, 10, 211, 3, 212, 3, 212, 3, 212,
	3, 212, 5, 212, 2669, 10, 212, 3, 212, 3, 212, 3, 212, 3, 212, 5, 212,
	2675, 10, 212, 3, 212, 3, 212, 3, 212, 3, 212, 3, 212, 3, 212, 3, 212,
	3, 212, 3, 212, 3, 212, 5, 212, 2687, 10, 212, 3, 213, 6, 213, 2690, 10,
	213, 13, 213, 14, 213, 2691, 3, 214, 7, 214, 2695, 10, 214, 12, 214, 14,
	214, 2698, 11, 214, 3, 214, 3, 214, 3, 214, 3, 214, 3, 215, 3, 215, 3,
	216, 3, 216, 5, 216, 2708, 10, 216, 3, 217, 3, 217, 3, 217, 3, 217, 3,
	218, 3, 218, 3, 218, 5, 218, 2717, 10, 218, 3, 218, 3, 218, 3, 218, 3,
	218, 3, 218, 5, 218, 2724, 10, 218, 3, 219, 3, 219, 3, 219, 7, 219, 2729,
	10, 219, 12, 219, 14, 219, 2732, 11, 219, 3, 220, 3, 220, 5, 220, 2736,
	10, 220, 3, 221, 3, 221, 5, 221, 2740, 10, 221, 3, 222, 3, 222, 3, 222,
	3, 222, 3, 223, 3, 223, 3, 223, 5, 223, 2749, 10, 223, 3, 224, 3, 224,
	3, 225, 3, 225, 3, 225, 3, 225, 3, 225, 3, 225, 3, 225, 5, 225, 2760, 10,
	225, 5, 225, 2762, 10, 225, 3, 226, 3, 226, 3, 226, 3, 226, 3, 226, 3,
	226, 7, 226, 2770, 10, 226, 12, 226, 14, 226, 2773, 11, 226, 3, 227, 3,
	227, 3, 227, 3, 227, 3, 227, 3, 227, 7, 227, 2781, 10, 227, 12, 227, 14,
	227, 2784, 11, 227, 3, 228, 3, 228, 3, 228, 3, 228, 3, 228, 3, 228, 7,
	228, 2792, 10, 228, 12, 228, 14, 228, 2795, 11, 228, 3, 229, 3, 229, 3,
	229, 3, 229, 3, 229, 3, 229, 7, 229, 2803, 10, 229, 12, 229, 14, 229, 2806,
	11, 229, 3, 230, 3, 230, 3, 230, 3, 230, 3, 230, 3, 230, 7, 230, 2814,
	10, 230, 12, 230, 14, 230, 2817, 11, 230, 3, 231, 3, 231, 3, 231, 3, 231,
	3, 231, 3, 231, 3, 231, 3, 231, 3, 231, 7, 231, 2828, 10, 231, 12, 231,
	14, 231, 2831, 11, 231, 3, 232, 3, 232, 3, 232, 3, 232, 3, 232, 3, 232,
	3, 232, 3, 232, 3, 232, 3, 232, 3, 232, 3, 232, 3, 232, 3, 232, 3, 232,
	3, 232, 3, 232, 3, 232, 7, 232, 2851, 10, 232, 12, 232, 14, 232, 2854,
	11, 232, 3, 233, 3, 233, 3, 233, 3, 233, 3, 233, 3, 233, 3, 233, 3, 233,
	3, 233, 3, 233, 3, 233, 3, 233, 3, 233, 3, 233, 3, 233, 3, 233, 7, 233,
	2872, 10, 233, 12, 233, 14, 233, 2875, 11, 233, 3, 234, 3, 234, 3, 234,
	3, 234, 3, 234, 3, 234, 3, 234, 3, 234, 3, 234, 7, 234, 2886, 10, 234,
	12, 234, 14, 234, 2889, 11, 234, 3, 235, 3, 235, 3, 235, 3, 235, 3, 235,
	3, 235, 3, 235, 3, 235, 3, 235, 3, 235, 3, 235, 3, 235, 7, 235, 2903, 10,
	235, 12, 235, 14, 235, 2906, 11, 235, 3, 236, 3, 236, 3, 236, 3, 236, 3,
	236, 3, 236, 3, 236, 5, 236, 2915, 10, 236, 3, 237, 3, 237, 3, 237, 3,
	238, 3, 238, 3, 238, 3, 239, 3, 239, 3, 239, 3, 239, 3, 239, 3, 239, 5,
	239, 2929, 10, 239, 3, 240, 3, 240, 5, 240, 2933, 10, 240, 3, 240, 3, 240,
	7, 240, 2937, 10, 240, 12, 240, 14, 240, 2940, 11, 240, 3, 241, 3, 241,
	3, 241, 3, 242, 3, 242, 3, 243, 3, 243, 3, 243, 3, 244, 3, 244, 3, 245,
	3, 245, 3, 245, 3, 245, 3, 245, 3, 245, 3, 245, 3, 245, 7, 245, 2960, 10,
	245, 12, 245, 14, 245, 2963, 11, 245, 3, 245, 3, 245, 3, 245, 3, 245, 3,
	245, 3, 245, 7, 245, 2971, 10, 245, 12, 245, 14, 245, 2974, 11, 245, 3,
	245, 3, 245, 3, 245, 5, 245, 2979, 10, 245, 3, 246, 3, 246, 3, 246, 2,
	16, 52, 54, 58, 64, 450, 452, 454, 456, 458, 460, 462, 464, 466, 468, 247,
	2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28, 30, 32, 34, 36, 38,
	40, 42, 44, 46, 48, 50, 52, 54, 56, 58, 60, 62, 64, 66, 68, 70, 72, 74,
	76, 78, 80, 82, 84, 86, 88, 90, 92, 94, 96, 98, 100, 102, 104, 106, 108,
	110, 112, 114, 116, 118, 120, 122, 124, 126, 128, 130, 132, 134, 136, 138,
	140, 142, 144, 146, 148, 150, 152, 154, 156, 158, 160, 162, 164, 166, 168,
	170, 172, 174, 176, 178, 180, 182, 184, 186, 188, 190, 192, 194, 196, 198,
	200, 202, 204, 206, 208, 210, 212, 214, 216, 218, 220, 222, 224, 226, 228,
	230, 232, 234, 236, 238, 240, 242, 244, 246, 248, 250, 252, 254, 256, 258,
	260, 262, 264, 266, 268, 270, 272, 274, 276, 278, 280, 282, 284, 286, 288,
	290, 292, 294, 296, 298, 300, 302, 304, 306, 308, 310, 312, 314, 316, 318,
	320, 322, 324, 326, 328, 330, 332, 334, 336, 338, 340, 342, 344, 346, 348,
	350, 352, 354, 356, 358, 360, 362, 364, 366, 368, 370, 372, 374, 376, 378,
	380, 382, 384, 386, 388, 390, 392, 394, 396, 398, 400, 402, 404, 406, 408,
	410, 412, 414, 416, 418, 420, 422, 424, 426, 428, 430, 432, 434, 436, 438,
	440, 442, 444, 446, 448, 450, 452, 454, 456, 458, 460, 462, 464, 466, 468,
	470, 472, 474, 476, 478, 480, 482, 484, 486, 488, 490, 2, 8, 3, 2, 64,
	69, 7, 2, 7, 7, 10, 10, 30, 30, 32, 32, 45, 45, 4, 2, 16, 16, 23, 23, 4,
	2, 46, 46, 56, 56, 4, 2, 82, 82, 106, 116, 11, 2, 19, 19, 33, 33, 36, 37,
	41, 41, 43, 43, 54, 54, 58, 58, 62, 62, 117, 117, 2, 3237, 2, 492, 3, 2,
	2, 2, 4, 508, 3, 2, 2, 2, 6, 512, 3, 2, 2, 2, 8, 514, 3, 2, 2, 2, 10, 516,
	3, 2, 2, 2, 12, 521, 3, 2, 2, 2, 14, 525, 3, 2, 2, 2, 16, 556, 3, 2, 2,
	2, 18, 558, 3, 2, 2, 2, 20, 572, 3, 2, 2, 2, 22, 579, 3, 2, 2, 2, 24, 581,
	3, 2, 2, 2, 26, 583, 3, 2, 2, 2, 28, 588, 3, 2, 2, 2, 30, 602, 3, 2, 2,
	2, 32, 607, 3, 2, 2, 2, 34, 628, 3, 2, 2, 2, 36, 635, 3, 2, 2, 2, 38, 647,
	3, 2, 2, 2, 40, 649, 3, 2, 2, 2, 42, 652, 3, 2, 2, 2, 44, 656, 3, 2, 2,
	2, 46, 666, 3, 2, 2, 2, 48, 671, 3, 2, 2, 2, 50, 682, 3, 2, 2, 2, 52, 684,
	3, 2, 2, 2, 54, 695, 3, 2, 2, 2, 56, 711, 3, 2, 2, 2, 58, 713, 3, 2, 2,
	2, 60, 729, 3, 2, 2, 2, 62, 731, 3, 2, 2, 2, 64, 733, 3, 2, 2, 2, 66, 746,
	3, 2, 2, 2, 68, 749, 3, 2, 2, 2, 70, 768, 3, 2, 2, 2, 72, 776, 3, 2, 2,
	2, 74, 783, 3, 2, 2, 2, 76, 789, 3, 2, 2, 2, 78, 791, 3, 2, 2, 2, 80, 795,
	3, 2, 2, 2, 82, 801, 3, 2, 2, 2, 84, 808, 3, 2, 2, 2, 86, 818, 3, 2, 2,
	2, 88, 823, 3, 2, 2, 2, 90, 897, 3, 2, 2, 2, 92, 899, 3, 2, 2, 2, 94, 903,
	3, 2, 2, 2, 96, 908, 3, 2, 2, 2, 98, 932, 3, 2, 2, 2, 100, 934, 3, 2, 2,
	2, 102, 938, 3, 2, 2, 2, 104, 946, 3, 2, 2, 2, 106, 949, 3, 2, 2, 2, 108,
	952, 3, 2, 2, 2, 110, 960, 3, 2, 2, 2, 112, 973, 3, 2, 2, 2, 114, 980,
	3, 2, 2, 2, 116, 985, 3, 2, 2, 2, 118, 1000, 3, 2, 2, 2, 120, 1002, 3,
	2, 2, 2, 122, 1010, 3, 2, 2, 2, 124, 1015, 3, 2, 2, 2, 126, 1021, 3, 2,
	2, 2, 128, 1025, 3, 2, 2, 2, 130, 1029, 3, 2, 2, 2, 132, 1034, 3, 2, 2,
	2, 134, 1038, 3, 2, 2, 2, 136, 1063, 3, 2, 2, 2, 138, 1065, 3, 2, 2, 2,
	140, 1076, 3, 2, 2, 2, 142, 1080, 3, 2, 2, 2, 144, 1082, 3, 2, 2, 2, 146,
	1084, 3, 2, 2, 2, 148, 1086, 3, 2, 2, 2, 150, 1097, 3, 2, 2, 2, 152, 1102,
	3, 2, 2, 2, 154, 1118, 3, 2, 2, 2, 156, 1137, 3, 2, 2, 2, 158, 1141, 3,
	2, 2, 2, 160, 1143, 3, 2, 2, 2, 162, 1158, 3, 2, 2, 2, 164, 1176, 3, 2,
	2, 2, 166, 1181, 3, 2, 2, 2, 168, 1189, 3, 2, 2, 2, 170, 1208, 3, 2, 2,
	2, 172, 1213, 3, 2, 2, 2, 174, 1224, 3, 2, 2, 2, 176, 1227, 3, 2, 2, 2,
	178, 1237, 3, 2, 2, 2, 180, 1241, 3, 2, 2, 2, 182, 1243, 3, 2, 2, 2, 184,
	1245, 3, 2, 2, 2, 186, 1251, 3, 2, 2, 2, 188, 1264, 3, 2, 2, 2, 190, 1267,
	3, 2, 2, 2, 192, 1276, 3, 2, 2, 2, 194, 1278, 3, 2, 2, 2, 196, 1333, 3,
	2, 2, 2, 198, 1338, 3, 2, 2, 2, 200, 1348, 3, 2, 2, 2, 202, 1360, 3, 2,
	2, 2, 204, 1371, 3, 2, 2, 2, 206, 1385, 3, 2, 2, 2, 208, 1387, 3, 2, 2,
	2, 210, 1396, 3, 2, 2, 2, 212, 1401, 3, 2, 2, 2, 214, 1421, 3, 2, 2, 2,
	216, 1423, 3, 2, 2, 2, 218, 1426, 3, 2, 2, 2, 220, 1440, 3, 2, 2, 2, 222,
	1445, 3, 2, 2, 2, 224, 1456, 3, 2, 2, 2, 226, 1461, 3, 2, 2, 2, 228, 1474,
	3, 2, 2, 2, 230, 1479, 3, 2, 2, 2, 232, 1487, 3, 2, 2, 2, 234, 1501, 3,
	2, 2, 2, 236, 1506, 3, 2, 2, 2, 238, 1524, 3, 2, 2, 2, 240, 1526, 3, 2,
	2, 2, 242, 1532, 3, 2, 2, 2, 244, 1534, 3, 2, 2, 2, 246, 1542, 3, 2, 2,
	2, 248, 1550, 3, 2, 2, 2, 250, 1557, 3, 2, 2, 2, 252, 1559, 3, 2, 2, 2,
	254, 1568, 3, 2, 2, 2, 256, 1576, 3, 2, 2, 2, 258, 1579, 3, 2, 2, 2, 260,
	1585, 3, 2, 2, 2, 262, 1594, 3, 2, 2, 2, 264, 1602, 3, 2, 2, 2, 266, 1609,
	3, 2, 2, 2, 268, 1616, 3, 2, 2, 2, 270, 1618, 3, 2, 2, 2, 272, 1624, 3,
	2, 2, 2, 274, 1636, 3, 2, 2, 2, 276, 1643, 3, 2, 2, 2, 278, 1657, 3, 2,
	2, 2, 280, 1659, 3, 2, 2, 2, 282, 1661, 3, 2, 2, 2, 284, 1665, 3, 2, 2,
	2, 286, 1669, 3, 2, 2, 2, 288, 1679, 3, 2, 2, 2, 290, 1681, 3, 2, 2, 2,
	292, 1687, 3, 2, 2, 2, 294, 1695, 3, 2, 2, 2, 296, 1713, 3, 2, 2, 2, 298,
	1715, 3, 2, 2, 2, 300, 1721, 3, 2, 2, 2, 302, 1736, 3, 2, 2, 2, 304, 1740,
	3, 2, 2, 2, 306, 1754, 3, 2, 2, 2, 308, 1756, 3, 2, 2, 2, 310, 1758, 3,
	2, 2, 2, 312, 1764, 3, 2, 2, 2, 314, 1770, 3, 2, 2, 2, 316, 1780, 3, 2,
	2, 2, 318, 1784, 3, 2, 2, 2, 320, 1786, 3, 2, 2, 2, 322, 1802, 3, 2, 2,
	2, 324, 1820, 3, 2, 2, 2, 326, 1822, 3, 2, 2, 2, 328, 1824, 3, 2, 2, 2,
	330, 1832, 3, 2, 2, 2, 332, 1847, 3, 2, 2, 2, 334, 1862, 3, 2, 2, 2, 336,
	1868, 3, 2, 2, 2, 338, 1874, 3, 2, 2, 2, 340, 1880, 3, 2, 2, 2, 342, 1884,
	3, 2, 2, 2, 344, 1902, 3, 2, 2, 2, 346, 1905, 3, 2, 2, 2, 348, 1909, 3,
	2, 2, 2, 350, 1918, 3, 2, 2, 2, 352, 1924, 3, 2, 2, 2, 354, 1932, 3, 2,
	2, 2, 356, 1935, 3, 2, 2, 2, 358, 1944, 3, 2, 2, 2, 360, 1951, 3, 2, 2,
	2, 362, 1971, 3, 2, 2, 2, 364, 1975, 3, 2, 2, 2, 366, 1979, 3, 2, 2, 2,
	368, 2003, 3, 2, 2, 2, 370, 2005, 3, 2, 2, 2, 372, 2035, 3, 2, 2, 2, 374,
	2042, 3, 2, 2, 2, 376, 2044, 3, 2, 2, 2, 378, 2050, 3, 2, 2, 2, 380, 2092,
	3, 2, 2, 2, 382, 2094, 3, 2, 2, 2, 384, 2135, 3, 2, 2, 2, 386, 2154, 3,
	2, 2, 2, 388, 2239, 3, 2, 2, 2, 390, 2241, 3, 2, 2, 2, 392, 2323, 3, 2,
	2, 2, 394, 2328, 3, 2, 2, 2, 396, 2343, 3, 2, 2, 2, 398, 2345, 3, 2, 2,
	2, 400, 2357, 3, 2, 2, 2, 402, 2369, 3, 2, 2, 2, 404, 2381, 3, 2, 2, 2,
	406, 2406, 3, 2, 2, 2, 408, 2487, 3, 2, 2, 2, 410, 2489, 3, 2, 2, 2, 412,
	2557, 3, 2, 2, 2, 414, 2559, 3, 2, 2, 2, 416, 2614, 3, 2, 2, 2, 418, 2616,
	3, 2, 2, 2, 420, 2662, 3, 2, 2, 2, 422, 2686, 3, 2, 2, 2, 424, 2689, 3,
	2, 2, 2, 426, 2696, 3, 2, 2, 2, 428, 2703, 3, 2, 2, 2, 430, 2707, 3, 2,
	2, 2, 432, 2709, 3, 2, 2, 2, 434, 2723, 3, 2, 2, 2, 436, 2725, 3, 2, 2,
	2, 438, 2735, 3, 2, 2, 2, 440, 2739, 3, 2, 2, 2, 442, 2741, 3, 2, 2, 2,
	444, 2748, 3, 2, 2, 2, 446, 2750, 3, 2, 2, 2, 448, 2761, 3, 2, 2, 2, 450,
	2763, 3, 2, 2, 2, 452, 2774, 3, 2, 2, 2, 454, 2785, 3, 2, 2, 2, 456, 2796,
	3, 2, 2, 2, 458, 2807, 3, 2, 2, 2, 460, 2818, 3, 2, 2, 2, 462, 2832, 3,
	2, 2, 2, 464, 2855, 3, 2, 2, 2, 466, 2876, 3, 2, 2, 2, 468, 2890, 3, 2,
	2, 2, 470, 2914, 3, 2, 2, 2, 472, 2916, 3, 2, 2, 2, 474, 2919, 3, 2, 2,
	2, 476, 2928, 3, 2, 2, 2, 478, 2932, 3, 2, 2, 2, 480, 2941, 3, 2, 2, 2,
	482, 2944, 3, 2, 2, 2, 484, 2946, 3, 2, 2, 2, 486, 2949, 3, 2, 2, 2, 488,
	2978, 3, 2, 2, 2, 490, 2980, 3, 2, 2, 2, 492, 493, 9, 2, 2, 2, 493, 3,
	3, 2, 2, 2, 494, 496, 5, 242, 122, 2, 495, 494, 3, 2, 2, 2, 496, 499, 3,
	2, 2, 2, 497, 495, 3, 2, 2, 2, 497, 498, 3, 2, 2, 2, 498, 500, 3, 2, 2,
	2, 499, 497, 3, 2, 2, 2, 500, 509, 5, 6, 4, 2, 501, 503, 5, 242, 122, 2,
	502, 501, 3, 2, 2, 2, 503, 506, 3, 2, 2, 2, 504, 502, 3, 2, 2, 2, 504,
	505, 3, 2, 2, 2, 505, 507, 3, 2, 2, 2, 506, 504, 3, 2, 2, 2, 507, 509,
	7, 5, 2, 2, 508, 497, 3, 2, 2, 2, 508, 504, 3, 2, 2, 2, 509, 5, 3, 2, 2,
	2, 510, 513, 5, 8, 5, 2, 511, 513, 5, 10, 6, 2, 512, 510, 3, 2, 2, 2, 512,
	511, 3, 2, 2, 2, 513, 7, 3, 2, 2, 2, 514, 515, 9, 3, 2, 2, 515, 9, 3, 2,
	2, 2, 516, 517, 9, 4, 2, 2, 517, 11, 3, 2, 2, 2, 518, 522, 5, 14, 8, 2,
	519, 522, 5, 28, 15, 2, 520, 522, 5, 30, 16, 2, 521, 518, 3, 2, 2, 2, 521,
	519, 3, 2, 2, 2, 521, 520, 3, 2, 2, 2, 522, 13, 3, 2, 2, 2, 523, 526, 5,
	20, 11, 2, 524, 526, 5, 26, 14, 2, 525, 523, 3, 2, 2, 2, 525, 524, 3, 2,
	2, 2, 526, 531, 3, 2, 2, 2, 527, 530, 5, 18, 10, 2, 528, 530, 5, 24, 13,
	2, 529, 527, 3, 2, 2, 2, 529, 528, 3, 2, 2, 2, 530, 533, 3, 2, 2, 2, 531,
	529, 3, 2, 2, 2, 531, 532, 3, 2, 2, 2, 532, 15, 3, 2, 2, 2, 533, 531, 3,
	2, 2, 2, 534, 536, 5, 242, 122, 2, 535, 534, 3, 2, 2, 2, 536, 539, 3, 2,
	2, 2, 537, 535, 3, 2, 2, 2, 537, 538, 3, 2, 2, 2, 538, 540, 3, 2, 2, 2,
	539, 537, 3, 2, 2, 2, 540, 542, 5, 490, 246, 2, 541, 543, 5, 42, 22, 2,
	542, 541, 3, 2, 2, 2, 542, 543, 3, 2, 2, 2, 543, 557, 3, 2, 2, 2, 544,
	545, 5, 14, 8, 2, 545, 549, 7, 78, 2, 2, 546, 548, 5, 242, 122, 2, 547,
	546, 3, 2, 2, 2, 548, 551, 3, 2, 2, 2, 549, 547, 3, 2, 2, 2, 549, 550,
	3, 2, 2, 2, 550, 552, 3, 2, 2, 2, 551, 549, 3, 2, 2, 2, 552, 554, 5, 490,
	246, 2, 553, 555, 5, 42, 22, 2, 554, 553, 3, 2, 2, 2, 554, 555, 3, 2, 2,
	2, 555, 557, 3, 2, 2, 2, 556, 537, 3, 2, 2, 2, 556, 544, 3, 2, 2, 2, 557,
	17, 3, 2, 2, 2, 558, 562, 7, 78, 2, 2, 559, 561, 5, 242, 122, 2, 560, 559,
	3, 2, 2, 2, 561, 564, 3, 2, 2, 2, 562, 560, 3, 2, 2, 2, 562, 563, 3, 2,
	2, 2, 563, 565, 3, 2, 2, 2, 564, 562, 3, 2, 2, 2, 565, 567, 5, 490, 246,
	2, 566, 568, 5, 42, 22, 2, 567, 566, 3, 2, 2, 2, 567, 568, 3, 2, 2, 2,
	568, 19, 3, 2, 2, 2, 569, 571, 5, 242, 122, 2, 570, 569, 3, 2, 2, 2, 571,
	574, 3, 2, 2, 2, 572, 570, 3, 2, 2, 2, 572, 573, 3, 2, 2, 2, 573, 575,
	3, 2, 2, 2, 574, 572, 3, 2, 2, 2, 575, 577, 5, 490, 246, 2, 576, 578, 5,
	42, 22, 2, 577, 576, 3, 2, 2, 2, 577, 578, 3, 2, 2, 2, 578, 21, 3, 2, 2,
	2, 579, 580, 5, 16, 9, 2, 580, 23, 3, 2, 2, 2, 581, 582, 5, 18, 10, 2,
	582, 25, 3, 2, 2, 2, 583, 584, 5, 20, 11, 2, 584, 27, 3, 2, 2, 2, 585,
	587, 5, 242, 122, 2, 586, 585, 3, 2, 2, 2, 587, 590, 3, 2, 2, 2, 588, 586,
	3, 2, 2, 2, 588, 589, 3, 2, 2, 2, 589, 591, 3, 2, 2, 2, 590, 588, 3, 2,
	2, 2, 591, 592, 5, 490, 246, 2, 592, 29, 3, 2, 2, 2, 593, 594, 5, 4, 3,
	2, 594, 595, 5, 32, 17, 2, 595, 603, 3, 2, 2, 2, 596, 597, 5, 14, 8, 2,
	597, 598, 5, 32, 17, 2, 598, 603, 3, 2, 2, 2, 599, 600, 5, 28, 15, 2, 600,
	601, 5, 32, 17, 2, 601, 603, 3, 2, 2, 2, 602, 593, 3, 2, 2, 2, 602, 596,
	3, 2, 2, 2, 602, 599, 3, 2, 2, 2, 603, 31, 3, 2, 2, 2, 604, 606, 5, 242,
	122, 2, 605, 604, 3, 2, 2, 2, 606, 609, 3, 2, 2, 2, 607, 605, 3, 2, 2,
	2, 607, 608, 3, 2, 2, 2, 608, 610, 3, 2, 2, 2, 609, 607, 3, 2, 2, 2, 610,
	611, 7, 74, 2, 2, 611, 622, 7, 75, 2, 2, 612, 614, 5, 242, 122, 2, 613,
	612, 3, 2, 2, 2, 614, 617, 3, 2, 2, 2, 615, 613, 3, 2, 2, 2, 615, 616,
	3, 2, 2, 2, 616, 618, 3, 2, 2, 2, 617, 615, 3, 2, 2, 2, 618, 619, 7, 74,
	2, 2, 619, 621, 7, 75, 2, 2, 620, 615, 3, 2, 2, 2, 621, 624, 3, 2, 2, 2,
	622, 620, 3, 2, 2, 2, 622, 623, 3, 2, 2, 2, 623, 33, 3, 2, 2, 2, 624, 622,
	3, 2, 2, 2, 625, 627, 5, 36, 19, 2, 626, 625, 3, 2, 2, 2, 627, 630, 3,
	2, 2, 2, 628, 626, 3, 2, 2, 2, 628, 629, 3, 2, 2, 2, 629, 631, 3, 2, 2,
	2, 630, 628, 3, 2, 2, 2, 631, 633, 5, 490, 246, 2, 632, 634, 5, 38, 20,
	2, 633, 632, 3, 2, 2, 2, 633, 634, 3, 2, 2, 2, 634, 35, 3, 2, 2, 2, 635,
	636, 5, 242, 122, 2, 636, 37, 3, 2, 2, 2, 637, 638, 7, 20, 2, 2, 638, 648,
	5, 28, 15, 2, 639, 640, 7, 20, 2, 2, 640, 644, 5, 14, 8, 2, 641, 643, 5,
	40, 21, 2, 642, 641, 3, 2, 2, 2, 643, 646, 3, 2, 2, 2, 644, 642, 3, 2,
	2, 2, 644, 645, 3, 2, 2, 2, 645, 648, 3, 2, 2, 2, 646, 644, 3, 2, 2, 2,
	647, 637, 3, 2, 2, 2, 647, 639, 3, 2, 2, 2, 648, 39, 3, 2, 2, 2, 649, 650,
	7, 102, 2, 2, 650, 651, 5, 22, 12, 2, 651, 41, 3, 2, 2, 2, 652, 653, 7,
	84, 2, 2, 653, 654, 5, 44, 23, 2, 654, 655, 7, 83, 2, 2, 655, 43, 3, 2,
	2, 2, 656, 661, 5, 46, 24, 2, 657, 658, 7, 77, 2, 2, 658, 660, 5, 46, 24,
	2, 659, 657, 3, 2, 2, 2, 660, 663, 3, 2, 2, 2, 661, 659, 3, 2, 2, 2, 661,
	662, 3, 2, 2, 2, 662, 45, 3, 2, 2, 2, 663, 661, 3, 2, 2, 2, 664, 667, 5,
	12, 7, 2, 665, 667, 5, 48, 25, 2, 666, 664, 3, 2, 2, 2, 666, 665, 3, 2,
	2, 2, 667, 47, 3, 2, 2, 2, 668, 670, 5, 242, 122, 2, 669, 668, 3, 2, 2,
	2, 670, 673, 3, 2, 2, 2, 671, 669, 3, 2, 2, 2, 671, 672, 3, 2, 2, 2, 672,
	674, 3, 2, 2, 2, 673, 671, 3, 2, 2, 2, 674, 676, 7, 87, 2, 2, 675, 677,
	5, 50, 26, 2, 676, 675, 3, 2, 2, 2, 676, 677, 3, 2, 2, 2, 677, 49, 3, 2,
	2, 2, 678, 679, 7, 20, 2, 2, 679, 683, 5, 12, 7, 2, 680, 681, 7, 48, 2,
	2, 681, 683, 5, 12, 7, 2, 682, 678, 3, 2, 2, 2, 682, 680, 3, 2, 2, 2, 683,
	51, 3, 2, 2, 2, 684, 685, 8, 27, 1, 2, 685, 686, 5, 490, 246, 2, 686, 692,
	3, 2, 2, 2, 687, 688, 12, 3, 2, 2, 688, 689, 7, 78, 2, 2, 689, 691, 5,
	490, 246, 2, 690, 687, 3, 2, 2, 2, 691, 694, 3, 2, 2, 2, 692, 690, 3, 2,
	2, 2, 692, 693, 3, 2, 2, 2, 693, 53, 3, 2, 2, 2, 694, 692, 3, 2, 2, 2,
	695, 696, 8, 28, 1, 2, 696, 697, 5, 490, 246, 2, 697, 703, 3, 2, 2, 2,
	698, 699, 12, 3, 2, 2, 699, 700, 7, 78, 2, 2, 700, 702, 5, 490, 246, 2,
	701, 698, 3, 2, 2, 2, 702, 705, 3, 2, 2, 2, 703, 701, 3, 2, 2, 2, 703,
	704, 3, 2, 2, 2, 704, 55, 3, 2, 2, 2, 705, 703, 3, 2, 2, 2, 706, 712, 5,
	490, 246, 2, 707, 708, 5, 58, 30, 2, 708, 709, 7, 78, 2, 2, 709, 710, 5,
	490, 246, 2, 710, 712, 3, 2, 2, 2, 711, 706, 3, 2, 2, 2, 711, 707, 3, 2,
	2, 2, 712, 57, 3, 2, 2, 2, 713, 714, 8, 30, 1, 2, 714, 715, 5, 490, 246,
	2, 715, 721, 3, 2, 2, 2, 716, 717, 12, 3, 2, 2, 717, 718, 7, 78, 2, 2,
	718, 720, 5, 490, 246, 2, 719, 716, 3, 2, 2, 2, 720, 723, 3, 2, 2, 2, 721,
	719, 3, 2, 2, 2, 721, 722, 3, 2, 2, 2, 722, 59, 3, 2, 2, 2, 723, 721, 3,
	2, 2, 2, 724, 730, 5, 490, 246, 2, 725, 726, 5, 64, 33, 2, 726, 727, 7,
	78, 2, 2, 727, 728, 5, 490, 246, 2, 728, 730, 3, 2, 2, 2, 729, 724, 3,
	2, 2, 2, 729, 725, 3, 2, 2, 2, 730, 61, 3, 2, 2, 2, 731, 732, 5, 490, 246,
	2, 732, 63, 3, 2, 2, 2, 733, 734, 8, 33, 1, 2, 734, 735, 5, 490, 246, 2,
	735, 741, 3, 2, 2, 2, 736, 737, 12, 3, 2, 2, 737, 738, 7, 78, 2, 2, 738,
	740, 5, 490, 246, 2, 739, 736, 3, 2, 2, 2, 740, 743, 3, 2, 2, 2, 741, 739,
	3, 2, 2, 2, 741, 742, 3, 2, 2, 2, 742, 65, 3, 2, 2, 2, 743, 741, 3, 2,
	2, 2, 744, 747, 5, 68, 35, 2, 745, 747, 5, 70, 36, 2, 746, 744, 3, 2, 2,
	2, 746, 745, 3, 2, 2, 2, 747, 67, 3, 2, 2, 2, 748, 750, 5, 72, 37, 2, 749,
	748, 3, 2, 2, 2, 749, 750, 3, 2, 2, 2, 750, 754, 3, 2, 2, 2, 751, 753,
	5, 76, 39, 2, 752, 751, 3, 2, 2, 2, 753, 756, 3, 2, 2, 2, 754, 752, 3,
	2, 2, 2, 754, 755, 3, 2, 2, 2, 755, 760, 3, 2, 2, 2, 756, 754, 3, 2, 2,
	2, 757, 759, 5, 86, 44, 2, 758, 757, 3, 2, 2, 2, 759, 762, 3, 2, 2, 2,
	760, 758, 3, 2, 2, 2, 760, 761, 3, 2, 2, 2, 761, 763, 3, 2, 2, 2, 762,
	760, 3, 2, 2, 2, 763, 764, 7, 2, 2, 3, 764, 69, 3, 2, 2, 2, 765, 767, 5,
	76, 39, 2, 766, 765, 3, 2, 2, 2, 767, 770, 3, 2, 2, 2, 768, 766, 3, 2,
	2, 2, 768, 769, 3, 2, 2, 2, 769, 771, 3, 2, 2, 2, 770, 768, 3, 2, 2, 2,
	771, 772, 5, 88, 45, 2, 772, 71, 3, 2, 2, 2, 773, 775, 5, 74, 38, 2, 774,
	773, 3, 2, 2, 2, 775, 778, 3, 2, 2, 2, 776, 774, 3, 2, 2, 2, 776, 777,
	3, 2, 2, 2, 777, 779, 3, 2, 2, 2, 778, 776, 3, 2, 2, 2, 779, 780, 7, 38,
	2, 2, 780, 781, 5, 54, 28, 2, 781, 782, 7, 76, 2, 2, 782, 73, 3, 2, 2,
	2, 783, 784, 5, 242, 122, 2, 784, 75, 3, 2, 2, 2, 785, 790, 5, 78, 40,
	2, 786, 790, 5, 80, 41, 2, 787, 790, 5, 82, 42, 2, 788, 790, 5, 84, 43,
	2, 789, 785, 3, 2, 2, 2, 789, 786, 3, 2, 2, 2, 789, 787, 3, 2, 2, 2, 789,
	788, 3, 2, 2, 2, 790, 77, 3, 2, 2, 2, 791, 792, 7, 28, 2, 2, 792, 793,
	5, 56, 29, 2, 793, 794, 7, 76, 2, 2, 794, 79, 3, 2, 2, 2, 795, 796, 7,
	28, 2, 2, 796, 797, 5, 58, 30, 2, 797, 798, 7, 78, 2, 2, 798, 799, 7, 100,
	2, 2, 799, 800, 7, 76, 2, 2, 800, 81, 3, 2, 2, 2, 801, 802, 7, 28, 2, 2,
	802, 803, 7, 46, 2, 2, 803, 804, 5, 56, 29, 2, 804, 805, 7, 78, 2, 2, 805,
	806, 5, 490, 246, 2, 806, 807, 7, 76, 2, 2, 807, 83, 3, 2, 2, 2, 808, 809,
	7, 28, 2, 2, 809, 810, 7, 46, 2, 2, 810, 811, 5, 56, 29, 2, 811, 812, 7,
	78, 2, 2, 812, 813, 7, 100, 2, 2, 813, 814, 7, 76, 2, 2, 814, 85, 3, 2,
	2, 2, 815, 819, 5, 94, 48, 2, 816, 819, 5, 210, 106, 2, 817, 819, 7, 76,
	2, 2, 818, 815, 3, 2, 2, 2, 818, 816, 3, 2, 2, 2, 818, 817, 3, 2, 2, 2,
	819, 87, 3, 2, 2, 2, 820, 822, 5, 242, 122, 2, 821, 820, 3, 2, 2, 2, 822,
	825, 3, 2, 2, 2, 823, 821, 3, 2, 2, 2, 823, 824, 3, 2, 2, 2, 824, 827,
	3, 2, 2, 2, 825, 823, 3, 2, 2, 2, 826, 828, 7, 36, 2, 2, 827, 826, 3, 2,
	2, 2, 827, 828, 3, 2, 2, 2, 828, 829, 3, 2, 2, 2, 829, 830, 7, 33, 2, 2,
	830, 831, 5, 52, 27, 2, 831, 835, 7, 72, 2, 2, 832, 834, 5, 90, 46, 2,
	833, 832, 3, 2, 2, 2, 834, 837, 3, 2, 2, 2, 835, 833, 3, 2, 2, 2, 835,
	836, 3, 2, 2, 2, 836, 838, 3, 2, 2, 2, 837, 835, 3, 2, 2, 2, 838, 839,
	7, 73, 2, 2, 839, 89, 3, 2, 2, 2, 840, 844, 7, 43, 2, 2, 841, 843, 5, 92,
	47, 2, 842, 841, 3, 2, 2, 2, 843, 846, 3, 2, 2, 2, 844, 842, 3, 2, 2, 2,
	844, 845, 3, 2, 2, 2, 845, 847, 3, 2, 2, 2, 846, 844, 3, 2, 2, 2, 847,
	848, 5, 52, 27, 2, 848, 849, 7, 76, 2, 2, 849, 898, 3, 2, 2, 2, 850, 851,
	7, 19, 2, 2, 851, 861, 5, 54, 28, 2, 852, 853, 7, 54, 2, 2, 853, 858, 5,
	52, 27, 2, 854, 855, 7, 77, 2, 2, 855, 857, 5, 52, 27, 2, 856, 854, 3,
	2, 2, 2, 857, 860, 3, 2, 2, 2, 858, 856, 3, 2, 2, 2, 858, 859, 3, 2, 2,
	2, 859, 862, 3, 2, 2, 2, 860, 858, 3, 2, 2, 2, 861, 852, 3, 2, 2, 2, 861,
	862, 3, 2, 2, 2, 862, 863, 3, 2, 2, 2, 863, 864, 7, 76, 2, 2, 864, 898,
	3, 2, 2, 2, 865, 866, 7, 37, 2, 2, 866, 876, 5, 54, 28, 2, 867, 868, 7,
	54, 2, 2, 868, 873, 5, 52, 27, 2, 869, 870, 7, 77, 2, 2, 870, 872, 5, 52,
	27, 2, 871, 869, 3, 2, 2, 2, 872, 875, 3, 2, 2, 2, 873, 871, 3, 2, 2, 2,
	873, 874, 3, 2, 2, 2, 874, 877, 3, 2, 2, 2, 875, 873, 3, 2, 2, 2, 876,
	867, 3, 2, 2, 2, 876, 877, 3, 2, 2, 2, 877, 878, 3, 2, 2, 2, 878, 879,
	7, 76, 2, 2, 879, 898, 3, 2, 2, 2, 880, 881, 7, 58, 2, 2, 881, 882, 5,
	56, 29, 2, 882, 883, 7, 76, 2, 2, 883, 898, 3, 2, 2, 2, 884, 885, 7, 41,
	2, 2, 885, 886, 5, 56, 29, 2, 886, 887, 7, 62, 2, 2, 887, 892, 5, 56, 29,
	2, 888, 889, 7, 77, 2, 2, 889, 891, 5, 56, 29, 2, 890, 888, 3, 2, 2, 2,
	891, 894, 3, 2, 2, 2, 892, 890, 3, 2, 2, 2, 892, 893, 3, 2, 2, 2, 893,
	895, 3, 2, 2, 2, 894, 892, 3, 2, 2, 2, 895, 896, 7, 76, 2, 2, 896, 898,
	3, 2, 2, 2, 897, 840, 3, 2, 2, 2, 897, 850, 3, 2, 2, 2, 897, 865, 3, 2,
	2, 2, 897, 880, 3, 2, 2, 2, 897, 884, 3, 2, 2, 2, 898, 91, 3, 2, 2, 2,
	899, 900, 9, 5, 2, 2, 900, 93, 3, 2, 2, 2, 901, 904, 5, 96, 49, 2, 902,
	904, 5, 198, 100, 2, 903, 901, 3, 2, 2, 2, 903, 902, 3, 2, 2, 2, 904, 95,
	3, 2, 2, 2, 905, 907, 5, 98, 50, 2, 906, 905, 3, 2, 2, 2, 907, 910, 3,
	2, 2, 2, 908, 906, 3, 2, 2, 2, 908, 909, 3, 2, 2, 2, 909, 911, 3, 2, 2,
	2, 910, 908, 3, 2, 2, 2, 911, 912, 7, 11, 2, 2, 912, 914, 5, 490, 246,
	2, 913, 915, 5, 100, 51, 2, 914, 913, 3, 2, 2, 2, 914, 915, 3, 2, 2, 2,
	915, 917, 3, 2, 2, 2, 916, 918, 5, 104, 53, 2, 917, 916, 3, 2, 2, 2, 917,
	918, 3, 2, 2, 2, 918, 920, 3, 2, 2, 2, 919, 921, 5, 106, 54, 2, 920, 919,
	3, 2, 2, 2, 920, 921, 3, 2, 2, 2, 921, 922, 3, 2, 2, 2, 922, 923, 5, 110,
	56, 2, 923, 97, 3, 2, 2, 2, 924, 933, 5, 242, 122, 2, 925, 933, 7, 42,
	2, 2, 926, 933, 7, 40, 2, 2, 927, 933, 7, 39, 2, 2, 928, 933, 7, 3, 2,
	2, 929, 933, 7, 46, 2, 2, 930, 933, 7, 21, 2, 2, 931, 933, 7, 47, 2, 2,
	932, 924, 3, 2, 2, 2, 932, 925, 3, 2, 2, 2, 932, 926, 3, 2, 2, 2, 932,
	927, 3, 2, 2, 2, 932, 928, 3, 2, 2, 2, 932, 929, 3, 2, 2, 2, 932, 930,
	3, 2, 2, 2, 932, 931, 3, 2, 2, 2, 933, 99, 3, 2, 2, 2, 934, 935, 7, 84,
	2, 2, 935, 936, 5, 102, 52, 2, 936, 937, 7, 83, 2, 2, 937, 101, 3, 2, 2,
	2, 938, 943, 5, 34, 18, 2, 939, 940, 7, 77, 2, 2, 940, 942, 5, 34, 18,
	2, 941, 939, 3, 2, 2, 2, 942, 945, 3, 2, 2, 2, 943, 941, 3, 2, 2, 2, 943,
	944, 3, 2, 2, 2, 944, 103, 3, 2, 2, 2, 945, 943, 3, 2, 2, 2, 946, 947,
	7, 20, 2, 2, 947, 948, 5, 16, 9, 2, 948, 105, 3, 2, 2, 2, 949, 950, 7,
	27, 2, 2, 950, 951, 5, 108, 55, 2, 951, 107, 3, 2, 2, 2, 952, 957, 5, 22,
	12, 2, 953, 954, 7, 77, 2, 2, 954, 956, 5, 22, 12, 2, 955, 953, 3, 2, 2,
	2, 956, 959, 3, 2, 2, 2, 957, 955, 3, 2, 2, 2, 957, 958, 3, 2, 2, 2, 958,
	109, 3, 2, 2, 2, 959, 957, 3, 2, 2, 2, 960, 964, 7, 72, 2, 2, 961, 963,
	5, 112, 57, 2, 962, 961, 3, 2, 2, 2, 963, 966, 3, 2, 2, 2, 964, 962, 3,
	2, 2, 2, 964, 965, 3, 2, 2, 2, 965, 967, 3, 2, 2, 2, 966, 964, 3, 2, 2,
	2, 967, 968, 7, 73, 2, 2, 968, 111, 3, 2, 2, 2, 969, 974, 5, 114, 58, 2,
	970, 974, 5, 182, 92, 2, 971, 974, 5, 184, 93, 2, 972, 974, 5, 186, 94,
	2, 973, 969, 3, 2, 2, 2, 973, 970, 3, 2, 2, 2, 973, 971, 3, 2, 2, 2, 973,
	972, 3, 2, 2, 2, 974, 113, 3, 2, 2, 2, 975, 981, 5, 116, 59, 2, 976, 981,
	5, 152, 77, 2, 977, 981, 5, 94, 48, 2, 978, 981, 5, 210, 106, 2, 979, 981,
	7, 76, 2, 2, 980, 975, 3, 2, 2, 2, 980, 976, 3, 2, 2, 2, 980, 977, 3, 2,
	2, 2, 980, 978, 3, 2, 2, 2, 980, 979, 3, 2, 2, 2, 981, 115, 3, 2, 2, 2,
	982, 984, 5, 118, 60, 2, 983, 982, 3, 2, 2, 2, 984, 987, 3, 2, 2, 2, 985,
	983, 3, 2, 2, 2, 985, 986, 3, 2, 2, 2, 986, 988, 3, 2, 2, 2, 987, 985,
	3, 2, 2, 2, 988, 989, 5, 128, 65, 2, 989, 990, 5, 120, 61, 2, 990, 991,
	7, 76, 2, 2, 991, 117, 3, 2, 2, 2, 992, 1001, 5, 242, 122, 2, 993, 1001,
	7, 42, 2, 2, 994, 1001, 7, 40, 2, 2, 995, 1001, 7, 39, 2, 2, 996, 1001,
	7, 46, 2, 2, 997, 1001, 7, 21, 2, 2, 998, 1001, 7, 55, 2, 2, 999, 1001,
	7, 60, 2, 2, 1000, 992, 3, 2, 2, 2, 1000, 993, 3, 2, 2, 2, 1000, 994, 3,
	2, 2, 2, 1000, 995, 3, 2, 2, 2, 1000, 996, 3, 2, 2, 2, 1000, 997, 3, 2,
	2, 2, 1000, 998, 3, 2, 2, 2, 1000, 999, 3, 2, 2, 2, 1001, 119, 3, 2, 2,
	2, 1002, 1007, 5, 122, 62, 2, 1003, 1004, 7, 77, 2, 2, 1004, 1006, 5, 122,
	62, 2, 1005, 1003, 3, 2, 2, 2, 1006, 1009, 3, 2, 2, 2, 1007, 1005, 3, 2,
	2, 2, 1007, 1008, 3, 2, 2, 2, 1008, 121, 3, 2, 2, 2, 1009, 1007, 3, 2,
	2, 2, 1010, 1013, 5, 124, 63, 2, 1011, 1012, 7, 82, 2, 2, 1012, 1014, 5,
	126, 64, 2, 1013, 1011, 3, 2, 2, 2, 1013, 1014, 3, 2, 2, 2, 1014, 123,
	3, 2, 2, 2, 1015, 1017, 5, 490, 246, 2, 1016, 1018, 5, 32, 17, 2, 1017,
	1016, 3, 2, 2, 2, 1017, 1018, 3, 2, 2, 2, 1018, 125, 3, 2, 2, 2, 1019,
	1022, 5, 430, 216, 2, 1020, 1022, 5, 260, 131, 2, 1021, 1019, 3, 2, 2,
	2, 1021, 1020, 3, 2, 2, 2, 1022, 127, 3, 2, 2, 2, 1023, 1026, 5, 130, 66,
	2, 1024, 1026, 5, 132, 67, 2, 1025, 1023, 3, 2, 2, 2, 1025, 1024, 3, 2,
	2, 2, 1026, 129, 3, 2, 2, 2, 1027, 1030, 5, 6, 4, 2, 1028, 1030, 7, 5,
	2, 2, 1029, 1027, 3, 2, 2, 2, 1029, 1028, 3, 2, 2, 2, 1030, 131, 3, 2,
	2, 2, 1031, 1035, 5, 134, 68, 2, 1032, 1035, 5, 148, 75, 2, 1033, 1035,
	5, 150, 76, 2, 1034, 1031, 3, 2, 2, 2, 1034, 1032, 3, 2, 2, 2, 1034, 1033,
	3, 2, 2, 2, 1035, 133, 3, 2, 2, 2, 1036, 1039, 5, 140, 71, 2, 1037, 1039,
	5, 146, 74, 2, 1038, 1036, 3, 2, 2, 2, 1038, 1037, 3, 2, 2, 2, 1039, 1044,
	3, 2, 2, 2, 1040, 1043, 5, 138, 70, 2, 1041, 1043, 5, 144, 73, 2, 1042,
	1040, 3, 2, 2, 2, 1042, 1041, 3, 2, 2, 2, 1043, 1046, 3, 2, 2, 2, 1044,
	1042, 3, 2, 2, 2, 1044, 1045, 3, 2, 2, 2, 1045, 135, 3, 2, 2, 2, 1046,
	1044, 3, 2, 2, 2, 1047, 1049, 5, 490, 246, 2, 1048, 1050, 5, 42, 22, 2,
	1049, 1048, 3, 2, 2, 2, 1049, 1050, 3, 2, 2, 2, 1050, 1064, 3, 2, 2, 2,
	1051, 1052, 5, 134, 68, 2, 1052, 1056, 7, 78, 2, 2, 1053, 1055, 5, 242,
	122, 2, 1054, 1053, 3, 2, 2, 2, 1055, 1058, 3, 2, 2, 2, 1056, 1054, 3,
	2, 2, 2, 1056, 1057, 3, 2, 2, 2, 1057, 1059, 3, 2, 2, 2, 1058, 1056, 3,
	2, 2, 2, 1059, 1061, 5, 490, 246, 2, 1060, 1062, 5, 42, 22, 2, 1061, 1060,
	3, 2, 2, 2, 1061, 1062, 3, 2, 2, 2, 1062, 1064, 3, 2, 2, 2, 1063, 1047,
	3, 2, 2, 2, 1063, 1051, 3, 2, 2, 2, 1064, 137, 3, 2, 2, 2, 1065, 1069,
	7, 78, 2, 2, 1066, 1068, 5, 242, 122, 2, 1067, 1066, 3, 2, 2, 2, 1068,
	1071, 3, 2, 2, 2, 1069, 1067, 3, 2, 2, 2, 1069, 1070, 3, 2, 2, 2, 1070,
	1072, 3, 2, 2, 2, 1071, 1069, 3, 2, 2, 2, 1072, 1074, 5, 490, 246, 2, 1073,
	1075, 5, 42, 22, 2, 1074, 1073, 3, 2, 2, 2, 1074, 1075, 3, 2, 2, 2, 1075,
	139, 3, 2, 2, 2, 1076, 1078, 5, 490, 246, 2, 1077, 1079, 5, 42, 22, 2,
	1078, 1077, 3, 2, 2, 2, 1078, 1079, 3, 2, 2, 2, 1079, 141, 3, 2, 2, 2,
	1080, 1081, 5, 136, 69, 2, 1081, 143, 3, 2, 2, 2, 1082, 1083, 5, 138, 70,
	2, 1083, 145, 3, 2, 2, 2, 1084, 1085, 5, 140, 71, 2, 1085, 147, 3, 2, 2,
	2, 1086, 1087, 5, 490, 246, 2, 1087, 149, 3, 2, 2, 2, 1088, 1089, 5, 130,
	66, 2, 1089, 1090, 5, 32, 17, 2, 1090, 1098, 3, 2, 2, 2, 1091, 1092, 5,
	134, 68, 2, 1092, 1093, 5, 32, 17, 2, 1093, 1098, 3, 2, 2, 2, 1094, 1095,
	5, 148, 75, 2, 1095, 1096, 5, 32, 17, 2, 1096, 1098, 3, 2, 2, 2, 1097,
	1088, 3, 2, 2, 2, 1097, 1091, 3, 2, 2, 2, 1097, 1094, 3, 2, 2, 2, 1098,
	151, 3, 2, 2, 2, 1099, 1101, 5, 154, 78, 2, 1100, 1099, 3, 2, 2, 2, 1101,
	1104, 3, 2, 2, 2, 1102, 1100, 3, 2, 2, 2, 1102, 1103, 3, 2, 2, 2, 1103,
	1105, 3, 2, 2, 2, 1104, 1102, 3, 2, 2, 2, 1105, 1106, 5, 156, 79, 2, 1106,
	1107, 5, 180, 91, 2, 1107, 153, 3, 2, 2, 2, 1108, 1119, 5, 242, 122, 2,
	1109, 1119, 7, 42, 2, 2, 1110, 1119, 7, 40, 2, 2, 1111, 1119, 7, 39, 2,
	2, 1112, 1119, 7, 3, 2, 2, 1113, 1119, 7, 46, 2, 2, 1114, 1119, 7, 21,
	2, 2, 1115, 1119, 7, 50, 2, 2, 1116, 1119, 7, 34, 2, 2, 1117, 1119, 7,
	47, 2, 2, 1118, 1108, 3, 2, 2, 2, 1118, 1109, 3, 2, 2, 2, 1118, 1110, 3,
	2, 2, 2, 1118, 1111, 3, 2, 2, 2, 1118, 1112, 3, 2, 2, 2, 1118, 1113, 3,
	2, 2, 2, 1118, 1114, 3, 2, 2, 2, 1118, 1115, 3, 2, 2, 2, 1118, 1116, 3,
	2, 2, 2, 1118, 1117, 3, 2, 2, 2, 1119, 155, 3, 2, 2, 2, 1120, 1121, 5,
	158, 80, 2, 1121, 1123, 5, 160, 81, 2, 1122, 1124, 5, 174, 88, 2, 1123,
	1122, 3, 2, 2, 2, 1123, 1124, 3, 2, 2, 2, 1124, 1138, 3, 2, 2, 2, 1125,
	1129, 5, 100, 51, 2, 1126, 1128, 5, 242, 122, 2, 1127, 1126, 3, 2, 2, 2,
	1128, 1131, 3, 2, 2, 2, 1129, 1127, 3, 2, 2, 2, 1129, 1130, 3, 2, 2, 2,
	1130, 1132, 3, 2, 2, 2, 1131, 1129, 3, 2, 2, 2, 1132, 1133, 5, 158, 80,
	2, 1133, 1135, 5, 160, 81, 2, 1134, 1136, 5, 174, 88, 2, 1135, 1134, 3,
	2, 2, 2, 1135, 1136, 3, 2, 2, 2, 1136, 1138, 3, 2, 2, 2, 1137, 1120, 3,
	2, 2, 2, 1137, 1125, 3, 2, 2, 2, 1138, 157, 3, 2, 2, 2, 1139, 1142, 5,
	128, 65, 2, 1140, 1142, 7, 59, 2, 2, 1141, 1139, 3, 2, 2, 2, 1141, 1140,
	3, 2, 2, 2, 1142, 159, 3, 2, 2, 2, 1143, 1144, 5, 490, 246, 2, 1144, 1146,
	7, 70, 2, 2, 1145, 1147, 5, 162, 82, 2, 1146, 1145, 3, 2, 2, 2, 1146, 1147,
	3, 2, 2, 2, 1147, 1148, 3, 2, 2, 2, 1148, 1150, 7, 71, 2, 2, 1149, 1151,
	5, 32, 17, 2, 1150, 1149, 3, 2, 2, 2, 1150, 1151, 3, 2, 2, 2, 1151, 161,
	3, 2, 2, 2, 1152, 1153, 5, 164, 83, 2, 1153, 1154, 7, 77, 2, 2, 1154, 1155,
	5, 170, 86, 2, 1155, 1159, 3, 2, 2, 2, 1156, 1159, 5, 170, 86, 2, 1157,
	1159, 5, 172, 87, 2, 1158, 1152, 3, 2, 2, 2, 1158, 1156, 3, 2, 2, 2, 1158,
	1157, 3, 2, 2, 2, 1159, 163, 3, 2, 2, 2, 1160, 1165, 5, 166, 84, 2, 1161,
	1162, 7, 77, 2, 2, 1162, 1164, 5, 166, 84, 2, 1163, 1161, 3, 2, 2, 2, 1164,
	1167, 3, 2, 2, 2, 1165, 1163, 3, 2, 2, 2, 1165, 1166, 3, 2, 2, 2, 1166,
	1177, 3, 2, 2, 2, 1167, 1165, 3, 2, 2, 2, 1168, 1173, 5, 172, 87, 2, 1169,
	1170, 7, 77, 2, 2, 1170, 1172, 5, 166, 84, 2, 1171, 1169, 3, 2, 2, 2, 1172,
	1175, 3, 2, 2, 2, 1173, 1171, 3, 2, 2, 2, 1173, 1174, 3, 2, 2, 2, 1174,
	1177, 3, 2, 2, 2, 1175, 1173, 3, 2, 2, 2, 1176, 1160, 3, 2, 2, 2, 1176,
	1168, 3, 2, 2, 2, 1177, 165, 3, 2, 2, 2, 1178, 1180, 5, 168, 85, 2, 1179,
	1178, 3, 2, 2, 2, 1180, 1183, 3, 2, 2, 2, 1181, 1179, 3, 2, 2, 2, 1181,
	1182, 3, 2, 2, 2, 1182, 1184, 3, 2, 2, 2, 1183, 1181, 3, 2, 2, 2, 1184,
	1185, 5, 128, 65, 2, 1185, 1186, 5, 124, 63, 2, 1186, 167, 3, 2, 2, 2,
	1187, 1190, 5, 242, 122, 2, 1188, 1190, 7, 21, 2, 2, 1189, 1187, 3, 2,
	2, 2, 1189, 1188, 3, 2, 2, 2, 1190, 169, 3, 2, 2, 2, 1191, 1193, 5, 168,
	85, 2, 1192, 1191, 3, 2, 2, 2, 1193, 1196, 3, 2, 2, 2, 1194, 1192, 3, 2,
	2, 2, 1194, 1195, 3, 2, 2, 2, 1195, 1197, 3, 2, 2, 2, 1196, 1194, 3, 2,
	2, 2, 1197, 1201, 5, 128, 65, 2, 1198, 1200, 5, 242, 122, 2, 1199, 1198,
	3, 2, 2, 2, 1200, 1203, 3, 2, 2, 2, 1201, 1199, 3, 2, 2, 2, 1201, 1202,
	3, 2, 2, 2, 1202, 1204, 3, 2, 2, 2, 1203, 1201, 3, 2, 2, 2, 1204, 1205,
	7, 79, 2, 2, 1205, 1206, 5, 124, 63, 2, 1206, 1209, 3, 2, 2, 2, 1207, 1209,
	5, 166, 84, 2, 1208, 1194, 3, 2, 2, 2, 1208, 1207, 3, 2, 2, 2, 1209, 171,
	3, 2, 2, 2, 1210, 1212, 5, 242, 122, 2, 1211, 1210, 3, 2, 2, 2, 1212, 1215,
	3, 2, 2, 2, 1213, 1211, 3, 2, 2, 2, 1213, 1214, 3, 2, 2, 2, 1214, 1216,
	3, 2, 2, 2, 1215, 1213, 3, 2, 2, 2, 1216, 1220, 5, 128, 65, 2, 1217, 1218,
	5, 490, 246, 2, 1218, 1219, 7, 78, 2, 2, 1219, 1221, 3, 2, 2, 2, 1220,
	1217, 3, 2, 2, 2, 1220, 1221, 3, 2, 2, 2, 1221, 1222, 3, 2, 2, 2, 1222,
	1223, 7, 51, 2, 2, 1223, 173, 3, 2, 2, 2, 1224, 1225, 7, 53, 2, 2, 1225,
	1226, 5, 176, 89, 2, 1226, 175, 3, 2, 2, 2, 1227, 1232, 5, 178, 90, 2,
	1228, 1229, 7, 77, 2, 2, 1229, 1231, 5, 178, 90, 2, 1230, 1228, 3, 2, 2,
	2, 1231, 1234, 3, 2, 2, 2, 1232, 1230, 3, 2, 2, 2, 1232, 1233, 3, 2, 2,
	2, 1233, 177, 3, 2, 2, 2, 1234, 1232, 3, 2, 2, 2, 1235, 1238, 5, 16, 9,
	2, 1236, 1238, 5, 28, 15, 2, 1237, 1235, 3, 2, 2, 2, 1237, 1236, 3, 2,
	2, 2, 1238, 179, 3, 2, 2, 2, 1239, 1242, 5, 264, 133, 2, 1240, 1242, 7,
	76, 2, 2, 1241, 1239, 3, 2, 2, 2, 1241, 1240, 3, 2, 2, 2, 1242, 181, 3,
	2, 2, 2, 1243, 1244, 5, 264, 133, 2, 1244, 183, 3, 2, 2, 2, 1245, 1246,
	7, 46, 2, 2, 1246, 1247, 5, 264, 133, 2, 1247, 185, 3, 2, 2, 2, 1248, 1250,
	5, 188, 95, 2, 1249, 1248, 3, 2, 2, 2, 1250, 1253, 3, 2, 2, 2, 1251, 1249,
	3, 2, 2, 2, 1251, 1252, 3, 2, 2, 2, 1252, 1254, 3, 2, 2, 2, 1253, 1251,
	3, 2, 2, 2, 1254, 1256, 5, 190, 96, 2, 1255, 1257, 5, 174, 88, 2, 1256,
	1255, 3, 2, 2, 2, 1256, 1257, 3, 2, 2, 2, 1257, 1258, 3, 2, 2, 2, 1258,
	1259, 5, 194, 98, 2, 1259, 187, 3, 2, 2, 2, 1260, 1265, 5, 242, 122, 2,
	1261, 1265, 7, 42, 2, 2, 1262, 1265, 7, 40, 2, 2, 1263, 1265, 7, 39, 2,
	2, 1264, 1260, 3, 2, 2, 2, 1264, 1261, 3, 2, 2, 2, 1264, 1262, 3, 2, 2,
	2, 1264, 1263, 3, 2, 2, 2, 1265, 189, 3, 2, 2, 2, 1266, 1268, 5, 100, 51,
	2, 1267, 1266, 3, 2, 2, 2, 1267, 1268, 3, 2, 2, 2, 1268, 1269, 3, 2, 2,
	2, 1269, 1270, 5, 192, 97, 2, 1270, 1272, 7, 70, 2, 2, 1271, 1273, 5, 162,
	82, 2, 1272, 1271, 3, 2, 2, 2, 1272, 1273, 3, 2, 2, 2, 1273, 1274, 3, 2,
	2, 2, 1274, 1275, 7, 71, 2, 2, 1275, 191, 3, 2, 2, 2, 1276, 1277, 5, 490,
	246, 2, 1277, 193, 3, 2, 2, 2, 1278, 1280, 7, 72, 2, 2, 1279, 1281, 5,
	196, 99, 2, 1280, 1279, 3, 2, 2, 2, 1280, 1281, 3, 2, 2, 2, 1281, 1283,
	3, 2, 2, 2, 1282, 1284, 5, 266, 134, 2, 1283, 1282, 3, 2, 2, 2, 1283, 1284,
	3, 2, 2, 2, 1284, 1285, 3, 2, 2, 2, 1285, 1286, 7, 73, 2, 2, 1286, 195,
	3, 2, 2, 2, 1287, 1289, 5, 42, 22, 2, 1288, 1287, 3, 2, 2, 2, 1288, 1289,
	3, 2, 2, 2, 1289, 1290, 3, 2, 2, 2, 1290, 1291, 7, 51, 2, 2, 1291, 1293,
	7, 70, 2, 2, 1292, 1294, 5, 414, 208, 2, 1293, 1292, 3, 2, 2, 2, 1293,
	1294, 3, 2, 2, 2, 1294, 1295, 3, 2, 2, 2, 1295, 1296, 7, 71, 2, 2, 1296,
	1334, 7, 76, 2, 2, 1297, 1299, 5, 42, 22, 2, 1298, 1297, 3, 2, 2, 2, 1298,
	1299, 3, 2, 2, 2, 1299, 1300, 3, 2, 2, 2, 1300, 1301, 7, 48, 2, 2, 1301,
	1303, 7, 70, 2, 2, 1302, 1304, 5, 414, 208, 2, 1303, 1302, 3, 2, 2, 2,
	1303, 1304, 3, 2, 2, 2, 1304, 1305, 3, 2, 2, 2, 1305, 1306, 7, 71, 2, 2,
	1306, 1334, 7, 76, 2, 2, 1307, 1308, 5, 60, 31, 2, 1308, 1310, 7, 78, 2,
	2, 1309, 1311, 5, 42, 22, 2, 1310, 1309, 3, 2, 2, 2, 1310, 1311, 3, 2,
	2, 2, 1311, 1312, 3, 2, 2, 2, 1312, 1313, 7, 48, 2, 2, 1313, 1315, 7, 70,
	2, 2, 1314, 1316, 5, 414, 208, 2, 1315, 1314, 3, 2, 2, 2, 1315, 1316, 3,
	2, 2, 2, 1316, 1317, 3, 2, 2, 2, 1317, 1318, 7, 71, 2, 2, 1318, 1319, 7,
	76, 2, 2, 1319, 1334, 3, 2, 2, 2, 1320, 1321, 5, 366, 184, 2, 1321, 1323,
	7, 78, 2, 2, 1322, 1324, 5, 42, 22, 2, 1323, 1322, 3, 2, 2, 2, 1323, 1324,
	3, 2, 2, 2, 1324, 1325, 3, 2, 2, 2, 1325, 1326, 7, 48, 2, 2, 1326, 1328,
	7, 70, 2, 2, 1327, 1329, 5, 414, 208, 2, 1328, 1327, 3, 2, 2, 2, 1328,
	1329, 3, 2, 2, 2, 1329, 1330, 3, 2, 2, 2, 1330, 1331, 7, 71, 2, 2, 1331,
	1332, 7, 76, 2, 2, 1332, 1334, 3, 2, 2, 2, 1333, 1288, 3, 2, 2, 2, 1333,
	1298, 3, 2, 2, 2, 1333, 1307, 3, 2, 2, 2, 1333, 1320, 3, 2, 2, 2, 1334,
	197, 3, 2, 2, 2, 1335, 1337, 5, 98, 50, 2, 1336, 1335, 3, 2, 2, 2, 1337,
	1340, 3, 2, 2, 2, 1338, 1336, 3, 2, 2, 2, 1338, 1339, 3, 2, 2, 2, 1339,
	1341, 3, 2, 2, 2, 1340, 1338, 3, 2, 2, 2, 1341, 1342, 7, 18, 2, 2, 1342,
	1344, 5, 490, 246, 2, 1343, 1345, 5, 106, 54, 2, 1344, 1343, 3, 2, 2, 2,
	1344, 1345, 3, 2, 2, 2, 1345, 1346, 3, 2, 2, 2, 1346, 1347, 5, 200, 101,
	2, 1347, 199, 3, 2, 2, 2, 1348, 1350, 7, 72, 2, 2, 1349, 1351, 5, 202,
	102, 2, 1350, 1349, 3, 2, 2, 2, 1350, 1351, 3, 2, 2, 2, 1351, 1353, 3,
	2, 2, 2, 1352, 1354, 7, 77, 2, 2, 1353, 1352, 3, 2, 2, 2, 1353, 1354, 3,
	2, 2, 2, 1354, 1356, 3, 2, 2, 2, 1355, 1357, 5, 208, 105, 2, 1356, 1355,
	3, 2, 2, 2, 1356, 1357, 3, 2, 2, 2, 1357, 1358, 3, 2, 2, 2, 1358, 1359,
	7, 73, 2, 2, 1359, 201, 3, 2, 2, 2, 1360, 1365, 5, 204, 103, 2, 1361, 1362,
	7, 77, 2, 2, 1362, 1364, 5, 204, 103, 2, 1363, 1361, 3, 2, 2, 2, 1364,
	1367, 3, 2, 2, 2, 1365, 1363, 3, 2, 2, 2, 1365, 1366, 3, 2, 2, 2, 1366,
	203, 3, 2, 2, 2, 1367, 1365, 3, 2, 2, 2, 1368, 1370, 5, 206, 104, 2, 1369,
	1368, 3, 2, 2, 2, 1370, 1373, 3, 2, 2, 2, 1371, 1369, 3, 2, 2, 2, 1371,
	1372, 3, 2, 2, 2, 1372, 1374, 3, 2, 2, 2, 1373, 1371, 3, 2, 2, 2, 1374,
	1380, 5, 490, 246, 2, 1375, 1377, 7, 70, 2, 2, 1376, 1378, 5, 414, 208,
	2, 1377, 1376, 3, 2, 2, 2, 1377, 1378, 3, 2, 2, 2, 1378, 1379, 3, 2, 2,
	2, 1379, 1381, 7, 71, 2, 2, 1380, 1375, 3, 2, 2, 2, 1380, 1381, 3, 2, 2,
	2, 1381, 1383, 3, 2, 2, 2, 1382, 1384, 5, 110, 56, 2, 1383, 1382, 3, 2,
	2, 2, 1383, 1384, 3, 2, 2, 2, 1384, 205, 3, 2, 2, 2, 1385, 1386, 5, 242,
	122, 2, 1386, 207, 3, 2, 2, 2, 1387, 1391, 7, 76, 2, 2, 1388, 1390, 5,
	112, 57, 2, 1389, 1388, 3, 2, 2, 2, 1390, 1393, 3, 2, 2, 2, 1391, 1389,
	3, 2, 2, 2, 1391, 1392, 3, 2, 2, 2, 1392, 209, 3, 2, 2, 2, 1393, 1391,
	3, 2, 2, 2, 1394, 1397, 5, 212, 107, 2, 1395, 1397, 5, 230, 116, 2, 1396,
	1394, 3, 2, 2, 2, 1396, 1395, 3, 2, 2, 2, 1397, 211, 3, 2, 2, 2, 1398,
	1400, 5, 214, 108, 2, 1399, 1398, 3, 2, 2, 2, 1400, 1403, 3, 2, 2, 2, 1401,
	1399, 3, 2, 2, 2, 1401, 1402, 3, 2, 2, 2, 1402, 1404, 3, 2, 2, 2, 1403,
	1401, 3, 2, 2, 2, 1404, 1405, 7, 31, 2, 2, 1405, 1407, 5, 490, 246, 2,
	1406, 1408, 5, 100, 51, 2, 1407, 1406, 3, 2, 2, 2, 1407, 1408, 3, 2, 2,
	2, 1408, 1410, 3, 2, 2, 2, 1409, 1411, 5, 216, 109, 2, 1410, 1409, 3, 2,
	2, 2, 1410, 1411, 3, 2, 2, 2, 1411, 1412, 3, 2, 2, 2, 1412, 1413, 5, 218,
	110, 2, 1413, 213, 3, 2, 2, 2, 1414, 1422, 5, 242, 122, 2, 1415, 1422,
	7, 42, 2, 2, 1416, 1422, 7, 40, 2, 2, 1417, 1422, 7, 39, 2, 2, 1418, 1422,
	7, 3, 2, 2, 1419, 1422, 7, 46, 2, 2, 1420, 1422, 7, 47, 2, 2, 1421, 1414,
	3, 2, 2, 2, 1421, 1415, 3, 2, 2, 2, 1421, 1416, 3, 2, 2, 2, 1421, 1417,
	3, 2, 2, 2, 1421, 1418, 3, 2, 2, 2, 1421, 1419, 3, 2, 2, 2, 1421, 1420,
	3, 2, 2, 2, 1422, 215, 3, 2, 2, 2, 1423, 1424, 7, 20, 2, 2, 1424, 1425,
	5, 108, 55, 2, 1425, 217, 3, 2, 2, 2, 1426, 1430, 7, 72, 2, 2, 1427, 1429,
	5, 220, 111, 2, 1428, 1427, 3, 2, 2, 2, 1429, 1432, 3, 2, 2, 2, 1430, 1428,
	3, 2, 2, 2, 1430, 1431, 3, 2, 2, 2, 1431, 1433, 3, 2, 2, 2, 1432, 1430,
	3, 2, 2, 2, 1433, 1434, 7, 73, 2, 2, 1434, 219, 3, 2, 2, 2, 1435, 1441,
	5, 222, 112, 2, 1436, 1441, 5, 226, 114, 2, 1437, 1441, 5, 94, 48, 2, 1438,
	1441, 5, 210, 106, 2, 1439, 1441, 7, 76, 2, 2, 1440, 1435, 3, 2, 2, 2,
	1440, 1436, 3, 2, 2, 2, 1440, 1437, 3, 2, 2, 2, 1440, 1438, 3, 2, 2, 2,
	1440, 1439, 3, 2, 2, 2, 1441, 221, 3, 2, 2, 2, 1442, 1444, 5, 224, 113,
	2, 1443, 1442, 3, 2, 2, 2, 1444, 1447, 3, 2, 2, 2, 1445, 1443, 3, 2, 2,
	2, 1445, 1446, 3, 2, 2, 2, 1446, 1448, 3, 2, 2, 2, 1447, 1445, 3, 2, 2,
	2, 1448, 1449, 5, 128, 65, 2, 1449, 1450, 5, 120, 61, 2, 1450, 1451, 7,
	76, 2, 2, 1451, 223, 3, 2, 2, 2, 1452, 1457, 5, 242, 122, 2, 1453, 1457,
	7, 42, 2, 2, 1454, 1457, 7, 46, 2, 2, 1455, 1457, 7, 21, 2, 2, 1456, 1452,
	3, 2, 2, 2, 1456, 1453, 3, 2, 2, 2, 1456, 1454, 3, 2, 2, 2, 1456, 1455,
	3, 2, 2, 2, 1457, 225, 3, 2, 2, 2, 1458, 1460, 5, 228, 115, 2, 1459, 1458,
	3, 2, 2, 2, 1460, 1463, 3, 2, 2, 2, 1461, 1459, 3, 2, 2, 2, 1461, 1462,
	3, 2, 2, 2, 1462, 1464, 3, 2, 2, 2, 1463, 1461, 3, 2, 2, 2, 1464, 1465,
	5, 156, 79, 2, 1465, 1466, 5, 180, 91, 2, 1466, 227, 3, 2, 2, 2, 1467,
	1475, 5, 242, 122, 2, 1468, 1475, 7, 42, 2, 2, 1469, 1475, 7, 39, 2, 2,
	1470, 1475, 7, 3, 2, 2, 1471, 1475, 7, 14, 2, 2, 1472, 1475, 7, 46, 2,
	2, 1473, 1475, 7, 47, 2, 2, 1474, 1467, 3, 2, 2, 2, 1474, 1468, 3, 2, 2,
	2, 1474, 1469, 3, 2, 2, 2, 1474, 1470, 3, 2, 2, 2, 1474, 1471, 3, 2, 2,
	2, 1474, 1472, 3, 2, 2, 2, 1474, 1473, 3, 2, 2, 2, 1475, 229, 3, 2, 2,
	2, 1476, 1478, 5, 214, 108, 2, 1477, 1476, 3, 2, 2, 2, 1478, 1481, 3, 2,
	2, 2, 1479, 1477, 3, 2, 2, 2, 1479, 1480, 3, 2, 2, 2, 1480, 1482, 3, 2,
	2, 2, 1481, 1479, 3, 2, 2, 2, 1482, 1483, 7, 80, 2, 2, 1483, 1484, 7, 31,
	2, 2, 1484, 1485, 5, 490, 246, 2, 1485, 1486, 5, 232, 117, 2, 1486, 231,
	3, 2, 2, 2, 1487, 1491, 7, 72, 2, 2, 1488, 1490, 5, 234, 118, 2, 1489,
	1488, 3, 2, 2, 2, 1490, 1493, 3, 2, 2, 2, 1491, 1489, 3, 2, 2, 2, 1491,
	1492, 3, 2, 2, 2, 1492, 1494, 3, 2, 2, 2, 1493, 1491, 3, 2, 2, 2, 1494,
	1495, 7, 73, 2, 2, 1495, 233, 3, 2, 2, 2, 1496, 1502, 5, 236, 119, 2, 1497,
	1502, 5, 222, 112, 2, 1498, 1502, 5, 94, 48, 2, 1499, 1502, 5, 210, 106,
	2, 1500, 1502, 7, 76, 2, 2, 1501, 1496, 3, 2, 2, 2, 1501, 1497, 3, 2, 2,
	2, 1501, 1498, 3, 2, 2, 2, 1501, 1499, 3, 2, 2, 2, 1501, 1500, 3, 2, 2,
	2, 1502, 235, 3, 2, 2, 2, 1503, 1505, 5, 238, 120, 2, 1504, 1503, 3, 2,
	2, 2, 1505, 1508, 3, 2, 2, 2, 1506, 1504, 3, 2, 2, 2, 1506, 1507, 3, 2,
	2, 2, 1507, 1509, 3, 2, 2, 2, 1508, 1506, 3, 2, 2, 2, 1509, 1510, 5, 128,
	65, 2, 1510, 1511, 5, 490, 246, 2, 1511, 1512, 7, 70, 2, 2, 1512, 1514,
	7, 71, 2, 2, 1513, 1515, 5, 32, 17, 2, 1514, 1513, 3, 2, 2, 2, 1514, 1515,
	3, 2, 2, 2, 1515, 1517, 3, 2, 2, 2, 1516, 1518, 5, 240, 121, 2, 1517, 1516,
	3, 2, 2, 2, 1517, 1518, 3, 2, 2, 2, 1518, 1519, 3, 2, 2, 2, 1519, 1520,
	7, 76, 2, 2, 1520, 237, 3, 2, 2, 2, 1521, 1525, 5, 242, 122, 2, 1522, 1525,
	7, 42, 2, 2, 1523, 1525, 7, 3, 2, 2, 1524, 1521, 3, 2, 2, 2, 1524, 1522,
	3, 2, 2, 2, 1524, 1523, 3, 2, 2, 2, 1525, 239, 3, 2, 2, 2, 1526, 1527,
	7, 14, 2, 2, 1527, 1528, 5, 250, 126, 2, 1528, 241, 3, 2, 2, 2, 1529, 1533,
	5, 244, 123, 2, 1530, 1533, 5, 256, 129, 2, 1531, 1533, 5, 258, 130, 2,
	1532, 1529, 3, 2, 2, 2, 1532, 1530, 3, 2, 2, 2, 1532, 1531, 3, 2, 2, 2,
	1533, 243, 3, 2, 2, 2, 1534, 1535, 7, 80, 2, 2, 1535, 1536, 5, 56, 29,
	2, 1536, 1538, 7, 70, 2, 2, 1537, 1539, 5, 246, 124, 2, 1538, 1537, 3,
	2, 2, 2, 1538, 1539, 3, 2, 2, 2, 1539, 1540, 3, 2, 2, 2, 1540, 1541, 7,
	71, 2, 2, 1541, 245, 3, 2, 2, 2, 1542, 1547, 5, 248, 125, 2, 1543, 1544,
	7, 77, 2, 2, 1544, 1546, 5, 248, 125, 2, 1545, 1543, 3, 2, 2, 2, 1546,
	1549, 3, 2, 2, 2, 1547, 1545, 3, 2, 2, 2, 1547, 1548, 3, 2, 2, 2, 1548,
	247, 3, 2, 2, 2, 1549, 1547, 3, 2, 2, 2, 1550, 1551, 5, 490, 246, 2, 1551,
	1552, 7, 82, 2, 2, 1552, 1553, 5, 250, 126, 2, 1553, 249, 3, 2, 2, 2, 1554,
	1558, 5, 448, 225, 2, 1555, 1558, 5, 252, 127, 2, 1556, 1558, 5, 242, 122,
	2, 1557, 1554, 3, 2, 2, 2, 1557, 1555, 3, 2, 2, 2, 1557, 1556, 3, 2, 2,
	2, 1558, 251, 3, 2, 2, 2, 1559, 1561, 7, 72, 2, 2, 1560, 1562, 5, 254,
	128, 2, 1561, 1560, 3, 2, 2, 2, 1561, 1562, 3, 2, 2, 2, 1562, 1564, 3,
	2, 2, 2, 1563, 1565, 7, 77, 2, 2, 1564, 1563, 3, 2, 2, 2, 1564, 1565, 3,
	2, 2, 2, 1565, 1566, 3, 2, 2, 2, 1566, 1567, 7, 73, 2, 2, 1567, 253, 3,
	2, 2, 2, 1568, 1573, 5, 250, 126, 2, 1569, 1570, 7, 77, 2, 2, 1570, 1572,
	5, 250, 126, 2, 1571, 1569, 3, 2, 2, 2, 1572, 1575, 3, 2, 2, 2, 1573, 1571,
	3, 2, 2, 2, 1573, 1574, 3, 2, 2, 2, 1574, 255, 3, 2, 2, 2, 1575, 1573,
	3, 2, 2, 2, 1576, 1577, 7, 80, 2, 2, 1577, 1578, 5, 56, 29, 2, 1578, 257,
	3, 2, 2, 2, 1579, 1580, 7, 80, 2, 2, 1580, 1581, 5, 56, 29, 2, 1581, 1582,
	7, 70, 2, 2, 1582, 1583, 5, 250, 126, 2, 1583, 1584, 7, 71, 2, 2, 1584,
	259, 3, 2, 2, 2, 1585, 1587, 7, 72, 2, 2, 1586, 1588, 5, 262, 132, 2, 1587,
	1586, 3, 2, 2, 2, 1587, 1588, 3, 2, 2, 2, 1588, 1590, 3, 2, 2, 2, 1589,
	1591, 7, 77, 2, 2, 1590, 1589, 3, 2, 2, 2, 1590, 1591, 3, 2, 2, 2, 1591,
	1592, 3, 2, 2, 2, 1592, 1593, 7, 73, 2, 2, 1593, 261, 3, 2, 2, 2, 1594,
	1599, 5, 126, 64, 2, 1595, 1596, 7, 77, 2, 2, 1596, 1598, 5, 126, 64, 2,
	1597, 1595, 3, 2, 2, 2, 1598, 1601, 3, 2, 2, 2, 1599, 1597, 3, 2, 2, 2,
	1599, 1600, 3, 2, 2, 2, 1600, 263, 3, 2, 2, 2, 1601, 1599, 3, 2, 2, 2,
	1602, 1604, 7, 72, 2, 2, 1603, 1605, 5, 266, 134, 2, 1604, 1603, 3, 2,
	2, 2, 1604, 1605, 3, 2, 2, 2, 1605, 1606, 3, 2, 2, 2, 1606, 1607, 7, 73,
	2, 2, 1607, 265, 3, 2, 2, 2, 1608, 1610, 5, 268, 135, 2, 1609, 1608, 3,
	2, 2, 2, 1610, 1611, 3, 2, 2, 2, 1611, 1609, 3, 2, 2, 2, 1611, 1612, 3,
	2, 2, 2, 1612, 267, 3, 2, 2, 2, 1613, 1617, 5, 270, 136, 2, 1614, 1617,
	5, 94, 48, 2, 1615, 1617, 5, 274, 138, 2, 1616, 1613, 3, 2, 2, 2, 1616,
	1614, 3, 2, 2, 2, 1616, 1615, 3, 2, 2, 2, 1617, 269, 3, 2, 2, 2, 1618,
	1619, 5, 272, 137, 2, 1619, 1620, 7, 76, 2, 2, 1620, 271, 3, 2, 2, 2, 1621,
	1623, 5, 168, 85, 2, 1622, 1621, 3, 2, 2, 2, 1623, 1626, 3, 2, 2, 2, 1624,
	1622, 3, 2, 2, 2, 1624, 1625, 3, 2, 2, 2, 1625, 1627, 3, 2, 2, 2, 1626,
	1624, 3, 2, 2, 2, 1627, 1628, 5, 128, 65, 2, 1628, 1629, 5, 120, 61, 2,
	1629, 273, 3, 2, 2, 2, 1630, 1637, 5, 278, 140, 2, 1631, 1637, 5, 282,
	142, 2, 1632, 1637, 5, 290, 146, 2, 1633, 1637, 5, 292, 147, 2, 1634, 1637,
	5, 310, 156, 2, 1635, 1637, 5, 316, 159, 2, 1636, 1630, 3, 2, 2, 2, 1636,
	1631, 3, 2, 2, 2, 1636, 1632, 3, 2, 2, 2, 1636, 1633, 3, 2, 2, 2, 1636,
	1634, 3, 2, 2, 2, 1636, 1635, 3, 2, 2, 2, 1637, 275, 3, 2, 2, 2, 1638,
	1644, 5, 278, 140, 2, 1639, 1644, 5, 284, 143, 2, 1640, 1644, 5, 294, 148,
	2, 1641, 1644, 5, 312, 157, 2, 1642, 1644, 5, 318, 160, 2, 1643, 1638,
	3, 2, 2, 2, 1643, 1639, 3, 2, 2, 2, 1643, 1640, 3, 2, 2, 2, 1643, 1641,
	3, 2, 2, 2, 1643, 1642, 3, 2, 2, 2, 1644, 277, 3, 2, 2, 2, 1645, 1658,
	5, 264, 133, 2, 1646, 1658, 5, 280, 141, 2, 1647, 1658, 5, 286, 144, 2,
	1648, 1658, 5, 296, 149, 2, 1649, 1658, 5, 298, 150, 2, 1650, 1658, 5,
	314, 158, 2, 1651, 1658, 5, 334, 168, 2, 1652, 1658, 5, 336, 169, 2, 1653,
	1658, 5, 338, 170, 2, 1654, 1658, 5, 342, 172, 2, 1655, 1658, 5, 340, 171,
	2, 1656, 1658, 5, 344, 173, 2, 1657, 1645, 3, 2, 2, 2, 1657, 1646, 3, 2,
	2, 2, 1657, 1647, 3, 2, 2, 2, 1657, 1648, 3, 2, 2, 2, 1657, 1649, 3, 2,
	2, 2, 1657, 1650, 3, 2, 2, 2, 1657, 1651, 3, 2, 2, 2, 1657, 1652, 3, 2,
	2, 2, 1657, 1653, 3, 2, 2, 2, 1657, 1654, 3, 2, 2, 2, 1657, 1655, 3, 2,
	2, 2, 1657, 1656, 3, 2, 2, 2, 1658, 279, 3, 2, 2, 2, 1659, 1660, 7, 76,
	2, 2, 1660, 281, 3, 2, 2, 2, 1661, 1662, 5, 490, 246, 2, 1662, 1663, 7,
	88, 2, 2, 1663, 1664, 5, 274, 138, 2, 1664, 283, 3, 2, 2, 2, 1665, 1666,
	5, 490, 246, 2, 1666, 1667, 7, 88, 2, 2, 1667, 1668, 5, 276, 139, 2, 1668,
	285, 3, 2, 2, 2, 1669, 1670, 5, 288, 145, 2, 1670, 1671, 7, 76, 2, 2, 1671,
	287, 3, 2, 2, 2, 1672, 1680, 5, 442, 222, 2, 1673, 1680, 5, 472, 237, 2,
	1674, 1680, 5, 474, 238, 2, 1675, 1680, 5, 480, 241, 2, 1676, 1680, 5,
	484, 243, 2, 1677, 1680, 5, 408, 205, 2, 1678, 1680, 5, 388, 195, 2, 1679,
	1672, 3, 2, 2, 2, 1679, 1673, 3, 2, 2, 2, 1679, 1674, 3, 2, 2, 2, 1679,
	1675, 3, 2, 2, 2, 1679, 1676, 3, 2, 2, 2, 1679, 1677, 3, 2, 2, 2, 1679,
	1678, 3, 2, 2, 2, 1680, 289, 3, 2, 2, 2, 1681, 1682, 7, 25, 2, 2, 1682,
	1683, 7, 70, 2, 2, 1683, 1684, 5, 430, 216, 2, 1684, 1685, 7, 71, 2, 2,
	1685, 1686, 5, 274, 138, 2, 1686, 291, 3, 2, 2, 2, 1687, 1688, 7, 25, 2,
	2, 1688, 1689, 7, 70, 2, 2, 1689, 1690, 5, 430, 216, 2, 1690, 1691, 7,
	71, 2, 2, 1691, 1692, 5, 276, 139, 2, 1692, 1693, 7, 17, 2, 2, 1693, 1694,
	5, 274, 138, 2, 1694, 293, 3, 2, 2, 2, 1695, 1696, 7, 25, 2, 2, 1696, 1697,
	7, 70, 2, 2, 1697, 1698, 5, 430, 216, 2, 1698, 1699, 7, 71, 2, 2, 1699,
	1700, 5, 276, 139, 2, 1700, 1701, 7, 17, 2, 2, 1701, 1702, 5, 276, 139,
	2, 1702, 295, 3, 2, 2, 2, 1703, 1704, 7, 4, 2, 2, 1704, 1705, 5, 430, 216,
	2, 1705, 1706, 7, 76, 2, 2, 1706, 1714, 3, 2, 2, 2, 1707, 1708, 7, 4, 2,
	2, 1708, 1709, 5, 430, 216, 2, 1709, 1710, 7, 88, 2, 2, 1710, 1711, 5,
	430, 216, 2, 1711, 1712, 7, 76, 2, 2, 1712, 1714, 3, 2, 2, 2, 1713, 1703,
	3, 2, 2, 2, 1713, 1707, 3, 2, 2, 2, 1714, 297, 3, 2, 2, 2, 1715, 1716,
	7, 49, 2, 2, 1716, 1717, 7, 70, 2, 2, 1717, 1718, 5, 430, 216, 2, 1718,
	1719, 7, 71, 2, 2, 1719, 1720, 5, 300, 151, 2, 1720, 299, 3, 2, 2, 2, 1721,
	1725, 7, 72, 2, 2, 1722, 1724, 5, 302, 152, 2, 1723, 1722, 3, 2, 2, 2,
	1724, 1727, 3, 2, 2, 2, 1725, 1723, 3, 2, 2, 2, 1725, 1726, 3, 2, 2, 2,
	1726, 1731, 3, 2, 2, 2, 1727, 1725, 3, 2, 2, 2, 1728, 1730, 5, 306, 154,
	2, 1729, 1728, 3, 2, 2, 2, 1730, 1733, 3, 2, 2, 2, 1731, 1729, 3, 2, 2,
	2, 1731, 1732, 3, 2, 2, 2, 1732, 1734, 3, 2, 2, 2, 1733, 1731, 3, 2, 2,
	2, 1734, 1735, 7, 73, 2, 2, 1735, 301, 3, 2, 2, 2, 1736, 1737, 5, 304,
	153, 2, 1737, 1738, 5, 266, 134, 2, 1738, 303, 3, 2, 2, 2, 1739, 1741,
	5, 306, 154, 2, 1740, 1739, 3, 2, 2, 2, 1741, 1742, 3, 2, 2, 2, 1742, 1740,
	3, 2, 2, 2, 1742, 1743, 3, 2, 2, 2, 1743, 305, 3, 2, 2, 2, 1744, 1745,
	7, 8, 2, 2, 1745, 1746, 5, 428, 215, 2, 1746, 1747, 7, 88, 2, 2, 1747,
	1755, 3, 2, 2, 2, 1748, 1749, 7, 8, 2, 2, 1749, 1750, 5, 308, 155, 2, 1750,
	1751, 7, 88, 2, 2, 1751, 1755, 3, 2, 2, 2, 1752, 1753, 7, 14, 2, 2, 1753,
	1755, 7, 88, 2, 2, 1754, 1744, 3, 2, 2, 2, 1754, 1748, 3, 2, 2, 2, 1754,
	1752, 3, 2, 2, 2, 1755, 307, 3, 2, 2, 2, 1756, 1757, 5, 490, 246, 2, 1757,
	309, 3, 2, 2, 2, 1758, 1759, 7, 61, 2, 2, 1759, 1760, 7, 70, 2, 2, 1760,
	1761, 5, 430, 216, 2, 1761, 1762, 7, 71, 2, 2, 1762, 1763, 5, 274, 138,
	2, 1763, 311, 3, 2, 2, 2, 1764, 1765, 7, 61, 2, 2, 1765, 1766, 7, 70, 2,
	2, 1766, 1767, 5, 430, 216, 2, 1767, 1768, 7, 71, 2, 2, 1768, 1769, 5,
	276, 139, 2, 1769, 313, 3, 2, 2, 2, 1770, 1771, 7, 15, 2, 2, 1771, 1772,
	5, 274, 138, 2, 1772, 1773, 7, 61, 2, 2, 1773, 1774, 7, 70, 2, 2, 1774,
	1775, 5, 430, 216, 2, 1775, 1776, 7, 71, 2, 2, 1776, 1777, 7, 76, 2, 2,
	1777, 315, 3, 2, 2, 2, 1778, 1781, 5, 320, 161, 2, 1779, 1781, 5, 330,
	166, 2, 1780, 1778, 3, 2, 2, 2, 1780, 1779, 3, 2, 2, 2, 1781, 317, 3, 2,
	2, 2, 1782, 1785, 5, 322, 162, 2, 1783, 1785, 5, 332, 167, 2, 1784, 1782,
	3, 2, 2, 2, 1784, 1783, 3, 2, 2, 2, 1785, 319, 3, 2, 2, 2, 1786, 1787,
	7, 24, 2, 2, 1787, 1789, 7, 70, 2, 2, 1788, 1790, 5, 324, 163, 2, 1789,
	1788, 3, 2, 2, 2, 1789, 1790, 3, 2, 2, 2, 1790, 1791, 3, 2, 2, 2, 1791,
	1793, 7, 76, 2, 2, 1792, 1794, 5, 430, 216, 2, 1793, 1792, 3, 2, 2, 2,
	1793, 1794, 3, 2, 2, 2, 1794, 1795, 3, 2, 2, 2, 1795, 1797, 7, 76, 2, 2,
	1796, 1798, 5, 326, 164, 2, 1797, 1796, 3, 2, 2, 2, 1797, 1798, 3, 2, 2,
	2, 1798, 1799, 3, 2, 2, 2, 1799, 1800, 7, 71, 2, 2, 1800, 1801, 5, 274,
	138, 2, 1801, 321, 3, 2, 2, 2, 1802, 1803, 7, 24, 2, 2, 1803, 1805, 7,
	70, 2, 2, 1804, 1806, 5, 324, 163, 2, 1805, 1804, 3, 2, 2, 2, 1805, 1806,
	3, 2, 2, 2, 1806, 1807, 3, 2, 2, 2, 1807, 1809, 7, 76, 2, 2, 1808, 1810,
	5, 430, 216, 2, 1809, 1808, 3, 2, 2, 2, 1809, 1810, 3, 2, 2, 2, 1810, 1811,
	3, 2, 2, 2, 1811, 1813, 7, 76, 2, 2, 1812, 1814, 5, 326, 164, 2, 1813,
	1812, 3, 2, 2, 2, 1813, 1814, 3, 2, 2, 2, 1814, 1815, 3, 2, 2, 2, 1815,
	1816, 7, 71, 2, 2, 1816, 1817, 5, 276, 139, 2, 1817, 323, 3, 2, 2, 2, 1818,
	1821, 5, 328, 165, 2, 1819, 1821, 5, 272, 137, 2, 1820, 1818, 3, 2, 2,
	2, 1820, 1819, 3, 2, 2, 2, 1821, 325, 3, 2, 2, 2, 1822, 1823, 5, 328, 165,
	2, 1823, 327, 3, 2, 2, 2, 1824, 1829, 5, 288, 145, 2, 1825, 1826, 7, 77,
	2, 2, 1826, 1828, 5, 288, 145, 2, 1827, 1825, 3, 2, 2, 2, 1828, 1831, 3,
	2, 2, 2, 1829, 1827, 3, 2, 2, 2, 1829, 1830, 3, 2, 2, 2, 1830, 329, 3,
	2, 2, 2, 1831, 1829, 3, 2, 2, 2, 1832, 1833, 7, 24, 2, 2, 1833, 1837, 7,
	70, 2, 2, 1834, 1836, 5, 168, 85, 2, 1835, 1834, 3, 2, 2, 2, 1836, 1839,
	3, 2, 2, 2, 1837, 1835, 3, 2, 2, 2, 1837, 1838, 3, 2, 2, 2, 1838, 1840,
	3, 2, 2, 2, 1839, 1837, 3, 2, 2, 2, 1840, 1841, 5, 128, 65, 2, 1841, 1842,
	5, 124, 63, 2, 1842, 1843, 7, 88, 2, 2, 1843, 1844, 5, 430, 216, 2, 1844,
	1845, 7, 71, 2, 2, 1845, 1846, 5, 274, 138, 2, 1846, 331, 3, 2, 2, 2, 1847,
	1848, 7, 24, 2, 2, 1848, 1852, 7, 70, 2, 2, 1849, 1851, 5, 168, 85, 2,
	1850, 1849, 3, 2, 2, 2, 1851, 1854, 3, 2, 2, 2, 1852, 1850, 3, 2, 2, 2,
	1852, 1853, 3, 2, 2, 2, 1853, 1855, 3, 2, 2, 2, 1854, 1852, 3, 2, 2, 2,
	1855, 1856, 5, 128, 65, 2, 1856, 1857, 5, 124, 63, 2, 1857, 1858, 7, 88,
	2, 2, 1858, 1859, 5, 430, 216, 2, 1859, 1860, 7, 71, 2, 2, 1860, 1861,
	5, 276, 139, 2, 1861, 333, 3, 2, 2, 2, 1862, 1864, 7, 6, 2, 2, 1863, 1865,
	5, 490, 246, 2, 1864, 1863, 3, 2, 2, 2, 1864, 1865, 3, 2, 2, 2, 1865, 1866,
	3, 2, 2, 2, 1866, 1867, 7, 76, 2, 2, 1867, 335, 3, 2, 2, 2, 1868, 1870,
	7, 13, 2, 2, 1869, 1871, 5, 490, 246, 2, 1870, 1869, 3, 2, 2, 2, 1870,
	1871, 3, 2, 2, 2, 1871, 1872, 3, 2, 2, 2, 1872, 1873, 7, 76, 2, 2, 1873,
	337, 3, 2, 2, 2, 1874, 1876, 7, 44, 2, 2, 1875, 1877, 5, 430, 216, 2, 1876,
	1875, 3, 2, 2, 2, 1876, 1877, 3, 2, 2, 2, 1877, 1878, 3, 2, 2, 2, 1878,
	1879, 7, 76, 2, 2, 1879, 339, 3, 2, 2, 2, 1880, 1881, 7, 52, 2, 2, 1881,
	1882, 5, 430, 216, 2, 1882, 1883, 7, 76, 2, 2, 1883, 341, 3, 2, 2, 2, 1884,
	1885, 7, 50, 2, 2, 1885, 1886, 7, 70, 2, 2, 1886, 1887, 5, 430, 216, 2,
	1887, 1888, 7, 71, 2, 2, 1888, 1889, 5, 264, 133, 2, 1889, 343, 3, 2, 2,
	2, 1890, 1891, 7, 57, 2, 2, 1891, 1892, 5, 264, 133, 2, 1892, 1893, 5,
	346, 174, 2, 1893, 1903, 3, 2, 2, 2, 1894, 1895, 7, 57, 2, 2, 1895, 1897,
	5, 264, 133, 2, 1896, 1898, 5, 346, 174, 2, 1897, 1896, 3, 2, 2, 2, 1897,
	1898, 3, 2, 2, 2, 1898, 1899, 3, 2, 2, 2, 1899, 1900, 5, 354, 178, 2, 1900,
	1903, 3, 2, 2, 2, 1901, 1903, 5, 356, 179, 2, 1902, 1890, 3, 2, 2, 2, 1902,
	1894, 3, 2, 2, 2, 1902, 1901, 3, 2, 2, 2, 1903, 345, 3, 2, 2, 2, 1904,
	1906, 5, 348, 175, 2, 1905, 1904, 3, 2, 2, 2, 1906, 1907, 3, 2, 2, 2, 1907,
	1905, 3, 2, 2, 2, 1907, 1908, 3, 2, 2, 2, 1908, 347, 3, 2, 2, 2, 1909,
	1910, 7, 9, 2, 2, 1910, 1911, 7, 70, 2, 2, 1911, 1912, 5, 350, 176, 2,
	1912, 1913, 7, 71, 2, 2, 1913, 1914, 5, 264, 133, 2, 1914, 349, 3, 2, 2,
	2, 1915, 1917, 5, 168, 85, 2, 1916, 1915, 3, 2, 2, 2, 1917, 1920, 3, 2,
	2, 2, 1918, 1916, 3, 2, 2, 2, 1918, 1919, 3, 2, 2, 2, 1919, 1921, 3, 2,
	2, 2, 1920, 1918, 3, 2, 2, 2, 1921, 1922, 5, 352, 177, 2, 1922, 1923, 5,
	124, 63, 2, 1923, 351, 3, 2, 2, 2, 1924, 1929, 5, 136, 69, 2, 1925, 1926,
	7, 103, 2, 2, 1926, 1928, 5, 16, 9, 2, 1927, 1925, 3, 2, 2, 2, 1928, 1931,
	3, 2, 2, 2, 1929, 1927, 3, 2, 2, 2, 1929, 1930, 3, 2, 2, 2, 1930, 353,
	3, 2, 2, 2, 1931, 1929, 3, 2, 2, 2, 1932, 1933, 7, 22, 2, 2, 1933, 1934,
	5, 264, 133, 2, 1934, 355, 3, 2, 2, 2, 1935, 1936, 7, 57, 2, 2, 1936, 1937,
	5, 358, 180, 2, 1937, 1939, 5, 264, 133, 2, 1938, 1940, 5, 346, 174, 2,
	1939, 1938, 3, 2, 2, 2, 1939, 1940, 3, 2, 2, 2, 1940, 1942, 3, 2, 2, 2,
	1941, 1943, 5, 354, 178, 2, 1942, 1941, 3, 2, 2, 2, 1942, 1943, 3, 2, 2,
	2, 1943, 357, 3, 2, 2, 2, 1944, 1945, 7, 70, 2, 2, 1945, 1947, 5, 360,
	181, 2, 1946, 1948, 7, 76, 2, 2, 1947, 1946, 3, 2, 2, 2, 1947, 1948, 3,
	2, 2, 2, 1948, 1949, 3, 2, 2, 2, 1949, 1950, 7, 71, 2, 2, 1950, 359, 3,
	2, 2, 2, 1951, 1956, 5, 362, 182, 2, 1952, 1953, 7, 76, 2, 2, 1953, 1955,
	5, 362, 182, 2, 1954, 1952, 3, 2, 2, 2, 1955, 1958, 3, 2, 2, 2, 1956, 1954,
	3, 2, 2, 2, 1956, 1957, 3, 2, 2, 2, 1957, 361, 3, 2, 2, 2, 1958, 1956,
	3, 2, 2, 2, 1959, 1961, 5, 168, 85, 2, 1960, 1959, 3, 2, 2, 2, 1961, 1964,
	3, 2, 2, 2, 1962, 1960, 3, 2, 2, 2, 1962, 1963, 3, 2, 2, 2, 1963, 1965,
	3, 2, 2, 2, 1964, 1962, 3, 2, 2, 2, 1965, 1966, 5, 128, 65, 2, 1966, 1967,
	5, 124, 63, 2, 1967, 1968, 7, 82, 2, 2, 1968, 1969, 5, 430, 216, 2, 1969,
	1972, 3, 2, 2, 2, 1970, 1972, 5, 364, 183, 2, 1971, 1962, 3, 2, 2, 2, 1971,
	1970, 3, 2, 2, 2, 1972, 363, 3, 2, 2, 2, 1973, 1976, 5, 60, 31, 2, 1974,
	1976, 5, 396, 199, 2, 1975, 1973, 3, 2, 2, 2, 1975, 1974, 3, 2, 2, 2, 1976,
	365, 3, 2, 2, 2, 1977, 1980, 5, 380, 191, 2, 1978, 1980, 5, 422, 212, 2,
	1979, 1977, 3, 2, 2, 2, 1979, 1978, 3, 2, 2, 2, 1980, 1984, 3, 2, 2, 2,
	1981, 1983, 5, 374, 188, 2, 1982, 1981, 3, 2, 2, 2, 1983, 1986, 3, 2, 2,
	2, 1984, 1982, 3, 2, 2, 2, 1984, 1985, 3, 2, 2, 2, 1985, 367, 3, 2, 2,
	2, 1986, 1984, 3, 2, 2, 2, 1987, 2004, 5, 2, 2, 2, 1988, 2004, 5, 386,
	194, 2, 1989, 2004, 7, 51, 2, 2, 1990, 1991, 5, 56, 29, 2, 1991, 1992,
	7, 78, 2, 2, 1992, 1993, 7, 51, 2, 2, 1993, 2004, 3, 2, 2, 2, 1994, 1995,
	7, 70, 2, 2, 1995, 1996, 5, 430, 216, 2, 1996, 1997, 7, 71, 2, 2, 1997,
	2004, 3, 2, 2, 2, 1998, 2004, 5, 388, 195, 2, 1999, 2004, 5, 396, 199,
	2, 2000, 2004, 5, 402, 202, 2, 2001, 2004, 5, 408, 205, 2, 2002, 2004,
	5, 416, 209, 2, 2003, 1987, 3, 2, 2, 2, 2003, 1988, 3, 2, 2, 2, 2003, 1989,
	3, 2, 2, 2, 2003, 1990, 3, 2, 2, 2, 2003, 1994, 3, 2, 2, 2, 2003, 1998,
	3, 2, 2, 2, 2003, 1999, 3, 2, 2, 2, 2003, 2000, 3, 2, 2, 2, 2003, 2001,
	3, 2, 2, 2, 2003, 2002, 3, 2, 2, 2, 2004, 369, 3, 2, 2, 2, 2005, 2006,
	3, 2, 2, 2, 2006, 371, 3, 2, 2, 2, 2007, 2036, 5, 2, 2, 2, 2008, 2013,
	5, 56, 29, 2, 2009, 2010, 7, 74, 2, 2, 2010, 2012, 7, 75, 2, 2, 2011, 2009,
	3, 2, 2, 2, 2012, 2015, 3, 2, 2, 2, 2013, 2011, 3, 2, 2, 2, 2013, 2014,
	3, 2, 2, 2, 2014, 2016, 3, 2, 2, 2, 2015, 2013, 3, 2, 2, 2, 2016, 2017,
	7, 78, 2, 2, 2017, 2018, 7, 11, 2, 2, 2018, 2036, 3, 2, 2, 2, 2019, 2020,
	7, 59, 2, 2, 2020, 2021, 7, 78, 2, 2, 2021, 2036, 7, 11, 2, 2, 2022, 2036,
	7, 51, 2, 2, 2023, 2024, 5, 56, 29, 2, 2024, 2025, 7, 78, 2, 2, 2025, 2026,
	7, 51, 2, 2, 2026, 2036, 3, 2, 2, 2, 2027, 2028, 7, 70, 2, 2, 2028, 2029,
	5, 430, 216, 2, 2029, 2030, 7, 71, 2, 2, 2030, 2036, 3, 2, 2, 2, 2031,
	2036, 5, 388, 195, 2, 2032, 2036, 5, 396, 199, 2, 2033, 2036, 5, 408, 205,
	2, 2034, 2036, 5, 416, 209, 2, 2035, 2007, 3, 2, 2, 2, 2035, 2008, 3, 2,
	2, 2, 2035, 2019, 3, 2, 2, 2, 2035, 2022, 3, 2, 2, 2, 2035, 2023, 3, 2,
	2, 2, 2035, 2027, 3, 2, 2, 2, 2035, 2031, 3, 2, 2, 2, 2035, 2032, 3, 2,
	2, 2, 2035, 2033, 3, 2, 2, 2, 2035, 2034, 3, 2, 2, 2, 2036, 373, 3, 2,
	2, 2, 2037, 2043, 5, 390, 196, 2, 2038, 2043, 5, 398, 200, 2, 2039, 2043,
	5, 404, 203, 2, 2040, 2043, 5, 410, 206, 2, 2041, 2043, 5, 418, 210, 2,
	2042, 2037, 3, 2, 2, 2, 2042, 2038, 3, 2, 2, 2, 2042, 2039, 3, 2, 2, 2,
	2042, 2040, 3, 2, 2, 2, 2042, 2041, 3, 2, 2, 2, 2043, 375, 3, 2, 2, 2,
	2044, 2045, 3, 2, 2, 2, 2045, 377, 3, 2, 2, 2, 2046, 2051, 5, 390, 196,
	2, 2047, 2051, 5, 398, 200, 2, 2048, 2051, 5, 410, 206, 2, 2049, 2051,
	5, 418, 210, 2, 2050, 2046, 3, 2, 2, 2, 2050, 2047, 3, 2, 2, 2, 2050, 2048,
	3, 2, 2, 2, 2050, 2049, 3, 2, 2, 2, 2051, 379, 3, 2, 2, 2, 2052, 2093,
	5, 2, 2, 2, 2053, 2058, 5, 56, 29, 2, 2054, 2055, 7, 74, 2, 2, 2055, 2057,
	7, 75, 2, 2, 2056, 2054, 3, 2, 2, 2, 2057, 2060, 3, 2, 2, 2, 2058, 2056,
	3, 2, 2, 2, 2058, 2059, 3, 2, 2, 2, 2059, 2061, 3, 2, 2, 2, 2060, 2058,
	3, 2, 2, 2, 2061, 2062, 7, 78, 2, 2, 2062, 2063, 7, 11, 2, 2, 2063, 2093,
	3, 2, 2, 2, 2064, 2069, 5, 130, 66, 2, 2065, 2066, 7, 74, 2, 2, 2066, 2068,
	7, 75, 2, 2, 2067, 2065, 3, 2, 2, 2, 2068, 2071, 3, 2, 2, 2, 2069, 2067,
	3, 2, 2, 2, 2069, 2070, 3, 2, 2, 2, 2070, 2072, 3, 2, 2, 2, 2071, 2069,
	3, 2, 2, 2, 2072, 2073, 7, 78, 2, 2, 2073, 2074, 7, 11, 2, 2, 2074, 2093,
	3, 2, 2, 2, 2075, 2076, 7, 59, 2, 2, 2076, 2077, 7, 78, 2, 2, 2077, 2093,
	7, 11, 2, 2, 2078, 2093, 7, 51, 2, 2, 2079, 2080, 5, 56, 29, 2, 2080, 2081,
	7, 78, 2, 2, 2081, 2082, 7, 51, 2, 2, 2082, 2093, 3, 2, 2, 2, 2083, 2084,
	7, 70, 2, 2, 2084, 2085, 5, 430, 216, 2, 2085, 2086, 7, 71, 2, 2, 2086,
	2093, 3, 2, 2, 2, 2087, 2093, 5, 392, 197, 2, 2088, 2093, 5, 400, 201,
	2, 2089, 2093, 5, 406, 204, 2, 2090, 2093, 5, 412, 207, 2, 2091, 2093,
	5, 420, 211, 2, 2092, 2052, 3, 2, 2, 2, 2092, 2053, 3, 2, 2, 2, 2092, 2064,
	3, 2, 2, 2, 2092, 2075, 3, 2, 2, 2, 2092, 2078, 3, 2, 2, 2, 2092, 2079,
	3, 2, 2, 2, 2092, 2083, 3, 2, 2, 2, 2092, 2087, 3, 2, 2, 2, 2092, 2088,
	3, 2, 2, 2, 2092, 2089, 3, 2, 2, 2, 2092, 2090, 3, 2, 2, 2, 2092, 2091,
	3, 2, 2, 2, 2093, 381, 3, 2, 2, 2, 2094, 2095, 3, 2, 2, 2, 2095, 383, 3,
	2, 2, 2, 2096, 2136, 5, 2, 2, 2, 2097, 2102, 5, 56, 29, 2, 2098, 2099,
	7, 74, 2, 2, 2099, 2101, 7, 75, 2, 2, 2100, 2098, 3, 2, 2, 2, 2101, 2104,
	3, 2, 2, 2, 2102, 2100, 3, 2, 2, 2, 2102, 2103, 3, 2, 2, 2, 2103, 2105,
	3, 2, 2, 2, 2104, 2102, 3, 2, 2, 2, 2105, 2106, 7, 78, 2, 2, 2106, 2107,
	7, 11, 2, 2, 2107, 2136, 3, 2, 2, 2, 2108, 2113, 5, 130, 66, 2, 2109, 2110,
	7, 74, 2, 2, 2110, 2112, 7, 75, 2, 2, 2111, 2109, 3, 2, 2, 2, 2112, 2115,
	3, 2, 2, 2, 2113, 2111, 3, 2, 2, 2, 2113, 2114, 3, 2, 2, 2, 2114, 2116,
	3, 2, 2, 2, 2115, 2113, 3, 2, 2, 2, 2116, 2117, 7, 78, 2, 2, 2117, 2118,
	7, 11, 2, 2, 2118, 2136, 3, 2, 2, 2, 2119, 2120, 7, 59, 2, 2, 2120, 2121,
	7, 78, 2, 2, 2121, 2136, 7, 11, 2, 2, 2122, 2136, 7, 51, 2, 2, 2123, 2124,
	5, 56, 29, 2, 2124, 2125, 7, 78, 2, 2, 2125, 2126, 7, 51, 2, 2, 2126, 2136,
	3, 2, 2, 2, 2127, 2128, 7, 70, 2, 2, 2128, 2129, 5, 430, 216, 2, 2129,
	2130, 7, 71, 2, 2, 2130, 2136, 3, 2, 2, 2, 2131, 2136, 5, 392, 197, 2,
	2132, 2136, 5, 400, 201, 2, 2133, 2136, 5, 412, 207, 2, 2134, 2136, 5,
	420, 211, 2, 2135, 2096, 3, 2, 2, 2, 2135, 2097, 3, 2, 2, 2, 2135, 2108,
	3, 2, 2, 2, 2135, 2119, 3, 2, 2, 2, 2135, 2122, 3, 2, 2, 2, 2135, 2123,
	3, 2, 2, 2, 2135, 2127, 3, 2, 2, 2, 2135, 2131, 3, 2, 2, 2, 2135, 2132,
	3, 2, 2, 2, 2135, 2133, 3, 2, 2, 2, 2135, 2134, 3, 2, 2, 2, 2136, 385,
	3, 2, 2, 2, 2137, 2141, 5, 56, 29, 2, 2138, 2141, 5, 6, 4, 2, 2139, 2141,
	7, 5, 2, 2, 2140, 2137, 3, 2, 2, 2, 2140, 2138, 3, 2, 2, 2, 2140, 2139,
	3, 2, 2, 2, 2141, 2146, 3, 2, 2, 2, 2142, 2143, 7, 74, 2, 2, 2143, 2145,
	7, 75, 2, 2, 2144, 2142, 3, 2, 2, 2, 2145, 2148, 3, 2, 2, 2, 2146, 2144,
	3, 2, 2, 2, 2146, 2147, 3, 2, 2, 2, 2147, 2149, 3, 2, 2, 2, 2148, 2146,
	3, 2, 2, 2, 2149, 2150, 7, 78, 2, 2, 2150, 2155, 7, 11, 2, 2, 2151, 2152,
	7, 59, 2, 2, 2152, 2153, 7, 78, 2, 2, 2153, 2155, 7, 11, 2, 2, 2154, 2140,
	3, 2, 2, 2, 2154, 2151, 3, 2, 2, 2, 2155, 387, 3, 2, 2, 2, 2156, 2158,
	7, 35, 2, 2, 2157, 2159, 5, 42, 22, 2, 2158, 2157, 3, 2, 2, 2, 2158, 2159,
	3, 2, 2, 2, 2159, 2163, 3, 2, 2, 2, 2160, 2162, 5, 242, 122, 2, 2161, 2160,
	3, 2, 2, 2, 2162, 2165, 3, 2, 2, 2, 2163, 2161, 3, 2, 2, 2, 2163, 2164,
	3, 2, 2, 2, 2164, 2166, 3, 2, 2, 2, 2165, 2163, 3, 2, 2, 2, 2166, 2177,
	5, 490, 246, 2, 2167, 2171, 7, 78, 2, 2, 2168, 2170, 5, 242, 122, 2, 2169,
	2168, 3, 2, 2, 2, 2170, 2173, 3, 2, 2, 2, 2171, 2169, 3, 2, 2, 2, 2171,
	2172, 3, 2, 2, 2, 2172, 2174, 3, 2, 2, 2, 2173, 2171, 3, 2, 2, 2, 2174,
	2176, 5, 490, 246, 2, 2175, 2167, 3, 2, 2, 2, 2176, 2179, 3, 2, 2, 2, 2177,
	2175, 3, 2, 2, 2, 2177, 2178, 3, 2, 2, 2, 2178, 2181, 3, 2, 2, 2, 2179,
	2177, 3, 2, 2, 2, 2180, 2182, 5, 394, 198, 2, 2181, 2180, 3, 2, 2, 2, 2181,
	2182, 3, 2, 2, 2, 2182, 2183, 3, 2, 2, 2, 2183, 2185, 7, 70, 2, 2, 2184,
	2186, 5, 414, 208, 2, 2185, 2184, 3, 2, 2, 2, 2185, 2186, 3, 2, 2, 2, 2186,
	2187, 3, 2, 2, 2, 2187, 2189, 7, 71, 2, 2, 2188, 2190, 5, 110, 56, 2, 2189,
	2188, 3, 2, 2, 2, 2189, 2190, 3, 2, 2, 2, 2190, 2240, 3, 2, 2, 2, 2191,
	2192, 5, 60, 31, 2, 2192, 2193, 7, 78, 2, 2, 2193, 2195, 7, 35, 2, 2, 2194,
	2196, 5, 42, 22, 2, 2195, 2194, 3, 2, 2, 2, 2195, 2196, 3, 2, 2, 2, 2196,
	2200, 3, 2, 2, 2, 2197, 2199, 5, 242, 122, 2, 2198, 2197, 3, 2, 2, 2, 2199,
	2202, 3, 2, 2, 2, 2200, 2198, 3, 2, 2, 2, 2200, 2201, 3, 2, 2, 2, 2201,
	2203, 3, 2, 2, 2, 2202, 2200, 3, 2, 2, 2, 2203, 2205, 5, 490, 246, 2, 2204,
	2206, 5, 394, 198, 2, 2205, 2204, 3, 2, 2, 2, 2205, 2206, 3, 2, 2, 2, 2206,
	2207, 3, 2, 2, 2, 2207, 2209, 7, 70, 2, 2, 2208, 2210, 5, 414, 208, 2,
	2209, 2208, 3, 2, 2, 2, 2209, 2210, 3, 2, 2, 2, 2210, 2211, 3, 2, 2, 2,
	2211, 2213, 7, 71, 2, 2, 2212, 2214, 5, 110, 56, 2, 2213, 2212, 3, 2, 2,
	2, 2213, 2214, 3, 2, 2, 2, 2214, 2240, 3, 2, 2, 2, 2215, 2216, 5, 366,
	184, 2, 2216, 2217, 7, 78, 2, 2, 2217, 2219, 7, 35, 2, 2, 2218, 2220, 5,
	42, 22, 2, 2219, 2218, 3, 2, 2, 2, 2219, 2220, 3, 2, 2, 2, 2220, 2224,
	3, 2, 2, 2, 2221, 2223, 5, 242, 122, 2, 2222, 2221, 3, 2, 2, 2, 2223, 2226,
	3, 2, 2, 2, 2224, 2222, 3, 2, 2, 2, 2224, 2225, 3, 2, 2, 2, 2225, 2227,
	3, 2, 2, 2, 2226, 2224, 3, 2, 2, 2, 2227, 2229, 5, 490, 246, 2, 2228, 2230,
	5, 394, 198, 2, 2229, 2228, 3, 2, 2, 2, 2229, 2230, 3, 2, 2, 2, 2230, 2231,
	3, 2, 2, 2, 2231, 2233, 7, 70, 2, 2, 2232, 2234, 5, 414, 208, 2, 2233,
	2232, 3, 2, 2, 2, 2233, 2234, 3, 2, 2, 2, 2234, 2235, 3, 2, 2, 2, 2235,
	2237, 7, 71, 2, 2, 2236, 2238, 5, 110, 56, 2, 2237, 2236, 3, 2, 2, 2, 2237,
	2238, 3, 2, 2, 2, 2238, 2240, 3, 2, 2, 2, 2239, 2156, 3, 2, 2, 2, 2239,
	2191, 3, 2, 2, 2, 2239, 2215, 3, 2, 2, 2, 2240, 389, 3, 2, 2, 2, 2241,
	2242, 7, 78, 2, 2, 2242, 2244, 7, 35, 2, 2, 2243, 2245, 5, 42, 22, 2, 2244,
	2243, 3, 2, 2, 2, 2244, 2245, 3, 2, 2, 2, 2245, 2249, 3, 2, 2, 2, 2246,
	2248, 5, 242, 122, 2, 2247, 2246, 3, 2, 2, 2, 2248, 2251, 3, 2, 2, 2, 2249,
	2247, 3, 2, 2, 2, 2249, 2250, 3, 2, 2, 2, 2250, 2252, 3, 2, 2, 2, 2251,
	2249, 3, 2, 2, 2, 2252, 2254, 5, 490, 246, 2, 2253, 2255, 5, 394, 198,
	2, 2254, 2253, 3, 2, 2, 2, 2254, 2255, 3, 2, 2, 2, 2255, 2256, 3, 2, 2,
	2, 2256, 2258, 7, 70, 2, 2, 2257, 2259, 5, 414, 208, 2, 2258, 2257, 3,
	2, 2, 2, 2258, 2259, 3, 2, 2, 2, 2259, 2260, 3, 2, 2, 2, 2260, 2262, 7,
	71, 2, 2, 2261, 2263, 5, 110, 56, 2, 2262, 2261, 3, 2, 2, 2, 2262, 2263,
	3, 2, 2, 2, 2263, 391, 3, 2, 2, 2, 2264, 2266, 7, 35, 2, 2, 2265, 2267,
	5, 42, 22, 2, 2266, 2265, 3, 2, 2, 2, 2266, 2267, 3, 2, 2, 2, 2267, 2271,
	3, 2, 2, 2, 2268, 2270, 5, 242, 122, 2, 2269, 2268, 3, 2, 2, 2, 2270, 2273,
	3, 2, 2, 2, 2271, 2269, 3, 2, 2, 2, 2271, 2272, 3, 2, 2, 2, 2272, 2274,
	3, 2, 2, 2, 2273, 2271, 3, 2, 2, 2, 2274, 2285, 5, 490, 246, 2, 2275, 2279,
	7, 78, 2, 2, 2276, 2278, 5, 242, 122, 2, 2277, 2276, 3, 2, 2, 2, 2278,
	2281, 3, 2, 2, 2, 2279, 2277, 3, 2, 2, 2, 2279, 2280, 3, 2, 2, 2, 2280,
	2282, 3, 2, 2, 2, 2281, 2279, 3, 2, 2, 2, 2282, 2284, 5, 490, 246, 2, 2283,
	2275, 3, 2, 2, 2, 2284, 2287, 3, 2, 2, 2, 2285, 2283, 3, 2, 2, 2, 2285,
	2286, 3, 2, 2, 2, 2286, 2289, 3, 2, 2, 2, 2287, 2285, 3, 2, 2, 2, 2288,
	2290, 5, 394, 198, 2, 2289, 2288, 3, 2, 2, 2, 2289, 2290, 3, 2, 2, 2, 2290,
	2291, 3, 2, 2, 2, 2291, 2293, 7, 70, 2, 2, 2292, 2294, 5, 414, 208, 2,
	2293, 2292, 3, 2, 2, 2, 2293, 2294, 3, 2, 2, 2, 2294, 2295, 3, 2, 2, 2,
	2295, 2297, 7, 71, 2, 2, 2296, 2298, 5, 110, 56, 2, 2297, 2296, 3, 2, 2,
	2, 2297, 2298, 3, 2, 2, 2, 2298, 2324, 3, 2, 2, 2, 2299, 2300, 5, 60, 31,
	2, 2300, 2301, 7, 78, 2, 2, 2301, 2303, 7, 35, 2, 2, 2302, 2304, 5, 42,
	22, 2, 2303, 2302, 3, 2, 2, 2, 2303, 2304, 3, 2, 2, 2, 2304, 2308, 3, 2,
	2, 2, 2305, 2307, 5, 242, 122, 2, 2306, 2305, 3, 2, 2, 2, 2307, 2310, 3,
	2, 2, 2, 2308, 2306, 3, 2, 2, 2, 2308, 2309, 3, 2, 2, 2, 2309, 2311, 3,
	2, 2, 2, 2310, 2308, 3, 2, 2, 2, 2311, 2313, 5, 490, 246, 2, 2312, 2314,
	5, 394, 198, 2, 2313, 2312, 3, 2, 2, 2, 2313, 2314, 3, 2, 2, 2, 2314, 2315,
	3, 2, 2, 2, 2315, 2317, 7, 70, 2, 2, 2316, 2318, 5, 414, 208, 2, 2317,
	2316, 3, 2, 2, 2, 2317, 2318, 3, 2, 2, 2, 2318, 2319, 3, 2, 2, 2, 2319,
	2321, 7, 71, 2, 2, 2320, 2322, 5, 110, 56, 2, 2321, 2320, 3, 2, 2, 2, 2321,
	2322, 3, 2, 2, 2, 2322, 2324, 3, 2, 2, 2, 2323, 2264, 3, 2, 2, 2, 2323,
	2299, 3, 2, 2, 2, 2324, 393, 3, 2, 2, 2, 2325, 2329, 5, 42, 22, 2, 2326,
	2327, 7, 84, 2, 2, 2327, 2329, 7, 83, 2, 2, 2328, 2325, 3, 2, 2, 2, 2328,
	2326, 3, 2, 2, 2, 2329, 395, 3, 2, 2, 2, 2330, 2331, 5, 366, 184, 2, 2331,
	2332, 7, 78, 2, 2, 2332, 2333, 5, 490, 246, 2, 2333, 2344, 3, 2, 2, 2,
	2334, 2335, 7, 48, 2, 2, 2335, 2336, 7, 78, 2, 2, 2336, 2344, 5, 490, 246,
	2, 2337, 2338, 5, 56, 29, 2, 2338, 2339, 7, 78, 2, 2, 2339, 2340, 7, 48,
	2, 2, 2340, 2341, 7, 78, 2, 2, 2341, 2342, 5, 490, 246, 2, 2342, 2344,
	3, 2, 2, 2, 2343, 2330, 3, 2, 2, 2, 2343, 2334, 3, 2, 2, 2, 2343, 2337,
	3, 2, 2, 2, 2344, 397, 3, 2, 2, 2, 2345, 2346, 7, 78, 2, 2, 2346, 2347,
	5, 490, 246, 2, 2347, 399, 3, 2, 2, 2, 2348, 2349, 7, 48, 2, 2, 2349, 2350,
	7, 78, 2, 2, 2350, 2358, 5, 490, 246, 2, 2351, 2352, 5, 56, 29, 2, 2352,
	2353, 7, 78, 2, 2, 2353, 2354, 7, 48, 2, 2, 2354, 2355, 7, 78, 2, 2, 2355,
	2356, 5, 490, 246, 2, 2356, 2358, 3, 2, 2, 2, 2357, 2348, 3, 2, 2, 2, 2357,
	2351, 3, 2, 2, 2, 2358, 401, 3, 2, 2, 2, 2359, 2360, 5, 60, 31, 2, 2360,
	2361, 7, 74, 2, 2, 2361, 2362, 5, 430, 216, 2, 2362, 2363, 7, 75, 2, 2,
	2363, 2370, 3, 2, 2, 2, 2364, 2365, 5, 372, 187, 2, 2365, 2366, 7, 74,
	2, 2, 2366, 2367, 5, 430, 216, 2, 2367, 2368, 7, 75, 2, 2, 2368, 2370,
	3, 2, 2, 2, 2369, 2359, 3, 2, 2, 2, 2369, 2364, 3, 2, 2, 2, 2370, 2378,
	3, 2, 2, 2, 2371, 2372, 5, 370, 186, 2, 2372, 2373, 7, 74, 2, 2, 2373,
	2374, 5, 430, 216, 2, 2374, 2375, 7, 75, 2, 2, 2375, 2377, 3, 2, 2, 2,
	2376, 2371, 3, 2, 2, 2, 2377, 2380, 3, 2, 2, 2, 2378, 2376, 3, 2, 2, 2,
	2378, 2379, 3, 2, 2, 2, 2379, 403, 3, 2, 2, 2, 2380, 2378, 3, 2, 2, 2,
	2381, 2382, 5, 378, 190, 2, 2382, 2383, 7, 74, 2, 2, 2383, 2384, 5, 430,
	216, 2, 2384, 2385, 7, 75, 2, 2, 2385, 2393, 3, 2, 2, 2, 2386, 2387, 5,
	376, 189, 2, 2387, 2388, 7, 74, 2, 2, 2388, 2389, 5, 430, 216, 2, 2389,
	2390, 7, 75, 2, 2, 2390, 2392, 3, 2, 2, 2, 2391, 2386, 3, 2, 2, 2, 2392,
	2395, 3, 2, 2, 2, 2393, 2391, 3, 2, 2, 2, 2393, 2394, 3, 2, 2, 2, 2394,
	405, 3, 2, 2, 2, 2395, 2393, 3, 2, 2, 2, 2396, 2397, 5, 60, 31, 2, 2397,
	2398, 7, 74, 2, 2, 2398, 2399, 5, 430, 216, 2, 2399, 2400, 7, 75, 2, 2,
	2400, 2407, 3, 2, 2, 2, 2401, 2402, 5, 384, 193, 2, 2402, 2403, 7, 74,
	2, 2, 2403, 2404, 5, 430, 216, 2, 2404, 2405, 7, 75, 2, 2, 2405, 2407,
	3, 2, 2, 2, 2406, 2396, 3, 2, 2, 2, 2406, 2401, 3, 2, 2, 2, 2407, 2415,
	3, 2, 2, 2, 2408, 2409, 5, 382, 192, 2, 2409, 2410, 7, 74, 2, 2, 2410,
	2411, 5, 430, 216, 2, 2411, 2412, 7, 75, 2, 2, 2412, 2414, 3, 2, 2, 2,
	2413, 2408, 3, 2, 2, 2, 2414, 2417, 3, 2, 2, 2, 2415, 2413, 3, 2, 2, 2,
	2415, 2416, 3, 2, 2, 2, 2416, 407, 3, 2, 2, 2, 2417, 2415, 3, 2, 2, 2,
	2418, 2419, 5, 62, 32, 2, 2419, 2421, 7, 70, 2, 2, 2420, 2422, 5, 414,
	208, 2, 2421, 2420, 3, 2, 2, 2, 2421, 2422, 3, 2, 2, 2, 2422, 2423, 3,
	2, 2, 2, 2423, 2424, 7, 71, 2, 2, 2424, 2488, 3, 2, 2, 2, 2425, 2426, 5,
	56, 29, 2, 2426, 2428, 7, 78, 2, 2, 2427, 2429, 5, 42, 22, 2, 2428, 2427,
	3, 2, 2, 2, 2428, 2429, 3, 2, 2, 2, 2429, 2430, 3, 2, 2, 2, 2430, 2431,
	5, 490, 246, 2, 2431, 2433, 7, 70, 2, 2, 2432, 2434, 5, 414, 208, 2, 2433,
	2432, 3, 2, 2, 2, 2433, 2434, 3, 2, 2, 2, 2434, 2435, 3, 2, 2, 2, 2435,
	2436, 7, 71, 2, 2, 2436, 2488, 3, 2, 2, 2, 2437, 2438, 5, 60, 31, 2, 2438,
	2440, 7, 78, 2, 2, 2439, 2441, 5, 42, 22, 2, 2440, 2439, 3, 2, 2, 2, 2440,
	2441, 3, 2, 2, 2, 2441, 2442, 3, 2, 2, 2, 2442, 2443, 5, 490, 246, 2, 2443,
	2445, 7, 70, 2, 2, 2444, 2446, 5, 414, 208, 2, 2445, 2444, 3, 2, 2, 2,
	2445, 2446, 3, 2, 2, 2, 2446, 2447, 3, 2, 2, 2, 2447, 2448, 7, 71, 2, 2,
	2448, 2488, 3, 2, 2, 2, 2449, 2450, 5, 366, 184, 2, 2450, 2452, 7, 78,
	2, 2, 2451, 2453, 5, 42, 22, 2, 2452, 2451, 3, 2, 2, 2, 2452, 2453, 3,
	2, 2, 2, 2453, 2454, 3, 2, 2, 2, 2454, 2455, 5, 490, 246, 2, 2455, 2457,
	7, 70, 2, 2, 2456, 2458, 5, 414, 208, 2, 2457, 2456, 3, 2, 2, 2, 2457,
	2458, 3, 2, 2, 2, 2458, 2459, 3, 2, 2, 2, 2459, 2460, 7, 71, 2, 2, 2460,
	2488, 3, 2, 2, 2, 2461, 2462, 7, 48, 2, 2, 2462, 2464, 7, 78, 2, 2, 2463,
	2465, 5, 42, 22, 2, 2464, 2463, 3, 2, 2, 2, 2464, 2465, 3, 2, 2, 2, 2465,
	2466, 3, 2, 2, 2, 2466, 2467, 5, 490, 246, 2, 2467, 2469, 7, 70, 2, 2,
	2468, 2470, 5, 414, 208, 2, 2469, 2468, 3, 2, 2, 2, 2469, 2470, 3, 2, 2,
	2, 2470, 2471, 3, 2, 2, 2, 2471, 2472, 7, 71, 2, 2, 2472, 2488, 3, 2, 2,
	2, 2473, 2474, 5, 56, 29, 2, 2474, 2475, 7, 78, 2, 2, 2475, 2476, 7, 48,
	2, 2, 2476, 2478, 7, 78, 2, 2, 2477, 2479, 5, 42, 22, 2, 2478, 2477, 3,
	2, 2, 2, 2478, 2479, 3, 2, 2, 2, 2479, 2480, 3, 2, 2, 2, 2480, 2481, 5,
	490, 246, 2, 2481, 2483, 7, 70, 2, 2, 2482, 2484, 5, 414, 208, 2, 2483,
	2482, 3, 2, 2, 2, 2483, 2484, 3, 2, 2, 2, 2484, 2485, 3, 2, 2, 2, 2485,
	2486, 7, 71, 2, 2, 2486, 2488, 3, 2, 2, 2, 2487, 2418, 3, 2, 2, 2, 2487,
	2425, 3, 2, 2, 2, 2487, 2437, 3, 2, 2, 2, 2487, 2449, 3, 2, 2, 2, 2487,
	2461, 3, 2, 2, 2, 2487, 2473, 3, 2, 2, 2, 2488, 409, 3, 2, 2, 2, 2489,
	2491, 7, 78, 2, 2, 2490, 2492, 5, 42, 22, 2, 2491, 2490, 3, 2, 2, 2, 2491,
	2492, 3, 2, 2, 2, 2492, 2493, 3, 2, 2, 2, 2493, 2494, 5, 490, 246, 2, 2494,
	2496, 7, 70, 2, 2, 2495, 2497, 5, 414, 208, 2, 2496, 2495, 3, 2, 2, 2,
	2496, 2497, 3, 2, 2, 2, 2497, 2498, 3, 2, 2, 2, 2498, 2499, 7, 71, 2, 2,
	2499, 411, 3, 2, 2, 2, 2500, 2501, 5, 62, 32, 2, 2501, 2503, 7, 70, 2,
	2, 2502, 2504, 5, 414, 208, 2, 2503, 2502, 3, 2, 2, 2, 2503, 2504, 3, 2,
	2, 2, 2504, 2505, 3, 2, 2, 2, 2505, 2506, 7, 71, 2, 2, 2506, 2558, 3, 2,
	2, 2, 2507, 2508, 5, 56, 29, 2, 2508, 2510, 7, 78, 2, 2, 2509, 2511, 5,
	42, 22, 2, 2510, 2509, 3, 2, 2, 2, 2510, 2511, 3, 2, 2, 2, 2511, 2512,
	3, 2, 2, 2, 2512, 2513, 5, 490, 246, 2, 2513, 2515, 7, 70, 2, 2, 2514,
	2516, 5, 414, 208, 2, 2515, 2514, 3, 2, 2, 2, 2515, 2516, 3, 2, 2, 2, 2516,
	2517, 3, 2, 2, 2, 2517, 2518, 7, 71, 2, 2, 2518, 2558, 3, 2, 2, 2, 2519,
	2520, 5, 60, 31, 2, 2520, 2522, 7, 78, 2, 2, 2521, 2523, 5, 42, 22, 2,
	2522, 2521, 3, 2, 2, 2, 2522, 2523, 3, 2, 2, 2, 2523, 2524, 3, 2, 2, 2,
	2524, 2525, 5, 490, 246, 2, 2525, 2527, 7, 70, 2, 2, 2526, 2528, 5, 414,
	208, 2, 2527, 2526, 3, 2, 2, 2, 2527, 2528, 3, 2, 2, 2, 2528, 2529, 3,
	2, 2, 2, 2529, 2530, 7, 71, 2, 2, 2530, 2558, 3, 2, 2, 2, 2531, 2532, 7,
	48, 2, 2, 2532, 2534, 7, 78, 2, 2, 2533, 2535, 5, 42, 22, 2, 2534, 2533,
	3, 2, 2, 2, 2534, 2535, 3, 2, 2, 2, 2535, 2536, 3, 2, 2, 2, 2536, 2537,
	5, 490, 246, 2, 2537, 2539, 7, 70, 2, 2, 2538, 2540, 5, 414, 208, 2, 2539,
	2538, 3, 2, 2, 2, 2539, 2540, 3, 2, 2, 2, 2540, 2541, 3, 2, 2, 2, 2541,
	2542, 7, 71, 2, 2, 2542, 2558, 3, 2, 2, 2, 2543, 2544, 5, 56, 29, 2, 2544,
	2545, 7, 78, 2, 2, 2545, 2546, 7, 48, 2, 2, 2546, 2548, 7, 78, 2, 2, 2547,
	2549, 5, 42, 22, 2, 2548, 2547, 3, 2, 2, 2, 2548, 2549, 3, 2, 2, 2, 2549,
	2550, 3, 2, 2, 2, 2550, 2551, 5, 490, 246, 2, 2551, 2553, 7, 70, 2, 2,
	2552, 2554, 5, 414, 208, 2, 2553, 2552, 3, 2, 2, 2, 2553, 2554, 3, 2, 2,
	2, 2554, 2555, 3, 2, 2, 2, 2555, 2556, 7, 71, 2, 2, 2556, 2558, 3, 2, 2,
	2, 2557, 2500, 3, 2, 2, 2, 2557, 2507, 3, 2, 2, 2, 2557, 2519, 3, 2, 2,
	2, 2557, 2531, 3, 2, 2, 2, 2557, 2543, 3, 2, 2, 2, 2558, 413, 3, 2, 2,
	2, 2559, 2564, 5, 430, 216, 2, 2560, 2561, 7, 77, 2, 2, 2561, 2563, 5,
	430, 216, 2, 2562, 2560, 3, 2, 2, 2, 2563, 2566, 3, 2, 2, 2, 2564, 2562,
	3, 2, 2, 2, 2564, 2565, 3, 2, 2, 2, 2565, 415, 3, 2, 2, 2, 2566, 2564,
	3, 2, 2, 2, 2567, 2568, 5, 60, 31, 2, 2568, 2570, 7, 81, 2, 2, 2569, 2571,
	5, 42, 22, 2, 2570, 2569, 3, 2, 2, 2, 2570, 2571, 3, 2, 2, 2, 2571, 2572,
	3, 2, 2, 2, 2572, 2573, 5, 490, 246, 2, 2573, 2615, 3, 2, 2, 2, 2574, 2575,
	5, 12, 7, 2, 2575, 2577, 7, 81, 2, 2, 2576, 2578, 5, 42, 22, 2, 2577, 2576,
	3, 2, 2, 2, 2577, 2578, 3, 2, 2, 2, 2578, 2579, 3, 2, 2, 2, 2579, 2580,
	5, 490, 246, 2, 2580, 2615, 3, 2, 2, 2, 2581, 2582, 5, 366, 184, 2, 2582,
	2584, 7, 81, 2, 2, 2583, 2585, 5, 42, 22, 2, 2584, 2583, 3, 2, 2, 2, 2584,
	2585, 3, 2, 2, 2, 2585, 2586, 3, 2, 2, 2, 2586, 2587, 5, 490, 246, 2, 2587,
	2615, 3, 2, 2, 2, 2588, 2589, 7, 48, 2, 2, 2589, 2591, 7, 81, 2, 2, 2590,
	2592, 5, 42, 22, 2, 2591, 2590, 3, 2, 2, 2, 2591, 2592, 3, 2, 2, 2, 2592,
	2593, 3, 2, 2, 2, 2593, 2615, 5, 490, 246, 2, 2594, 2595, 5, 56, 29, 2,
	2595, 2596, 7, 78, 2, 2, 2596, 2597, 7, 48, 2, 2, 2597, 2599, 7, 81, 2,
	2, 2598, 2600, 5, 42, 22, 2, 2599, 2598, 3, 2, 2, 2, 2599, 2600, 3, 2,
	2, 2, 2600, 2601, 3, 2, 2, 2, 2601, 2602, 5, 490, 246, 2, 2602, 2615, 3,
	2, 2, 2, 2603, 2604, 5, 16, 9, 2, 2604, 2606, 7, 81, 2, 2, 2605, 2607,
	5, 42, 22, 2, 2606, 2605, 3, 2, 2, 2, 2606, 2607, 3, 2, 2, 2, 2607, 2608,
	3, 2, 2, 2, 2608, 2609, 7, 35, 2, 2, 2609, 2615, 3, 2, 2, 2, 2610, 2611,
	5, 30, 16, 2, 2611, 2612, 7, 81, 2, 2, 2612, 2613, 7, 35, 2, 2, 2613, 2615,
	3, 2, 2, 2, 2614, 2567, 3, 2, 2, 2, 2614, 2574, 3, 2, 2, 2, 2614, 2581,
	3, 2, 2, 2, 2614, 2588, 3, 2, 2, 2, 2614, 2594, 3, 2, 2, 2, 2614, 2603,
	3, 2, 2, 2, 2614, 2610, 3, 2, 2, 2, 2615, 417, 3, 2, 2, 2, 2616, 2618,
	7, 81, 2, 2, 2617, 2619, 5, 42, 22, 2, 2618, 2617, 3, 2, 2, 2, 2618, 2619,
	3, 2, 2, 2, 2619, 2620, 3, 2, 2, 2, 2620, 2621, 5, 490, 246, 2, 2621, 419,
	3, 2, 2, 2, 2622, 2623, 5, 60, 31, 2, 2623, 2625, 7, 81, 2, 2, 2624, 2626,
	5, 42, 22, 2, 2625, 2624, 3, 2, 2, 2, 2625, 2626, 3, 2, 2, 2, 2626, 2627,
	3, 2, 2, 2, 2627, 2628, 5, 490, 246, 2, 2628, 2663, 3, 2, 2, 2, 2629, 2630,
	5, 12, 7, 2, 2630, 2632, 7, 81, 2, 2, 2631, 2633, 5, 42, 22, 2, 2632, 2631,
	3, 2, 2, 2, 2632, 2633, 3, 2, 2, 2, 2633, 2634, 3, 2, 2, 2, 2634, 2635,
	5, 490, 246, 2, 2635, 2663, 3, 2, 2, 2, 2636, 2637, 7, 48, 2, 2, 2637,
	2639, 7, 81, 2, 2, 2638, 2640, 5, 42, 22, 2, 2639, 2638, 3, 2, 2, 2, 2639,
	2640, 3, 2, 2, 2, 2640, 2641, 3, 2, 2, 2, 2641, 2663, 5, 490, 246, 2, 2642,
	2643, 5, 56, 29, 2, 2643, 2644, 7, 78, 2, 2, 2644, 2645, 7, 48, 2, 2, 2645,
	2647, 7, 81, 2, 2, 2646, 2648, 5, 42, 22, 2, 2647, 2646, 3, 2, 2, 2, 2647,
	2648, 3, 2, 2, 2, 2648, 2649, 3, 2, 2, 2, 2649, 2650, 5, 490, 246, 2, 2650,
	2663, 3, 2, 2, 2, 2651, 2652, 5, 16, 9, 2, 2652, 2654, 7, 81, 2, 2, 2653,
	2655, 5, 42, 22, 2, 2654, 2653, 3, 2, 2, 2, 2654, 2655, 3, 2, 2, 2, 2655,
	2656, 3, 2, 2, 2, 2656, 2657, 7, 35, 2, 2, 2657, 2663, 3, 2, 2, 2, 2658,
	2659, 5, 30, 16, 2, 2659, 2660, 7, 81, 2, 2, 2660, 2661, 7, 35, 2, 2, 2661,
	2663, 3, 2, 2, 2, 2662, 2622, 3, 2, 2, 2, 2662, 2629, 3, 2, 2, 2, 2662,
	2636, 3, 2, 2, 2, 2662, 2642, 3, 2, 2, 2, 2662, 2651, 3, 2, 2, 2, 2662,
	2658, 3, 2, 2, 2, 2663, 421, 3, 2, 2, 2, 2664, 2665, 7, 35, 2, 2, 2665,
	2666, 5, 4, 3, 2, 2666, 2668, 5, 424, 213, 2, 2667, 2669, 5, 32, 17, 2,
	2668, 2667, 3, 2, 2, 2, 2668, 2669, 3, 2, 2, 2, 2669, 2687, 3, 2, 2, 2,
	2670, 2671, 7, 35, 2, 2, 2671, 2672, 5, 14, 8, 2, 2672, 2674, 5, 424, 213,
	2, 2673, 2675, 5, 32, 17, 2, 2674, 2673, 3, 2, 2, 2, 2674, 2675, 3, 2,
	2, 2, 2675, 2687, 3, 2, 2, 2, 2676, 2677, 7, 35, 2, 2, 2677, 2678, 5, 4,
	3, 2, 2678, 2679, 5, 32, 17, 2, 2679, 2680, 5, 260, 131, 2, 2680, 2687,
	3, 2, 2, 2, 2681, 2682, 7, 35, 2, 2, 2682, 2683, 5, 14, 8, 2, 2683, 2684,
	5, 32, 17, 2, 2684, 2685, 5, 260, 131, 2, 2685, 2687, 3, 2, 2, 2, 2686,
	2664, 3, 2, 2, 2, 2686, 2670, 3, 2, 2, 2, 2686, 2676, 3, 2, 2, 2, 2686,
	2681, 3, 2, 2, 2, 2687, 423, 3, 2, 2, 2, 2688, 2690, 5, 426, 214, 2, 2689,
	2688, 3, 2, 2, 2, 2690, 2691, 3, 2, 2, 2, 2691, 2689, 3, 2, 2, 2, 2691,
	2692, 3, 2, 2, 2, 2692, 425, 3, 2, 2, 2, 2693, 2695, 5, 242, 122, 2, 2694,
	2693, 3, 2, 2, 2, 2695, 2698, 3, 2, 2, 2, 2696, 2694, 3, 2, 2, 2, 2696,
	2697, 3, 2, 2, 2, 2697, 2699, 3, 2, 2, 2, 2698, 2696, 3, 2, 2, 2, 2699,
	2700, 7, 74, 2, 2, 2700, 2701, 5, 430, 216, 2, 2701, 2702, 7, 75, 2, 2,
	2702, 427, 3, 2, 2, 2, 2703, 2704, 5, 430, 216, 2, 2704, 429, 3, 2, 2,
	2, 2705, 2708, 5, 432, 217, 2, 2706, 2708, 5, 440, 221, 2, 2707, 2705,
	3, 2, 2, 2, 2707, 2706, 3, 2, 2, 2, 2708, 431, 3, 2, 2, 2, 2709, 2710,
	5, 434, 218, 2, 2710, 2711, 7, 89, 2, 2, 2711, 2712, 5, 438, 220, 2, 2712,
	433, 3, 2, 2, 2, 2713, 2724, 5, 490, 246, 2, 2714, 2716, 7, 70, 2, 2, 2715,
	2717, 5, 162, 82, 2, 2716, 2715, 3, 2, 2, 2, 2716, 2717, 3, 2, 2, 2, 2717,
	2718, 3, 2, 2, 2, 2718, 2724, 7, 71, 2, 2, 2719, 2720, 7, 70, 2, 2, 2720,
	2721, 5, 436, 219, 2, 2721, 2722, 7, 71, 2, 2, 2722, 2724, 3, 2, 2, 2,
	2723, 2713, 3, 2, 2, 2, 2723, 2714, 3, 2, 2, 2, 2723, 2719, 3, 2, 2, 2,
	2724, 435, 3, 2, 2, 2, 2725, 2730, 5, 490, 246, 2, 2726, 2727, 7, 77, 2,
	2, 2727, 2729, 5, 490, 246, 2, 2728, 2726, 3, 2, 2, 2, 2729, 2732, 3, 2,
	2, 2, 2730, 2728, 3, 2, 2, 2, 2730, 2731, 3, 2, 2, 2, 2731, 437, 3, 2,
	2, 2, 2732, 2730, 3, 2, 2, 2, 2733, 2736, 5, 430, 216, 2, 2734, 2736, 5,
	264, 133, 2, 2735, 2733, 3, 2, 2, 2, 2735, 2734, 3, 2, 2, 2, 2736, 439,
	3, 2, 2, 2, 2737, 2740, 5, 448, 225, 2, 2738, 2740, 5, 442, 222, 2, 2739,
	2737, 3, 2, 2, 2, 2739, 2738, 3, 2, 2, 2, 2740, 441, 3, 2, 2, 2, 2741,
	2742, 5, 444, 223, 2, 2742, 2743, 5, 446, 224, 2, 2743, 2744, 5, 430, 216,
	2, 2744, 443, 3, 2, 2, 2, 2745, 2749, 5, 60, 31, 2, 2746, 2749, 5, 396,
	199, 2, 2747, 2749, 5, 402, 202, 2, 2748, 2745, 3, 2, 2, 2, 2748, 2746,
	3, 2, 2, 2, 2748, 2747, 3, 2, 2, 2, 2749, 445, 3, 2, 2, 2, 2750, 2751,
	9, 6, 2, 2, 2751, 447, 3, 2, 2, 2, 2752, 2762, 5, 450, 226, 2, 2753, 2754,
	5, 450, 226, 2, 2754, 2755, 7, 87, 2, 2, 2755, 2756, 5, 430, 216, 2, 2756,
	2759, 7, 88, 2, 2, 2757, 2760, 5, 448, 225, 2, 2758, 2760, 5, 432, 217,
	2, 2759, 2757, 3, 2, 2, 2, 2759, 2758, 3, 2, 2, 2, 2760, 2762, 3, 2, 2,
	2, 2761, 2752, 3, 2, 2, 2, 2761, 2753, 3, 2, 2, 2, 2762, 449, 3, 2, 2,
	2, 2763, 2764, 8, 226, 1, 2, 2764, 2765, 5, 452, 227, 2, 2765, 2771, 3,
	2, 2, 2, 2766, 2767, 12, 3, 2, 2, 2767, 2768, 7, 95, 2, 2, 2768, 2770,
	5, 452, 227, 2, 2769, 2766, 3, 2, 2, 2, 2770, 2773, 3, 2, 2, 2, 2771, 2769,
	3, 2, 2, 2, 2771, 2772, 3, 2, 2, 2, 2772, 451, 3, 2, 2, 2, 2773, 2771,
	3, 2, 2, 2, 2774, 2775, 8, 227, 1, 2, 2775, 2776, 5, 454, 228, 2, 2776,
	2782, 3, 2, 2, 2, 2777, 2778, 12, 3, 2, 2, 2778, 2779, 7, 94, 2, 2, 2779,
	2781, 5, 454, 228, 2, 2780, 2777, 3, 2, 2, 2, 2781, 2784, 3, 2, 2, 2, 2782,
	2780, 3, 2, 2, 2, 2782, 2783, 3, 2, 2, 2, 2783, 453, 3, 2, 2, 2, 2784,
	2782, 3, 2, 2, 2, 2785, 2786, 8, 228, 1, 2, 2786, 2787, 5, 456, 229, 2,
	2787, 2793, 3, 2, 2, 2, 2788, 2789, 12, 3, 2, 2, 2789, 2790, 7, 103, 2,
	2, 2790, 2792, 5, 456, 229, 2, 2791, 2788, 3, 2, 2, 2, 2792, 2795, 3, 2,
	2, 2, 2793, 2791, 3, 2, 2, 2, 2793, 2794, 3, 2, 2, 2, 2794, 455, 3, 2,
	2, 2, 2795, 2793, 3, 2, 2, 2, 2796, 2797, 8, 229, 1, 2, 2797, 2798, 5,
	458, 230, 2, 2798, 2804, 3, 2, 2, 2, 2799, 2800, 12, 3, 2, 2, 2800, 2801,
	7, 104, 2, 2, 2801, 2803, 5, 458, 230, 2, 2802, 2799, 3, 2, 2, 2, 2803,
	2806, 3, 2, 2, 2, 2804, 2802, 3, 2, 2, 2, 2804, 2805, 3, 2, 2, 2, 2805,
	457, 3, 2, 2, 2, 2806, 2804, 3, 2, 2, 2, 2807, 2808, 8, 230, 1, 2, 2808,
	2809, 5, 460, 231, 2, 2809, 2815, 3, 2, 2, 2, 2810, 2811, 12, 3, 2, 2,
	2811, 2812, 7, 102, 2, 2, 2812, 2814, 5, 460, 231, 2, 2813, 2810, 3, 2,
	2, 2, 2814, 2817, 3, 2, 2, 2, 2815, 2813, 3, 2, 2, 2, 2815, 2816, 3, 2,
	2, 2, 2816, 459, 3, 2, 2, 2, 2817, 2815, 3, 2, 2, 2, 2818, 2819, 8, 231,
	1, 2, 2819, 2820, 5, 462, 232, 2, 2820, 2829, 3, 2, 2, 2, 2821, 2822, 12,
	4, 2, 2, 2822, 2823, 7, 90, 2, 2, 2823, 2828, 5, 462, 232, 2, 2824, 2825,
	12, 3, 2, 2, 2825, 2826, 7, 93, 2, 2, 2826, 2828, 5, 462, 232, 2, 2827,
	2821, 3, 2, 2, 2, 2827, 2824, 3, 2, 2, 2, 2828, 2831, 3, 2, 2, 2, 2829,
	2827, 3, 2, 2, 2, 2829, 2830, 3, 2, 2, 2, 2830, 461, 3, 2, 2, 2, 2831,
	2829, 3, 2, 2, 2, 2832, 2833, 8, 232, 1, 2, 2833, 2834, 5, 464, 233, 2,
	2834, 2852, 3, 2, 2, 2, 2835, 2836, 12, 7, 2, 2, 2836, 2837, 7, 84, 2,
	2, 2837, 2851, 5, 464, 233, 2, 2838, 2839, 12, 6, 2, 2, 2839, 2840, 7,
	83, 2, 2, 2840, 2851, 5, 464, 233, 2, 2841, 2842, 12, 5, 2, 2, 2842, 2843,
	7, 91, 2, 2, 2843, 2851, 5, 464, 233, 2, 2844, 2845, 12, 4, 2, 2, 2845,
	2846, 7, 92, 2, 2, 2846, 2851, 5, 464, 233, 2, 2847, 2848, 12, 3, 2, 2,
	2848, 2849, 7, 29, 2, 2, 2849, 2851, 5, 12, 7, 2, 2850, 2835, 3, 2, 2,
	2, 2850, 2838, 3, 2, 2, 2, 2850, 2841, 3, 2, 2, 2, 2850, 2844, 3, 2, 2,
	2, 2850, 2847, 3, 2, 2, 2, 2851, 2854, 3, 2, 2, 2, 2852, 2850, 3, 2, 2,
	2, 2852, 2853, 3, 2, 2, 2, 2853, 463, 3, 2, 2, 2, 2854, 2852, 3, 2, 2,
	2, 2855, 2856, 8, 233, 1, 2, 2856, 2857, 5, 466, 234, 2, 2857, 2873, 3,
	2, 2, 2, 2858, 2859, 12, 5, 2, 2, 2859, 2860, 7, 84, 2, 2, 2860, 2861,
	7, 84, 2, 2, 2861, 2872, 5, 466, 234, 2, 2862, 2863, 12, 4, 2, 2, 2863,
	2864, 7, 83, 2, 2, 2864, 2865, 7, 83, 2, 2, 2865, 2872, 5, 466, 234, 2,
	2866, 2867, 12, 3, 2, 2, 2867, 2868, 7, 83, 2, 2, 2868, 2869, 7, 83, 2,
	2, 2869, 2870, 7, 83, 2, 2, 2870, 2872, 5, 466, 234, 2, 2871, 2858, 3,
	2, 2, 2, 2871, 2862, 3, 2, 2, 2, 2871, 2866, 3, 2, 2, 2, 2872, 2875, 3,
	2, 2, 2, 2873, 2871, 3, 2, 2, 2, 2873, 2874, 3, 2, 2, 2, 2874, 465, 3,
	2, 2, 2, 2875, 2873, 3, 2, 2, 2, 2876, 2877, 8, 234, 1, 2, 2877, 2878,
	5, 468, 235, 2, 2878, 2887, 3, 2, 2, 2, 2879, 2880, 12, 4, 2, 2, 2880,
	2881, 7, 98, 2, 2, 2881, 2886, 5, 468, 235, 2, 2882, 2883, 12, 3, 2, 2,
	2883, 2884, 7, 99, 2, 2, 2884, 2886, 5, 468, 235, 2, 2885, 2879, 3, 2,
	2, 2, 2885, 2882, 3, 2, 2, 2, 2886, 2889, 3, 2, 2, 2, 2887, 2885, 3, 2,
	2, 2, 2887, 2888, 3, 2, 2, 2, 2888, 467, 3, 2, 2, 2, 2889, 2887, 3, 2,
	2, 2, 2890, 2891, 8, 235, 1, 2, 2891, 2892, 5, 470, 236, 2, 2892, 2904,
	3, 2, 2, 2, 2893, 2894, 12, 5, 2, 2, 2894, 2895, 7, 100, 2, 2, 2895, 2903,
	5, 470, 236, 2, 2896, 2897, 12, 4, 2, 2, 2897, 2898, 7, 101, 2, 2, 2898,
	2903, 5, 470, 236, 2, 2899, 2900, 12, 3, 2, 2, 2900, 2901, 7, 105, 2, 2,
	2901, 2903, 5, 470, 236, 2, 2902, 2893, 3, 2, 2, 2, 2902, 2896, 3, 2, 2,
	2, 2902, 2899, 3, 2, 2, 2, 2903, 2906, 3, 2, 2, 2, 2904, 2902, 3, 2, 2,
	2, 2904, 2905, 3, 2, 2, 2, 2905, 469, 3, 2, 2, 2, 2906, 2904, 3, 2, 2,
	2, 2907, 2915, 5, 472, 237, 2, 2908, 2915, 5, 474, 238, 2, 2909, 2910,
	7, 98, 2, 2, 2910, 2915, 5, 470, 236, 2, 2911, 2912, 7, 99, 2, 2, 2912,
	2915, 5, 470, 236, 2, 2913, 2915, 5, 476, 239, 2, 2914, 2907, 3, 2, 2,
	2, 2914, 2908, 3, 2, 2, 2, 2914, 2909, 3, 2, 2, 2, 2914, 2911, 3, 2, 2,
	2, 2914, 2913, 3, 2, 2, 2, 2915, 471, 3, 2, 2, 2, 2916, 2917, 7, 96, 2,
	2, 2917, 2918, 5, 470, 236, 2, 2918, 473, 3, 2, 2, 2, 2919, 2920, 7, 97,
	2, 2, 2920, 2921, 5, 470, 236, 2, 2921, 475, 3, 2, 2, 2, 2922, 2929, 5,
	478, 240, 2, 2923, 2924, 7, 86, 2, 2, 2924, 2929, 5, 470, 236, 2, 2925,
	2926, 7, 85, 2, 2, 2926, 2929, 5, 470, 236, 2, 2927, 2929, 5, 488, 245,
	2, 2928, 2922, 3, 2, 2, 2, 2928, 2923, 3, 2, 2, 2, 2928, 2925, 3, 2, 2,
	2, 2928, 2927, 3, 2, 2, 2, 2929, 477, 3, 2, 2, 2, 2930, 2933, 5, 366, 184,
	2, 2931, 2933, 5, 60, 31, 2, 2932, 2930, 3, 2, 2, 2, 2932, 2931, 3, 2,
	2, 2, 2933, 2938, 3, 2, 2, 2, 2934, 2937, 5, 482, 242, 2, 2935, 2937, 5,
	486, 244, 2, 2936, 2934, 3, 2, 2, 2, 2936, 2935, 3, 2, 2, 2, 2937, 2940,
	3, 2, 2, 2, 2938, 2936, 3, 2, 2, 2, 2938, 2939, 3, 2, 2, 2, 2939, 479,
	3, 2, 2, 2, 2940, 2938, 3, 2, 2, 2, 2941, 2942, 5, 478, 240, 2, 2942, 2943,
	7, 96, 2, 2, 2943, 481, 3, 2, 2, 2, 2944, 2945, 7, 96, 2, 2, 2945, 483,
	3, 2, 2, 2, 2946, 2947, 5, 478, 240, 2, 2947, 2948, 7, 97, 2, 2, 2948,
	485, 3, 2, 2, 2, 2949, 2950, 7, 97, 2, 2, 2950, 487, 3, 2, 2, 2, 2951,
	2952, 7, 70, 2, 2, 2952, 2953, 5, 4, 3, 2, 2953, 2954, 7, 71, 2, 2, 2954,
	2955, 5, 470, 236, 2, 2955, 2979, 3, 2, 2, 2, 2956, 2957, 7, 70, 2, 2,
	2957, 2961, 5, 12, 7, 2, 2958, 2960, 5, 40, 21, 2, 2959, 2958, 3, 2, 2,
	2, 2960, 2963, 3, 2, 2, 2, 2961, 2959, 3, 2, 2, 2, 2961, 2962, 3, 2, 2,
	2, 2962, 2964, 3, 2, 2, 2, 2963, 2961, 3, 2, 2, 2, 2964, 2965, 7, 71, 2,
	2, 2965, 2966, 5, 476, 239, 2, 2966, 2979, 3, 2, 2, 2, 2967, 2968, 7, 70,
	2, 2, 2968, 2972, 5, 12, 7, 2, 2969, 2971, 5, 40, 21, 2, 2970, 2969, 3,
	2, 2, 2, 2971, 2974, 3, 2, 2, 2, 2972, 2970, 3, 2, 2, 2, 2972, 2973, 3,
	2, 2, 2, 2973, 2975, 3, 2, 2, 2, 2974, 2972, 3, 2, 2, 2, 2975, 2976, 7,
	71, 2, 2, 2976, 2977, 5, 432, 217, 2, 2977, 2979, 3, 2, 2, 2, 2978, 2951,
	3, 2, 2, 2, 2978, 2956, 3, 2, 2, 2, 2978, 2967, 3, 2, 2, 2, 2979, 489,
	3, 2, 2, 2, 2980, 2981, 9, 7, 2, 2, 2981, 491, 3, 2, 2, 2, 342, 497, 504,
	508, 512, 521, 525, 529, 531, 537, 542, 549, 554, 556, 562, 567, 572, 577,
	588, 602, 607, 615, 622, 628, 633, 644, 647, 661, 666, 671, 676, 682, 692,
	703, 711, 721, 729, 741, 746, 749, 754, 760, 768, 776, 789, 818, 823, 827,
	835, 844, 858, 861, 873, 876, 892, 897, 903, 908, 914, 917, 920, 932, 943,
	957, 964, 973, 980, 985, 1000, 1007, 1013, 1017, 1021, 1025, 1029, 1034,
	1038, 1042, 1044, 1049, 1056, 1061, 1063, 1069, 1074, 1078, 1097, 1102,
	1118, 1123, 1129, 1135, 1137, 1141, 1146, 1150, 1158, 1165, 1173, 1176,
	1181, 1189, 1194, 1201, 1208, 1213, 1220, 1232, 1237, 1241, 1251, 1256,
	1264, 1267, 1272, 1280, 1283, 1288, 1293, 1298, 1303, 1310, 1315, 1323,
	1328, 1333, 1338, 1344, 1350, 1353, 1356, 1365, 1371, 1377, 1380, 1383,
	1391, 1396, 1401, 1407, 1410, 1421, 1430, 1440, 1445, 1456, 1461, 1474,
	1479, 1491, 1501, 1506, 1514, 1517, 1524, 1532, 1538, 1547, 1557, 1561,
	1564, 1573, 1587, 1590, 1599, 1604, 1611, 1616, 1624, 1636, 1643, 1657,
	1679, 1713, 1725, 1731, 1742, 1754, 1780, 1784, 1789, 1793, 1797, 1805,
	1809, 1813, 1820, 1829, 1837, 1852, 1864, 1870, 1876, 1897, 1902, 1907,
	1918, 1929, 1939, 1942, 1947, 1956, 1962, 1971, 1975, 1979, 1984, 2003,
	2013, 2035, 2042, 2050, 2058, 2069, 2092, 2102, 2113, 2135, 2140, 2146,
	2154, 2158, 2163, 2171, 2177, 2181, 2185, 2189, 2195, 2200, 2205, 2209,
	2213, 2219, 2224, 2229, 2233, 2237, 2239, 2244, 2249, 2254, 2258, 2262,
	2266, 2271, 2279, 2285, 2289, 2293, 2297, 2303, 2308, 2313, 2317, 2321,
	2323, 2328, 2343, 2357, 2369, 2378, 2393, 2406, 2415, 2421, 2428, 2433,
	2440, 2445, 2452, 2457, 2464, 2469, 2478, 2483, 2487, 2491, 2496, 2503,
	2510, 2515, 2522, 2527, 2534, 2539, 2548, 2553, 2557, 2564, 2570, 2577,
	2584, 2591, 2599, 2606, 2614, 2618, 2625, 2632, 2639, 2647, 2654, 2662,
	2668, 2674, 2686, 2691, 2696, 2707, 2716, 2723, 2730, 2735, 2739, 2748,
	2759, 2761, 2771, 2782, 2793, 2804, 2815, 2827, 2829, 2850, 2852, 2871,
	2873, 2885, 2887, 2902, 2904, 2914, 2928, 2932, 2936, 2938, 2961, 2972,
	2978,
}
var deserializer = antlr.NewATNDeserializer(nil)
var deserializedATN = deserializer.DeserializeFromUInt16(parserATN)

var literalNames = []string{
	"", "'abstract'", "'assert'", "'boolean'", "'break'", "'byte'", "'case'",
	"'catch'", "'char'", "'class'", "'const'", "'continue'", "'default'", "'do'",
	"'double'", "'else'", "'enum'", "'exports'", "'extends'", "'final'", "'finally'",
	"'float'", "'for'", "'if'", "'goto'", "'implements'", "'import'", "'instanceof'",
	"'int'", "'interface'", "'long'", "'module'", "'native'", "'new'", "'open'",
	"'opens'", "'package'", "'private'", "'protected'", "'provides'", "'public'",
	"'requires'", "'return'", "'short'", "'static'", "'strictfp'", "'super'",
	"'switch'", "'synchronized'", "'this'", "'throw'", "'throws'", "'to'",
	"'transient'", "'transitive'", "'try'", "'uses'", "'void'", "'volatile'",
	"'while'", "'with'", "'_'", "", "", "", "", "", "'null'", "'('", "')'",
	"'{'", "'}'", "'['", "']'", "';'", "','", "'.'", "'...'", "'@'", "'::'",
	"'='", "'>'", "'<'", "'!'", "'~'", "'?'", "':'", "'->'", "'=='", "'<='",
	"'>='", "'!='", "'&&'", "'||'", "'++'", "'--'", "'+'", "'-'", "'*'", "'/'",
	"'&'", "'|'", "'^'", "'%'", "'+='", "'-='", "'*='", "'/='", "'&='", "'|='",
	"'^='", "'%='", "'<<='", "'>>='", "'>>>='",
}
var symbolicNames = []string{
	"", "ABSTRACT", "ASSERT", "BOOLEAN", "BREAK", "BYTE", "CASE", "CATCH",
	"CHAR", "CLASS", "CONST", "CONTINUE", "DEFAULT", "DO", "DOUBLE", "ELSE",
	"ENUM", "EXPORTS", "EXTENDS", "FINAL", "FINALLY", "FLOAT", "FOR", "IF",
	"GOTO", "IMPLEMENTS", "IMPORT", "INSTANCEOF", "INT", "INTERFACE", "LONG",
	"MODULE", "NATIVE", "NEW", "OPEN", "OPERNS", "PACKAGE", "PRIVATE", "PROTECTED",
	"PROVIDES", "PUBLIC", "REQUIRES", "RETURN", "SHORT", "STATIC", "STRICTFP",
	"SUPER", "SWITCH", "SYNCHRONIZED", "THIS", "THROW", "THROWS", "TO", "TRANSIENT",
	"TRANSITIVE", "TRY", "USES", "VOID", "VOLATILE", "WHILE", "WITH", "UNDER_SCORE",
	"IntegerLiteral", "FloatingPointLiteral", "BooleanLiteral", "CharacterLiteral",
	"StringLiteral", "NullLiteral", "LPAREN", "RPAREN", "LBRACE", "RBRACE",
	"LBRACK", "RBRACK", "SEMI", "COMMA", "DOT", "ELLIPSIS", "AT", "COLONCOLON",
	"ASSIGN", "GT", "LT", "BANG", "TILDE", "QUESTION", "COLON", "ARROW", "EQUAL",
	"LE", "GE", "NOTEQUAL", "AND", "OR", "INC", "DEC", "ADD", "SUB", "MUL",
	"DIV", "BITAND", "BITOR", "CARET", "MOD", "ADD_ASSIGN", "SUB_ASSIGN", "MUL_ASSIGN",
	"DIV_ASSIGN", "AND_ASSIGN", "OR_ASSIGN", "XOR_ASSIGN", "MOD_ASSIGN", "LSHIFT_ASSIGN",
	"RSHIFT_ASSIGN", "URSHIFT_ASSIGN", "Identifier", "WS", "COMMENT", "LINE_COMMENT",
}

var ruleNames = []string{
	"literal", "primitiveType", "numericType", "integralType", "floatingPointType",
	"referenceType", "classOrInterfaceType", "classType", "classType_lf_classOrInterfaceType",
	"classType_lfno_classOrInterfaceType", "interfaceType", "interfaceType_lf_classOrInterfaceType",
	"interfaceType_lfno_classOrInterfaceType", "typeVariable", "arrayType",
	"dims", "typeParameter", "typeParameterModifier", "typeBound", "additionalBound",
	"typeArguments", "typeArgumentList", "typeArgument", "wildcard", "wildcardBounds",
	"moduleName", "packageName", "typeName", "packageOrTypeName", "expressionName",
	"methodName", "ambiguousName", "compilationUnit", "ordinaryCompilation",
	"modularCompilation", "packageDeclaration", "packageModifier", "importDeclaration",
	"singleTypeImportDeclaration", "typeImportOnDemandDeclaration", "singleStaticImportDeclaration",
	"staticImportOnDemandDeclaration", "typeDeclaration", "moduleDeclaration",
	"moduleDirective", "requiresModifier", "classDeclaration", "normalClassDeclaration",
	"classModifier", "typeParameters", "typeParameterList", "superclass", "superinterfaces",
	"interfaceTypeList", "classBody", "classBodyDeclaration", "classMemberDeclaration",
	"fieldDeclaration", "fieldModifier", "variableDeclaratorList", "variableDeclarator",
	"variableDeclaratorId", "variableInitializer", "unannType", "unannPrimitiveType",
	"unannReferenceType", "unannClassOrInterfaceType", "unannClassType", "unannClassType_lf_unannClassOrInterfaceType",
	"unannClassType_lfno_unannClassOrInterfaceType", "unannInterfaceType",
	"unannInterfaceType_lf_unannClassOrInterfaceType", "unannInterfaceType_lfno_unannClassOrInterfaceType",
	"unannTypeVariable", "unannArrayType", "methodDeclaration", "methodModifier",
	"methodHeader", "result", "methodDeclarator", "formalParameterList", "formalParameters",
	"formalParameter", "variableModifier", "lastFormalParameter", "receiverParameter",
	"throws_", "exceptionTypeList", "exceptionType", "methodBody", "instanceInitializer",
	"staticInitializer", "constructorDeclaration", "constructorModifier", "constructorDeclarator",
	"simpleTypeName", "constructorBody", "explicitConstructorInvocation", "enumDeclaration",
	"enumBody", "enumConstantList", "enumConstant", "enumConstantModifier",
	"enumBodyDeclarations", "interfaceDeclaration", "normalInterfaceDeclaration",
	"interfaceModifier", "extendsInterfaces", "interfaceBody", "interfaceMemberDeclaration",
	"constantDeclaration", "constantModifier", "interfaceMethodDeclaration",
	"interfaceMethodModifier", "annotationTypeDeclaration", "annotationTypeBody",
	"annotationTypeMemberDeclaration", "annotationTypeElementDeclaration",
	"annotationTypeElementModifier", "defaultValue", "annotation", "normalAnnotation",
	"elementValuePairList", "elementValuePair", "elementValue", "elementValueArrayInitializer",
	"elementValueList", "markerAnnotation", "singleElementAnnotation", "arrayInitializer",
	"variableInitializerList", "block", "blockStatements", "blockStatement",
	"localVariableDeclarationStatement", "localVariableDeclaration", "statement",
	"statementNoShortIf", "statementWithoutTrailingSubstatement", "emptyStatement_",
	"labeledStatement", "labeledStatementNoShortIf", "expressionStatement",
	"statementExpression", "ifThenStatement", "ifThenElseStatement", "ifThenElseStatementNoShortIf",
	"assertStatement", "switchStatement", "switchBlock", "switchBlockStatementGroup",
	"switchLabels", "switchLabel", "enumConstantName", "whileStatement", "whileStatementNoShortIf",
	"doStatement", "forStatement", "forStatementNoShortIf", "basicForStatement",
	"basicForStatementNoShortIf", "forInit", "forUpdate", "statementExpressionList",
	"enhancedForStatement", "enhancedForStatementNoShortIf", "breakStatement",
	"continueStatement", "returnStatement", "throwStatement", "synchronizedStatement",
	"tryStatement", "catches", "catchClause", "catchFormalParameter", "catchType",
	"finally_", "tryWithResourcesStatement", "resourceSpecification", "resourceList",
	"resource", "variableAccess", "primary", "primaryNoNewArray", "primaryNoNewArray_lf_arrayAccess",
	"primaryNoNewArray_lfno_arrayAccess", "primaryNoNewArray_lf_primary", "primaryNoNewArray_lf_primary_lf_arrayAccess_lf_primary",
	"primaryNoNewArray_lf_primary_lfno_arrayAccess_lf_primary", "primaryNoNewArray_lfno_primary",
	"primaryNoNewArray_lfno_primary_lf_arrayAccess_lfno_primary", "primaryNoNewArray_lfno_primary_lfno_arrayAccess_lfno_primary",
	"classLiteral", "classInstanceCreationExpression", "classInstanceCreationExpression_lf_primary",
	"classInstanceCreationExpression_lfno_primary", "typeArgumentsOrDiamond",
	"fieldAccess", "fieldAccess_lf_primary", "fieldAccess_lfno_primary", "arrayAccess",
	"arrayAccess_lf_primary", "arrayAccess_lfno_primary", "methodInvocation",
	"methodInvocation_lf_primary", "methodInvocation_lfno_primary", "argumentList",
	"methodReference", "methodReference_lf_primary", "methodReference_lfno_primary",
	"arrayCreationExpression", "dimExprs", "dimExpr", "constantExpression",
	"expression", "lambdaExpression", "lambdaParameters", "inferredFormalParameterList",
	"lambdaBody", "assignmentExpression", "assignment", "leftHandSide", "assignmentOperator",
	"conditionalExpression", "conditionalOrExpression", "conditionalAndExpression",
	"inclusiveOrExpression", "exclusiveOrExpression", "andExpression", "equalityExpression",
	"relationalExpression", "shiftExpression", "additiveExpression", "multiplicativeExpression",
	"unaryExpression", "preIncrementExpression", "preDecrementExpression",
	"unaryExpressionNotPlusMinus", "postfixExpression", "postIncrementExpression",
	"postIncrementExpression_lf_postfixExpression", "postDecrementExpression",
	"postDecrementExpression_lf_postfixExpression", "castExpression", "identifier",
}
var decisionToDFA = make([]*antlr.DFA, len(deserializedATN.DecisionToState))

func init() {
	for index, ds := range deserializedATN.DecisionToState {
		decisionToDFA[index] = antlr.NewDFA(ds, index)
	}
}

type Java9Parser struct {
	*antlr.BaseParser
}

func NewJava9Parser(input antlr.TokenStream) *Java9Parser {
	this := new(Java9Parser)

	this.BaseParser = antlr.NewBaseParser(input)

	this.Interpreter = antlr.NewParserATNSimulator(this, deserializedATN, decisionToDFA, antlr.NewPredictionContextCache())
	this.RuleNames = ruleNames
	this.LiteralNames = literalNames
	this.SymbolicNames = symbolicNames
	this.GrammarFileName = "Java9Parser.g4"

	return this
}

// Java9Parser tokens.
const (
	Java9ParserEOF                  = antlr.TokenEOF
	Java9ParserABSTRACT             = 1
	Java9ParserASSERT               = 2
	Java9ParserBOOLEAN              = 3
	Java9ParserBREAK                = 4
	Java9ParserBYTE                 = 5
	Java9ParserCASE                 = 6
	Java9ParserCATCH                = 7
	Java9ParserCHAR                 = 8
	Java9ParserCLASS                = 9
	Java9ParserCONST                = 10
	Java9ParserCONTINUE             = 11
	Java9ParserDEFAULT              = 12
	Java9ParserDO                   = 13
	Java9ParserDOUBLE               = 14
	Java9ParserELSE                 = 15
	Java9ParserENUM                 = 16
	Java9ParserEXPORTS              = 17
	Java9ParserEXTENDS              = 18
	Java9ParserFINAL                = 19
	Java9ParserFINALLY              = 20
	Java9ParserFLOAT                = 21
	Java9ParserFOR                  = 22
	Java9ParserIF                   = 23
	Java9ParserGOTO                 = 24
	Java9ParserIMPLEMENTS           = 25
	Java9ParserIMPORT               = 26
	Java9ParserINSTANCEOF           = 27
	Java9ParserINT                  = 28
	Java9ParserINTERFACE            = 29
	Java9ParserLONG                 = 30
	Java9ParserMODULE               = 31
	Java9ParserNATIVE               = 32
	Java9ParserNEW                  = 33
	Java9ParserOPEN                 = 34
	Java9ParserOPERNS               = 35
	Java9ParserPACKAGE              = 36
	Java9ParserPRIVATE              = 37
	Java9ParserPROTECTED            = 38
	Java9ParserPROVIDES             = 39
	Java9ParserPUBLIC               = 40
	Java9ParserREQUIRES             = 41
	Java9ParserRETURN               = 42
	Java9ParserSHORT                = 43
	Java9ParserSTATIC               = 44
	Java9ParserSTRICTFP             = 45
	Java9ParserSUPER                = 46
	Java9ParserSWITCH               = 47
	Java9ParserSYNCHRONIZED         = 48
	Java9ParserTHIS                 = 49
	Java9ParserTHROW                = 50
	Java9ParserTHROWS               = 51
	Java9ParserTO                   = 52
	Java9ParserTRANSIENT            = 53
	Java9ParserTRANSITIVE           = 54
	Java9ParserTRY                  = 55
	Java9ParserUSES                 = 56
	Java9ParserVOID                 = 57
	Java9ParserVOLATILE             = 58
	Java9ParserWHILE                = 59
	Java9ParserWITH                 = 60
	Java9ParserUNDER_SCORE          = 61
	Java9ParserIntegerLiteral       = 62
	Java9ParserFloatingPointLiteral = 63
	Java9ParserBooleanLiteral       = 64
	Java9ParserCharacterLiteral     = 65
	Java9ParserStringLiteral        = 66
	Java9ParserNullLiteral          = 67
	Java9ParserLPAREN               = 68
	Java9ParserRPAREN               = 69
	Java9ParserLBRACE               = 70
	Java9ParserRBRACE               = 71
	Java9ParserLBRACK               = 72
	Java9ParserRBRACK               = 73
	Java9ParserSEMI                 = 74
	Java9ParserCOMMA                = 75
	Java9ParserDOT                  = 76
	Java9ParserELLIPSIS             = 77
	Java9ParserAT                   = 78
	Java9ParserCOLONCOLON           = 79
	Java9ParserASSIGN               = 80
	Java9ParserGT                   = 81
	Java9ParserLT                   = 82
	Java9ParserBANG                 = 83
	Java9ParserTILDE                = 84
	Java9ParserQUESTION             = 85
	Java9ParserCOLON                = 86
	Java9ParserARROW                = 87
	Java9ParserEQUAL                = 88
	Java9ParserLE                   = 89
	Java9ParserGE                   = 90
	Java9ParserNOTEQUAL             = 91
	Java9ParserAND                  = 92
	Java9ParserOR                   = 93
	Java9ParserINC                  = 94
	Java9ParserDEC                  = 95
	Java9ParserADD                  = 96
	Java9ParserSUB                  = 97
	Java9ParserMUL                  = 98
	Java9ParserDIV                  = 99
	Java9ParserBITAND               = 100
	Java9ParserBITOR                = 101
	Java9ParserCARET                = 102
	Java9ParserMOD                  = 103
	Java9ParserADD_ASSIGN           = 104
	Java9ParserSUB_ASSIGN           = 105
	Java9ParserMUL_ASSIGN           = 106
	Java9ParserDIV_ASSIGN           = 107
	Java9ParserAND_ASSIGN           = 108
	Java9ParserOR_ASSIGN            = 109
	Java9ParserXOR_ASSIGN           = 110
	Java9ParserMOD_ASSIGN           = 111
	Java9ParserLSHIFT_ASSIGN        = 112
	Java9ParserRSHIFT_ASSIGN        = 113
	Java9ParserURSHIFT_ASSIGN       = 114
	Java9ParserIdentifier           = 115
	Java9ParserWS                   = 116
	Java9ParserCOMMENT              = 117
	Java9ParserLINE_COMMENT         = 118
)

// Java9Parser rules.
const (
	Java9ParserRULE_literal                                                      = 0
	Java9ParserRULE_primitiveType                                                = 1
	Java9ParserRULE_numericType                                                  = 2
	Java9ParserRULE_integralType                                                 = 3
	Java9ParserRULE_floatingPointType                                            = 4
	Java9ParserRULE_referenceType                                                = 5
	Java9ParserRULE_classOrInterfaceType                                         = 6
	Java9ParserRULE_classType                                                    = 7
	Java9ParserRULE_classType_lf_classOrInterfaceType                            = 8
	Java9ParserRULE_classType_lfno_classOrInterfaceType                          = 9
	Java9ParserRULE_interfaceType                                                = 10
	Java9ParserRULE_interfaceType_lf_classOrInterfaceType                        = 11
	Java9ParserRULE_interfaceType_lfno_classOrInterfaceType                      = 12
	Java9ParserRULE_typeVariable                                                 = 13
	Java9ParserRULE_arrayType                                                    = 14
	Java9ParserRULE_dims                                                         = 15
	Java9ParserRULE_typeParameter                                                = 16
	Java9ParserRULE_typeParameterModifier                                        = 17
	Java9ParserRULE_typeBound                                                    = 18
	Java9ParserRULE_additionalBound                                              = 19
	Java9ParserRULE_typeArguments                                                = 20
	Java9ParserRULE_typeArgumentList                                             = 21
	Java9ParserRULE_typeArgument                                                 = 22
	Java9ParserRULE_wildcard                                                     = 23
	Java9ParserRULE_wildcardBounds                                               = 24
	Java9ParserRULE_moduleName                                                   = 25
	Java9ParserRULE_packageName                                                  = 26
	Java9ParserRULE_typeName                                                     = 27
	Java9ParserRULE_packageOrTypeName                                            = 28
	Java9ParserRULE_expressionName                                               = 29
	Java9ParserRULE_methodName                                                   = 30
	Java9ParserRULE_ambiguousName                                                = 31
	Java9ParserRULE_compilationUnit                                              = 32
	Java9ParserRULE_ordinaryCompilation                                          = 33
	Java9ParserRULE_modularCompilation                                           = 34
	Java9ParserRULE_packageDeclaration                                           = 35
	Java9ParserRULE_packageModifier                                              = 36
	Java9ParserRULE_importDeclaration                                            = 37
	Java9ParserRULE_singleTypeImportDeclaration                                  = 38
	Java9ParserRULE_typeImportOnDemandDeclaration                                = 39
	Java9ParserRULE_singleStaticImportDeclaration                                = 40
	Java9ParserRULE_staticImportOnDemandDeclaration                              = 41
	Java9ParserRULE_typeDeclaration                                              = 42
	Java9ParserRULE_moduleDeclaration                                            = 43
	Java9ParserRULE_moduleDirective                                              = 44
	Java9ParserRULE_requiresModifier                                             = 45
	Java9ParserRULE_classDeclaration                                             = 46
	Java9ParserRULE_normalClassDeclaration                                       = 47
	Java9ParserRULE_classModifier                                                = 48
	Java9ParserRULE_typeParameters                                               = 49
	Java9ParserRULE_typeParameterList                                            = 50
	Java9ParserRULE_superclass                                                   = 51
	Java9ParserRULE_superinterfaces                                              = 52
	Java9ParserRULE_interfaceTypeList                                            = 53
	Java9ParserRULE_classBody                                                    = 54
	Java9ParserRULE_classBodyDeclaration                                         = 55
	Java9ParserRULE_classMemberDeclaration                                       = 56
	Java9ParserRULE_fieldDeclaration                                             = 57
	Java9ParserRULE_fieldModifier                                                = 58
	Java9ParserRULE_variableDeclaratorList                                       = 59
	Java9ParserRULE_variableDeclarator                                           = 60
	Java9ParserRULE_variableDeclaratorId                                         = 61
	Java9ParserRULE_variableInitializer                                          = 62
	Java9ParserRULE_unannType                                                    = 63
	Java9ParserRULE_unannPrimitiveType                                           = 64
	Java9ParserRULE_unannReferenceType                                           = 65
	Java9ParserRULE_unannClassOrInterfaceType                                    = 66
	Java9ParserRULE_unannClassType                                               = 67
	Java9ParserRULE_unannClassType_lf_unannClassOrInterfaceType                  = 68
	Java9ParserRULE_unannClassType_lfno_unannClassOrInterfaceType                = 69
	Java9ParserRULE_unannInterfaceType                                           = 70
	Java9ParserRULE_unannInterfaceType_lf_unannClassOrInterfaceType              = 71
	Java9ParserRULE_unannInterfaceType_lfno_unannClassOrInterfaceType            = 72
	Java9ParserRULE_unannTypeVariable                                            = 73
	Java9ParserRULE_unannArrayType                                               = 74
	Java9ParserRULE_methodDeclaration                                            = 75
	Java9ParserRULE_methodModifier                                               = 76
	Java9ParserRULE_methodHeader                                                 = 77
	Java9ParserRULE_result                                                       = 78
	Java9ParserRULE_methodDeclarator                                             = 79
	Java9ParserRULE_formalParameterList                                          = 80
	Java9ParserRULE_formalParameters                                             = 81
	Java9ParserRULE_formalParameter                                              = 82
	Java9ParserRULE_variableModifier                                             = 83
	Java9ParserRULE_lastFormalParameter                                          = 84
	Java9ParserRULE_receiverParameter                                            = 85
	Java9ParserRULE_throws_                                                      = 86
	Java9ParserRULE_exceptionTypeList                                            = 87
	Java9ParserRULE_exceptionType                                                = 88
	Java9ParserRULE_methodBody                                                   = 89
	Java9ParserRULE_instanceInitializer                                          = 90
	Java9ParserRULE_staticInitializer                                            = 91
	Java9ParserRULE_constructorDeclaration                                       = 92
	Java9ParserRULE_constructorModifier                                          = 93
	Java9ParserRULE_constructorDeclarator                                        = 94
	Java9ParserRULE_simpleTypeName                                               = 95
	Java9ParserRULE_constructorBody                                              = 96
	Java9ParserRULE_explicitConstructorInvocation                                = 97
	Java9ParserRULE_enumDeclaration                                              = 98
	Java9ParserRULE_enumBody                                                     = 99
	Java9ParserRULE_enumConstantList                                             = 100
	Java9ParserRULE_enumConstant                                                 = 101
	Java9ParserRULE_enumConstantModifier                                         = 102
	Java9ParserRULE_enumBodyDeclarations                                         = 103
	Java9ParserRULE_interfaceDeclaration                                         = 104
	Java9ParserRULE_normalInterfaceDeclaration                                   = 105
	Java9ParserRULE_interfaceModifier                                            = 106
	Java9ParserRULE_extendsInterfaces                                            = 107
	Java9ParserRULE_interfaceBody                                                = 108
	Java9ParserRULE_interfaceMemberDeclaration                                   = 109
	Java9ParserRULE_constantDeclaration                                          = 110
	Java9ParserRULE_constantModifier                                             = 111
	Java9ParserRULE_interfaceMethodDeclaration                                   = 112
	Java9ParserRULE_interfaceMethodModifier                                      = 113
	Java9ParserRULE_annotationTypeDeclaration                                    = 114
	Java9ParserRULE_annotationTypeBody                                           = 115
	Java9ParserRULE_annotationTypeMemberDeclaration                              = 116
	Java9ParserRULE_annotationTypeElementDeclaration                             = 117
	Java9ParserRULE_annotationTypeElementModifier                                = 118
	Java9ParserRULE_defaultValue                                                 = 119
	Java9ParserRULE_annotation                                                   = 120
	Java9ParserRULE_normalAnnotation                                             = 121
	Java9ParserRULE_elementValuePairList                                         = 122
	Java9ParserRULE_elementValuePair                                             = 123
	Java9ParserRULE_elementValue                                                 = 124
	Java9ParserRULE_elementValueArrayInitializer                                 = 125
	Java9ParserRULE_elementValueList                                             = 126
	Java9ParserRULE_markerAnnotation                                             = 127
	Java9ParserRULE_singleElementAnnotation                                      = 128
	Java9ParserRULE_arrayInitializer                                             = 129
	Java9ParserRULE_variableInitializerList                                      = 130
	Java9ParserRULE_block                                                        = 131
	Java9ParserRULE_blockStatements                                              = 132
	Java9ParserRULE_blockStatement                                               = 133
	Java9ParserRULE_localVariableDeclarationStatement                            = 134
	Java9ParserRULE_localVariableDeclaration                                     = 135
	Java9ParserRULE_statement                                                    = 136
	Java9ParserRULE_statementNoShortIf                                           = 137
	Java9ParserRULE_statementWithoutTrailingSubstatement                         = 138
	Java9ParserRULE_emptyStatement_                                              = 139
	Java9ParserRULE_labeledStatement                                             = 140
	Java9ParserRULE_labeledStatementNoShortIf                                    = 141
	Java9ParserRULE_expressionStatement                                          = 142
	Java9ParserRULE_statementExpression                                          = 143
	Java9ParserRULE_ifThenStatement                                              = 144
	Java9ParserRULE_ifThenElseStatement                                          = 145
	Java9ParserRULE_ifThenElseStatementNoShortIf                                 = 146
	Java9ParserRULE_assertStatement                                              = 147
	Java9ParserRULE_switchStatement                                              = 148
	Java9ParserRULE_switchBlock                                                  = 149
	Java9ParserRULE_switchBlockStatementGroup                                    = 150
	Java9ParserRULE_switchLabels                                                 = 151
	Java9ParserRULE_switchLabel                                                  = 152
	Java9ParserRULE_enumConstantName                                             = 153
	Java9ParserRULE_whileStatement                                               = 154
	Java9ParserRULE_whileStatementNoShortIf                                      = 155
	Java9ParserRULE_doStatement                                                  = 156
	Java9ParserRULE_forStatement                                                 = 157
	Java9ParserRULE_forStatementNoShortIf                                        = 158
	Java9ParserRULE_basicForStatement                                            = 159
	Java9ParserRULE_basicForStatementNoShortIf                                   = 160
	Java9ParserRULE_forInit                                                      = 161
	Java9ParserRULE_forUpdate                                                    = 162
	Java9ParserRULE_statementExpressionList                                      = 163
	Java9ParserRULE_enhancedForStatement                                         = 164
	Java9ParserRULE_enhancedForStatementNoShortIf                                = 165
	Java9ParserRULE_breakStatement                                               = 166
	Java9ParserRULE_continueStatement                                            = 167
	Java9ParserRULE_returnStatement                                              = 168
	Java9ParserRULE_throwStatement                                               = 169
	Java9ParserRULE_synchronizedStatement                                        = 170
	Java9ParserRULE_tryStatement                                                 = 171
	Java9ParserRULE_catches                                                      = 172
	Java9ParserRULE_catchClause                                                  = 173
	Java9ParserRULE_catchFormalParameter                                         = 174
	Java9ParserRULE_catchType                                                    = 175
	Java9ParserRULE_finally_                                                     = 176
	Java9ParserRULE_tryWithResourcesStatement                                    = 177
	Java9ParserRULE_resourceSpecification                                        = 178
	Java9ParserRULE_resourceList                                                 = 179
	Java9ParserRULE_resource                                                     = 180
	Java9ParserRULE_variableAccess                                               = 181
	Java9ParserRULE_primary                                                      = 182
	Java9ParserRULE_primaryNoNewArray                                            = 183
	Java9ParserRULE_primaryNoNewArray_lf_arrayAccess                             = 184
	Java9ParserRULE_primaryNoNewArray_lfno_arrayAccess                           = 185
	Java9ParserRULE_primaryNoNewArray_lf_primary                                 = 186
	Java9ParserRULE_primaryNoNewArray_lf_primary_lf_arrayAccess_lf_primary       = 187
	Java9ParserRULE_primaryNoNewArray_lf_primary_lfno_arrayAccess_lf_primary     = 188
	Java9ParserRULE_primaryNoNewArray_lfno_primary                               = 189
	Java9ParserRULE_primaryNoNewArray_lfno_primary_lf_arrayAccess_lfno_primary   = 190
	Java9ParserRULE_primaryNoNewArray_lfno_primary_lfno_arrayAccess_lfno_primary = 191
	Java9ParserRULE_classLiteral                                                 = 192
	Java9ParserRULE_classInstanceCreationExpression                              = 193
	Java9ParserRULE_classInstanceCreationExpression_lf_primary                   = 194
	Java9ParserRULE_classInstanceCreationExpression_lfno_primary                 = 195
	Java9ParserRULE_typeArgumentsOrDiamond                                       = 196
	Java9ParserRULE_fieldAccess                                                  = 197
	Java9ParserRULE_fieldAccess_lf_primary                                       = 198
	Java9ParserRULE_fieldAccess_lfno_primary                                     = 199
	Java9ParserRULE_arrayAccess                                                  = 200
	Java9ParserRULE_arrayAccess_lf_primary                                       = 201
	Java9ParserRULE_arrayAccess_lfno_primary                                     = 202
	Java9ParserRULE_methodInvocation                                             = 203
	Java9ParserRULE_methodInvocation_lf_primary                                  = 204
	Java9ParserRULE_methodInvocation_lfno_primary                                = 205
	Java9ParserRULE_argumentList                                                 = 206
	Java9ParserRULE_methodReference                                              = 207
	Java9ParserRULE_methodReference_lf_primary                                   = 208
	Java9ParserRULE_methodReference_lfno_primary                                 = 209
	Java9ParserRULE_arrayCreationExpression                                      = 210
	Java9ParserRULE_dimExprs                                                     = 211
	Java9ParserRULE_dimExpr                                                      = 212
	Java9ParserRULE_constantExpression                                           = 213
	Java9ParserRULE_expression                                                   = 214
	Java9ParserRULE_lambdaExpression                                             = 215
	Java9ParserRULE_lambdaParameters                                             = 216
	Java9ParserRULE_inferredFormalParameterList                                  = 217
	Java9ParserRULE_lambdaBody                                                   = 218
	Java9ParserRULE_assignmentExpression                                         = 219
	Java9ParserRULE_assignment                                                   = 220
	Java9ParserRULE_leftHandSide                                                 = 221
	Java9ParserRULE_assignmentOperator                                           = 222
	Java9ParserRULE_conditionalExpression                                        = 223
	Java9ParserRULE_conditionalOrExpression                                      = 224
	Java9ParserRULE_conditionalAndExpression                                     = 225
	Java9ParserRULE_inclusiveOrExpression                                        = 226
	Java9ParserRULE_exclusiveOrExpression                                        = 227
	Java9ParserRULE_andExpression                                                = 228
	Java9ParserRULE_equalityExpression                                           = 229
	Java9ParserRULE_relationalExpression                                         = 230
	Java9ParserRULE_shiftExpression                                              = 231
	Java9ParserRULE_additiveExpression                                           = 232
	Java9ParserRULE_multiplicativeExpression                                     = 233
	Java9ParserRULE_unaryExpression                                              = 234
	Java9ParserRULE_preIncrementExpression                                       = 235
	Java9ParserRULE_preDecrementExpression                                       = 236
	Java9ParserRULE_unaryExpressionNotPlusMinus                                  = 237
	Java9ParserRULE_postfixExpression                                            = 238
	Java9ParserRULE_postIncrementExpression                                      = 239
	Java9ParserRULE_postIncrementExpression_lf_postfixExpression                 = 240
	Java9ParserRULE_postDecrementExpression                                      = 241
	Java9ParserRULE_postDecrementExpression_lf_postfixExpression                 = 242
	Java9ParserRULE_castExpression                                               = 243
	Java9ParserRULE_identifier                                                   = 244
)

// ILiteralContext is an interface to support dynamic dispatch.
type ILiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLiteralContext differentiates from other interfaces.
	IsLiteralContext()
}

type LiteralContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLiteralContext() *LiteralContext {
	var p = new(LiteralContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Java9ParserRULE_literal
	return p
}

func (*LiteralContext) IsLiteralContext() {}

func NewLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LiteralContext {
	var p = new(LiteralContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java9ParserRULE_literal

	return p
}

func (s *LiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *LiteralContext) IntegerLiteral() antlr.TerminalNode {
	return s.GetToken(Java9ParserIntegerLiteral, 0)
}

func (s *LiteralContext) FloatingPointLiteral() antlr.TerminalNode {
	return s.GetToken(Java9ParserFloatingPointLiteral, 0)
}

func (s *LiteralContext) BooleanLiteral() antlr.TerminalNode {
	return s.GetToken(Java9ParserBooleanLiteral, 0)
}

func (s *LiteralContext) CharacterLiteral() antlr.TerminalNode {
	return s.GetToken(Java9ParserCharacterLiteral, 0)
}

func (s *LiteralContext) StringLiteral() antlr.TerminalNode {
	return s.GetToken(Java9ParserStringLiteral, 0)
}

func (s *LiteralContext) NullLiteral() antlr.TerminalNode {
	return s.GetToken(Java9ParserNullLiteral, 0)
}

func (s *LiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.EnterLiteral(s)
	}
}

func (s *LiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.ExitLiteral(s)
	}
}

func (p *Java9Parser) Literal() (localctx ILiteralContext) {
	localctx = NewLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 0, Java9ParserRULE_literal)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(490)
		_la = p.GetTokenStream().LA(1)

		if !(((_la-62)&-(0x1f+1)) == 0 && ((1<<uint((_la-62)))&((1<<(Java9ParserIntegerLiteral-62))|(1<<(Java9ParserFloatingPointLiteral-62))|(1<<(Java9ParserBooleanLiteral-62))|(1<<(Java9ParserCharacterLiteral-62))|(1<<(Java9ParserStringLiteral-62))|(1<<(Java9ParserNullLiteral-62)))) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IPrimitiveTypeContext is an interface to support dynamic dispatch.
type IPrimitiveTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPrimitiveTypeContext differentiates from other interfaces.
	IsPrimitiveTypeContext()
}

type PrimitiveTypeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPrimitiveTypeContext() *PrimitiveTypeContext {
	var p = new(PrimitiveTypeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Java9ParserRULE_primitiveType
	return p
}

func (*PrimitiveTypeContext) IsPrimitiveTypeContext() {}

func NewPrimitiveTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PrimitiveTypeContext {
	var p = new(PrimitiveTypeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java9ParserRULE_primitiveType

	return p
}

func (s *PrimitiveTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *PrimitiveTypeContext) NumericType() INumericTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INumericTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INumericTypeContext)
}

func (s *PrimitiveTypeContext) AllAnnotation() []IAnnotationContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAnnotationContext)(nil)).Elem())
	var tst = make([]IAnnotationContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAnnotationContext)
		}
	}

	return tst
}

func (s *PrimitiveTypeContext) Annotation(i int) IAnnotationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAnnotationContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAnnotationContext)
}

func (s *PrimitiveTypeContext) BOOLEAN() antlr.TerminalNode {
	return s.GetToken(Java9ParserBOOLEAN, 0)
}

func (s *PrimitiveTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PrimitiveTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PrimitiveTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.EnterPrimitiveType(s)
	}
}

func (s *PrimitiveTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.ExitPrimitiveType(s)
	}
}

func (p *Java9Parser) PrimitiveType() (localctx IPrimitiveTypeContext) {
	localctx = NewPrimitiveTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 2, Java9ParserRULE_primitiveType)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(506)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 2, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(495)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == Java9ParserAT {
			{
				p.SetState(492)
				p.Annotation()
			}

			p.SetState(497)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(498)
			p.NumericType()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		p.SetState(502)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == Java9ParserAT {
			{
				p.SetState(499)
				p.Annotation()
			}

			p.SetState(504)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(505)
			p.Match(Java9ParserBOOLEAN)
		}

	}

	return localctx
}

// INumericTypeContext is an interface to support dynamic dispatch.
type INumericTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsNumericTypeContext differentiates from other interfaces.
	IsNumericTypeContext()
}

type NumericTypeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNumericTypeContext() *NumericTypeContext {
	var p = new(NumericTypeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Java9ParserRULE_numericType
	return p
}

func (*NumericTypeContext) IsNumericTypeContext() {}

func NewNumericTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NumericTypeContext {
	var p = new(NumericTypeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java9ParserRULE_numericType

	return p
}

func (s *NumericTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *NumericTypeContext) IntegralType() IIntegralTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIntegralTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIntegralTypeContext)
}

func (s *NumericTypeContext) FloatingPointType() IFloatingPointTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFloatingPointTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFloatingPointTypeContext)
}

func (s *NumericTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NumericTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NumericTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.EnterNumericType(s)
	}
}

func (s *NumericTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.ExitNumericType(s)
	}
}

func (p *Java9Parser) NumericType() (localctx INumericTypeContext) {
	localctx = NewNumericTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 4, Java9ParserRULE_numericType)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(510)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case Java9ParserBYTE, Java9ParserCHAR, Java9ParserINT, Java9ParserLONG, Java9ParserSHORT:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(508)
			p.IntegralType()
		}

	case Java9ParserDOUBLE, Java9ParserFLOAT:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(509)
			p.FloatingPointType()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IIntegralTypeContext is an interface to support dynamic dispatch.
type IIntegralTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsIntegralTypeContext differentiates from other interfaces.
	IsIntegralTypeContext()
}

type IntegralTypeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIntegralTypeContext() *IntegralTypeContext {
	var p = new(IntegralTypeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Java9ParserRULE_integralType
	return p
}

func (*IntegralTypeContext) IsIntegralTypeContext() {}

func NewIntegralTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IntegralTypeContext {
	var p = new(IntegralTypeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java9ParserRULE_integralType

	return p
}

func (s *IntegralTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *IntegralTypeContext) BYTE() antlr.TerminalNode {
	return s.GetToken(Java9ParserBYTE, 0)
}

func (s *IntegralTypeContext) SHORT() antlr.TerminalNode {
	return s.GetToken(Java9ParserSHORT, 0)
}

func (s *IntegralTypeContext) INT() antlr.TerminalNode {
	return s.GetToken(Java9ParserINT, 0)
}

func (s *IntegralTypeContext) LONG() antlr.TerminalNode {
	return s.GetToken(Java9ParserLONG, 0)
}

func (s *IntegralTypeContext) CHAR() antlr.TerminalNode {
	return s.GetToken(Java9ParserCHAR, 0)
}

func (s *IntegralTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IntegralTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IntegralTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.EnterIntegralType(s)
	}
}

func (s *IntegralTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.ExitIntegralType(s)
	}
}

func (p *Java9Parser) IntegralType() (localctx IIntegralTypeContext) {
	localctx = NewIntegralTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 6, Java9ParserRULE_integralType)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(512)
		_la = p.GetTokenStream().LA(1)

		if !((((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<Java9ParserBYTE)|(1<<Java9ParserCHAR)|(1<<Java9ParserINT)|(1<<Java9ParserLONG))) != 0) || _la == Java9ParserSHORT) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IFloatingPointTypeContext is an interface to support dynamic dispatch.
type IFloatingPointTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFloatingPointTypeContext differentiates from other interfaces.
	IsFloatingPointTypeContext()
}

type FloatingPointTypeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFloatingPointTypeContext() *FloatingPointTypeContext {
	var p = new(FloatingPointTypeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Java9ParserRULE_floatingPointType
	return p
}

func (*FloatingPointTypeContext) IsFloatingPointTypeContext() {}

func NewFloatingPointTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FloatingPointTypeContext {
	var p = new(FloatingPointTypeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java9ParserRULE_floatingPointType

	return p
}

func (s *FloatingPointTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *FloatingPointTypeContext) FLOAT() antlr.TerminalNode {
	return s.GetToken(Java9ParserFLOAT, 0)
}

func (s *FloatingPointTypeContext) DOUBLE() antlr.TerminalNode {
	return s.GetToken(Java9ParserDOUBLE, 0)
}

func (s *FloatingPointTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FloatingPointTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FloatingPointTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.EnterFloatingPointType(s)
	}
}

func (s *FloatingPointTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.ExitFloatingPointType(s)
	}
}

func (p *Java9Parser) FloatingPointType() (localctx IFloatingPointTypeContext) {
	localctx = NewFloatingPointTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 8, Java9ParserRULE_floatingPointType)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(514)
		_la = p.GetTokenStream().LA(1)

		if !(_la == Java9ParserDOUBLE || _la == Java9ParserFLOAT) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IReferenceTypeContext is an interface to support dynamic dispatch.
type IReferenceTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsReferenceTypeContext differentiates from other interfaces.
	IsReferenceTypeContext()
}

type ReferenceTypeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReferenceTypeContext() *ReferenceTypeContext {
	var p = new(ReferenceTypeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Java9ParserRULE_referenceType
	return p
}

func (*ReferenceTypeContext) IsReferenceTypeContext() {}

func NewReferenceTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReferenceTypeContext {
	var p = new(ReferenceTypeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java9ParserRULE_referenceType

	return p
}

func (s *ReferenceTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *ReferenceTypeContext) ClassOrInterfaceType() IClassOrInterfaceTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IClassOrInterfaceTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IClassOrInterfaceTypeContext)
}

func (s *ReferenceTypeContext) TypeVariable() ITypeVariableContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypeVariableContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITypeVariableContext)
}

func (s *ReferenceTypeContext) ArrayType() IArrayTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IArrayTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IArrayTypeContext)
}

func (s *ReferenceTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReferenceTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReferenceTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.EnterReferenceType(s)
	}
}

func (s *ReferenceTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.ExitReferenceType(s)
	}
}

func (p *Java9Parser) ReferenceType() (localctx IReferenceTypeContext) {
	localctx = NewReferenceTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 10, Java9ParserRULE_referenceType)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(519)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 4, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(516)
			p.ClassOrInterfaceType()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(517)
			p.TypeVariable()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(518)
			p.ArrayType()
		}

	}

	return localctx
}

// IClassOrInterfaceTypeContext is an interface to support dynamic dispatch.
type IClassOrInterfaceTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsClassOrInterfaceTypeContext differentiates from other interfaces.
	IsClassOrInterfaceTypeContext()
}

type ClassOrInterfaceTypeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyClassOrInterfaceTypeContext() *ClassOrInterfaceTypeContext {
	var p = new(ClassOrInterfaceTypeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Java9ParserRULE_classOrInterfaceType
	return p
}

func (*ClassOrInterfaceTypeContext) IsClassOrInterfaceTypeContext() {}

func NewClassOrInterfaceTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ClassOrInterfaceTypeContext {
	var p = new(ClassOrInterfaceTypeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java9ParserRULE_classOrInterfaceType

	return p
}

func (s *ClassOrInterfaceTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *ClassOrInterfaceTypeContext) ClassType_lfno_classOrInterfaceType() IClassType_lfno_classOrInterfaceTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IClassType_lfno_classOrInterfaceTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IClassType_lfno_classOrInterfaceTypeContext)
}

func (s *ClassOrInterfaceTypeContext) InterfaceType_lfno_classOrInterfaceType() IInterfaceType_lfno_classOrInterfaceTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInterfaceType_lfno_classOrInterfaceTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInterfaceType_lfno_classOrInterfaceTypeContext)
}

func (s *ClassOrInterfaceTypeContext) AllClassType_lf_classOrInterfaceType() []IClassType_lf_classOrInterfaceTypeContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IClassType_lf_classOrInterfaceTypeContext)(nil)).Elem())
	var tst = make([]IClassType_lf_classOrInterfaceTypeContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IClassType_lf_classOrInterfaceTypeContext)
		}
	}

	return tst
}

func (s *ClassOrInterfaceTypeContext) ClassType_lf_classOrInterfaceType(i int) IClassType_lf_classOrInterfaceTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IClassType_lf_classOrInterfaceTypeContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IClassType_lf_classOrInterfaceTypeContext)
}

func (s *ClassOrInterfaceTypeContext) AllInterfaceType_lf_classOrInterfaceType() []IInterfaceType_lf_classOrInterfaceTypeContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IInterfaceType_lf_classOrInterfaceTypeContext)(nil)).Elem())
	var tst = make([]IInterfaceType_lf_classOrInterfaceTypeContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IInterfaceType_lf_classOrInterfaceTypeContext)
		}
	}

	return tst
}

func (s *ClassOrInterfaceTypeContext) InterfaceType_lf_classOrInterfaceType(i int) IInterfaceType_lf_classOrInterfaceTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInterfaceType_lf_classOrInterfaceTypeContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IInterfaceType_lf_classOrInterfaceTypeContext)
}

func (s *ClassOrInterfaceTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ClassOrInterfaceTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ClassOrInterfaceTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.EnterClassOrInterfaceType(s)
	}
}

func (s *ClassOrInterfaceTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.ExitClassOrInterfaceType(s)
	}
}

func (p *Java9Parser) ClassOrInterfaceType() (localctx IClassOrInterfaceTypeContext) {
	localctx = NewClassOrInterfaceTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 12, Java9ParserRULE_classOrInterfaceType)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(523)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 5, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(521)
			p.ClassType_lfno_classOrInterfaceType()
		}

	case 2:
		{
			p.SetState(522)
			p.InterfaceType_lfno_classOrInterfaceType()
		}

	}
	p.SetState(529)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 7, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			p.SetState(527)
			p.GetErrorHandler().Sync(p)
			switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 6, p.GetParserRuleContext()) {
			case 1:
				{
					p.SetState(525)
					p.ClassType_lf_classOrInterfaceType()
				}

			case 2:
				{
					p.SetState(526)
					p.InterfaceType_lf_classOrInterfaceType()
				}

			}

		}
		p.SetState(531)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 7, p.GetParserRuleContext())
	}

	return localctx
}

// IClassTypeContext is an interface to support dynamic dispatch.
type IClassTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsClassTypeContext differentiates from other interfaces.
	IsClassTypeContext()
}

type ClassTypeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyClassTypeContext() *ClassTypeContext {
	var p = new(ClassTypeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Java9ParserRULE_classType
	return p
}

func (*ClassTypeContext) IsClassTypeContext() {}

func NewClassTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ClassTypeContext {
	var p = new(ClassTypeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java9ParserRULE_classType

	return p
}

func (s *ClassTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *ClassTypeContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ClassTypeContext) AllAnnotation() []IAnnotationContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAnnotationContext)(nil)).Elem())
	var tst = make([]IAnnotationContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAnnotationContext)
		}
	}

	return tst
}

func (s *ClassTypeContext) Annotation(i int) IAnnotationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAnnotationContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAnnotationContext)
}

func (s *ClassTypeContext) TypeArguments() ITypeArgumentsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypeArgumentsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITypeArgumentsContext)
}

func (s *ClassTypeContext) ClassOrInterfaceType() IClassOrInterfaceTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IClassOrInterfaceTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IClassOrInterfaceTypeContext)
}

func (s *ClassTypeContext) DOT() antlr.TerminalNode {
	return s.GetToken(Java9ParserDOT, 0)
}

func (s *ClassTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ClassTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ClassTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.EnterClassType(s)
	}
}

func (s *ClassTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.ExitClassType(s)
	}
}

func (p *Java9Parser) ClassType() (localctx IClassTypeContext) {
	localctx = NewClassTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 14, Java9ParserRULE_classType)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(554)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 12, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(535)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == Java9ParserAT {
			{
				p.SetState(532)
				p.Annotation()
			}

			p.SetState(537)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(538)
			p.Identifier()
		}
		p.SetState(540)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == Java9ParserLT {
			{
				p.SetState(539)
				p.TypeArguments()
			}

		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(542)
			p.ClassOrInterfaceType()
		}
		{
			p.SetState(543)
			p.Match(Java9ParserDOT)
		}
		p.SetState(547)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == Java9ParserAT {
			{
				p.SetState(544)
				p.Annotation()
			}

			p.SetState(549)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(550)
			p.Identifier()
		}
		p.SetState(552)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == Java9ParserLT {
			{
				p.SetState(551)
				p.TypeArguments()
			}

		}

	}

	return localctx
}

// IClassType_lf_classOrInterfaceTypeContext is an interface to support dynamic dispatch.
type IClassType_lf_classOrInterfaceTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsClassType_lf_classOrInterfaceTypeContext differentiates from other interfaces.
	IsClassType_lf_classOrInterfaceTypeContext()
}

type ClassType_lf_classOrInterfaceTypeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyClassType_lf_classOrInterfaceTypeContext() *ClassType_lf_classOrInterfaceTypeContext {
	var p = new(ClassType_lf_classOrInterfaceTypeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Java9ParserRULE_classType_lf_classOrInterfaceType
	return p
}

func (*ClassType_lf_classOrInterfaceTypeContext) IsClassType_lf_classOrInterfaceTypeContext() {}

func NewClassType_lf_classOrInterfaceTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ClassType_lf_classOrInterfaceTypeContext {
	var p = new(ClassType_lf_classOrInterfaceTypeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java9ParserRULE_classType_lf_classOrInterfaceType

	return p
}

func (s *ClassType_lf_classOrInterfaceTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *ClassType_lf_classOrInterfaceTypeContext) DOT() antlr.TerminalNode {
	return s.GetToken(Java9ParserDOT, 0)
}

func (s *ClassType_lf_classOrInterfaceTypeContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ClassType_lf_classOrInterfaceTypeContext) AllAnnotation() []IAnnotationContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAnnotationContext)(nil)).Elem())
	var tst = make([]IAnnotationContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAnnotationContext)
		}
	}

	return tst
}

func (s *ClassType_lf_classOrInterfaceTypeContext) Annotation(i int) IAnnotationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAnnotationContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAnnotationContext)
}

func (s *ClassType_lf_classOrInterfaceTypeContext) TypeArguments() ITypeArgumentsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypeArgumentsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITypeArgumentsContext)
}

func (s *ClassType_lf_classOrInterfaceTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ClassType_lf_classOrInterfaceTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ClassType_lf_classOrInterfaceTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.EnterClassType_lf_classOrInterfaceType(s)
	}
}

func (s *ClassType_lf_classOrInterfaceTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.ExitClassType_lf_classOrInterfaceType(s)
	}
}

func (p *Java9Parser) ClassType_lf_classOrInterfaceType() (localctx IClassType_lf_classOrInterfaceTypeContext) {
	localctx = NewClassType_lf_classOrInterfaceTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 16, Java9ParserRULE_classType_lf_classOrInterfaceType)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(556)
		p.Match(Java9ParserDOT)
	}
	p.SetState(560)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == Java9ParserAT {
		{
			p.SetState(557)
			p.Annotation()
		}

		p.SetState(562)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(563)
		p.Identifier()
	}
	p.SetState(565)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 14, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(564)
			p.TypeArguments()
		}

	}

	return localctx
}

// IClassType_lfno_classOrInterfaceTypeContext is an interface to support dynamic dispatch.
type IClassType_lfno_classOrInterfaceTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsClassType_lfno_classOrInterfaceTypeContext differentiates from other interfaces.
	IsClassType_lfno_classOrInterfaceTypeContext()
}

type ClassType_lfno_classOrInterfaceTypeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyClassType_lfno_classOrInterfaceTypeContext() *ClassType_lfno_classOrInterfaceTypeContext {
	var p = new(ClassType_lfno_classOrInterfaceTypeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Java9ParserRULE_classType_lfno_classOrInterfaceType
	return p
}

func (*ClassType_lfno_classOrInterfaceTypeContext) IsClassType_lfno_classOrInterfaceTypeContext() {}

func NewClassType_lfno_classOrInterfaceTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ClassType_lfno_classOrInterfaceTypeContext {
	var p = new(ClassType_lfno_classOrInterfaceTypeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java9ParserRULE_classType_lfno_classOrInterfaceType

	return p
}

func (s *ClassType_lfno_classOrInterfaceTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *ClassType_lfno_classOrInterfaceTypeContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ClassType_lfno_classOrInterfaceTypeContext) AllAnnotation() []IAnnotationContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAnnotationContext)(nil)).Elem())
	var tst = make([]IAnnotationContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAnnotationContext)
		}
	}

	return tst
}

func (s *ClassType_lfno_classOrInterfaceTypeContext) Annotation(i int) IAnnotationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAnnotationContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAnnotationContext)
}

func (s *ClassType_lfno_classOrInterfaceTypeContext) TypeArguments() ITypeArgumentsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypeArgumentsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITypeArgumentsContext)
}

func (s *ClassType_lfno_classOrInterfaceTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ClassType_lfno_classOrInterfaceTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ClassType_lfno_classOrInterfaceTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.EnterClassType_lfno_classOrInterfaceType(s)
	}
}

func (s *ClassType_lfno_classOrInterfaceTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.ExitClassType_lfno_classOrInterfaceType(s)
	}
}

func (p *Java9Parser) ClassType_lfno_classOrInterfaceType() (localctx IClassType_lfno_classOrInterfaceTypeContext) {
	localctx = NewClassType_lfno_classOrInterfaceTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 18, Java9ParserRULE_classType_lfno_classOrInterfaceType)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(570)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == Java9ParserAT {
		{
			p.SetState(567)
			p.Annotation()
		}

		p.SetState(572)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(573)
		p.Identifier()
	}
	p.SetState(575)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 16, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(574)
			p.TypeArguments()
		}

	}

	return localctx
}

// IInterfaceTypeContext is an interface to support dynamic dispatch.
type IInterfaceTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsInterfaceTypeContext differentiates from other interfaces.
	IsInterfaceTypeContext()
}

type InterfaceTypeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInterfaceTypeContext() *InterfaceTypeContext {
	var p = new(InterfaceTypeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Java9ParserRULE_interfaceType
	return p
}

func (*InterfaceTypeContext) IsInterfaceTypeContext() {}

func NewInterfaceTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InterfaceTypeContext {
	var p = new(InterfaceTypeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java9ParserRULE_interfaceType

	return p
}

func (s *InterfaceTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *InterfaceTypeContext) ClassType() IClassTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IClassTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IClassTypeContext)
}

func (s *InterfaceTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InterfaceTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InterfaceTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.EnterInterfaceType(s)
	}
}

func (s *InterfaceTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.ExitInterfaceType(s)
	}
}

func (p *Java9Parser) InterfaceType() (localctx IInterfaceTypeContext) {
	localctx = NewInterfaceTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 20, Java9ParserRULE_interfaceType)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(577)
		p.ClassType()
	}

	return localctx
}

// IInterfaceType_lf_classOrInterfaceTypeContext is an interface to support dynamic dispatch.
type IInterfaceType_lf_classOrInterfaceTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsInterfaceType_lf_classOrInterfaceTypeContext differentiates from other interfaces.
	IsInterfaceType_lf_classOrInterfaceTypeContext()
}

type InterfaceType_lf_classOrInterfaceTypeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInterfaceType_lf_classOrInterfaceTypeContext() *InterfaceType_lf_classOrInterfaceTypeContext {
	var p = new(InterfaceType_lf_classOrInterfaceTypeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Java9ParserRULE_interfaceType_lf_classOrInterfaceType
	return p
}

func (*InterfaceType_lf_classOrInterfaceTypeContext) IsInterfaceType_lf_classOrInterfaceTypeContext() {
}

func NewInterfaceType_lf_classOrInterfaceTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InterfaceType_lf_classOrInterfaceTypeContext {
	var p = new(InterfaceType_lf_classOrInterfaceTypeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java9ParserRULE_interfaceType_lf_classOrInterfaceType

	return p
}

func (s *InterfaceType_lf_classOrInterfaceTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *InterfaceType_lf_classOrInterfaceTypeContext) ClassType_lf_classOrInterfaceType() IClassType_lf_classOrInterfaceTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IClassType_lf_classOrInterfaceTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IClassType_lf_classOrInterfaceTypeContext)
}

func (s *InterfaceType_lf_classOrInterfaceTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InterfaceType_lf_classOrInterfaceTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InterfaceType_lf_classOrInterfaceTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.EnterInterfaceType_lf_classOrInterfaceType(s)
	}
}

func (s *InterfaceType_lf_classOrInterfaceTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.ExitInterfaceType_lf_classOrInterfaceType(s)
	}
}

func (p *Java9Parser) InterfaceType_lf_classOrInterfaceType() (localctx IInterfaceType_lf_classOrInterfaceTypeContext) {
	localctx = NewInterfaceType_lf_classOrInterfaceTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 22, Java9ParserRULE_interfaceType_lf_classOrInterfaceType)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(579)
		p.ClassType_lf_classOrInterfaceType()
	}

	return localctx
}

// IInterfaceType_lfno_classOrInterfaceTypeContext is an interface to support dynamic dispatch.
type IInterfaceType_lfno_classOrInterfaceTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsInterfaceType_lfno_classOrInterfaceTypeContext differentiates from other interfaces.
	IsInterfaceType_lfno_classOrInterfaceTypeContext()
}

type InterfaceType_lfno_classOrInterfaceTypeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInterfaceType_lfno_classOrInterfaceTypeContext() *InterfaceType_lfno_classOrInterfaceTypeContext {
	var p = new(InterfaceType_lfno_classOrInterfaceTypeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Java9ParserRULE_interfaceType_lfno_classOrInterfaceType
	return p
}

func (*InterfaceType_lfno_classOrInterfaceTypeContext) IsInterfaceType_lfno_classOrInterfaceTypeContext() {
}

func NewInterfaceType_lfno_classOrInterfaceTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InterfaceType_lfno_classOrInterfaceTypeContext {
	var p = new(InterfaceType_lfno_classOrInterfaceTypeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java9ParserRULE_interfaceType_lfno_classOrInterfaceType

	return p
}

func (s *InterfaceType_lfno_classOrInterfaceTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *InterfaceType_lfno_classOrInterfaceTypeContext) ClassType_lfno_classOrInterfaceType() IClassType_lfno_classOrInterfaceTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IClassType_lfno_classOrInterfaceTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IClassType_lfno_classOrInterfaceTypeContext)
}

func (s *InterfaceType_lfno_classOrInterfaceTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InterfaceType_lfno_classOrInterfaceTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InterfaceType_lfno_classOrInterfaceTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.EnterInterfaceType_lfno_classOrInterfaceType(s)
	}
}

func (s *InterfaceType_lfno_classOrInterfaceTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.ExitInterfaceType_lfno_classOrInterfaceType(s)
	}
}

func (p *Java9Parser) InterfaceType_lfno_classOrInterfaceType() (localctx IInterfaceType_lfno_classOrInterfaceTypeContext) {
	localctx = NewInterfaceType_lfno_classOrInterfaceTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 24, Java9ParserRULE_interfaceType_lfno_classOrInterfaceType)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(581)
		p.ClassType_lfno_classOrInterfaceType()
	}

	return localctx
}

// ITypeVariableContext is an interface to support dynamic dispatch.
type ITypeVariableContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTypeVariableContext differentiates from other interfaces.
	IsTypeVariableContext()
}

type TypeVariableContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeVariableContext() *TypeVariableContext {
	var p = new(TypeVariableContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Java9ParserRULE_typeVariable
	return p
}

func (*TypeVariableContext) IsTypeVariableContext() {}

func NewTypeVariableContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeVariableContext {
	var p = new(TypeVariableContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java9ParserRULE_typeVariable

	return p
}

func (s *TypeVariableContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeVariableContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *TypeVariableContext) AllAnnotation() []IAnnotationContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAnnotationContext)(nil)).Elem())
	var tst = make([]IAnnotationContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAnnotationContext)
		}
	}

	return tst
}

func (s *TypeVariableContext) Annotation(i int) IAnnotationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAnnotationContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAnnotationContext)
}

func (s *TypeVariableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeVariableContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeVariableContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.EnterTypeVariable(s)
	}
}

func (s *TypeVariableContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.ExitTypeVariable(s)
	}
}

func (p *Java9Parser) TypeVariable() (localctx ITypeVariableContext) {
	localctx = NewTypeVariableContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 26, Java9ParserRULE_typeVariable)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(586)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == Java9ParserAT {
		{
			p.SetState(583)
			p.Annotation()
		}

		p.SetState(588)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(589)
		p.Identifier()
	}

	return localctx
}

// IArrayTypeContext is an interface to support dynamic dispatch.
type IArrayTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsArrayTypeContext differentiates from other interfaces.
	IsArrayTypeContext()
}

type ArrayTypeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyArrayTypeContext() *ArrayTypeContext {
	var p = new(ArrayTypeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Java9ParserRULE_arrayType
	return p
}

func (*ArrayTypeContext) IsArrayTypeContext() {}

func NewArrayTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ArrayTypeContext {
	var p = new(ArrayTypeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java9ParserRULE_arrayType

	return p
}

func (s *ArrayTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *ArrayTypeContext) PrimitiveType() IPrimitiveTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPrimitiveTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPrimitiveTypeContext)
}

func (s *ArrayTypeContext) Dims() IDimsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDimsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDimsContext)
}

func (s *ArrayTypeContext) ClassOrInterfaceType() IClassOrInterfaceTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IClassOrInterfaceTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IClassOrInterfaceTypeContext)
}

func (s *ArrayTypeContext) TypeVariable() ITypeVariableContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypeVariableContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITypeVariableContext)
}

func (s *ArrayTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArrayTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ArrayTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.EnterArrayType(s)
	}
}

func (s *ArrayTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.ExitArrayType(s)
	}
}

func (p *Java9Parser) ArrayType() (localctx IArrayTypeContext) {
	localctx = NewArrayTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 28, Java9ParserRULE_arrayType)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(600)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 18, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(591)
			p.PrimitiveType()
		}
		{
			p.SetState(592)
			p.Dims()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(594)
			p.ClassOrInterfaceType()
		}
		{
			p.SetState(595)
			p.Dims()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(597)
			p.TypeVariable()
		}
		{
			p.SetState(598)
			p.Dims()
		}

	}

	return localctx
}

// IDimsContext is an interface to support dynamic dispatch.
type IDimsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDimsContext differentiates from other interfaces.
	IsDimsContext()
}

type DimsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDimsContext() *DimsContext {
	var p = new(DimsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Java9ParserRULE_dims
	return p
}

func (*DimsContext) IsDimsContext() {}

func NewDimsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DimsContext {
	var p = new(DimsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java9ParserRULE_dims

	return p
}

func (s *DimsContext) GetParser() antlr.Parser { return s.parser }

func (s *DimsContext) AllLBRACK() []antlr.TerminalNode {
	return s.GetTokens(Java9ParserLBRACK)
}

func (s *DimsContext) LBRACK(i int) antlr.TerminalNode {
	return s.GetToken(Java9ParserLBRACK, i)
}

func (s *DimsContext) AllRBRACK() []antlr.TerminalNode {
	return s.GetTokens(Java9ParserRBRACK)
}

func (s *DimsContext) RBRACK(i int) antlr.TerminalNode {
	return s.GetToken(Java9ParserRBRACK, i)
}

func (s *DimsContext) AllAnnotation() []IAnnotationContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAnnotationContext)(nil)).Elem())
	var tst = make([]IAnnotationContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAnnotationContext)
		}
	}

	return tst
}

func (s *DimsContext) Annotation(i int) IAnnotationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAnnotationContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAnnotationContext)
}

func (s *DimsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DimsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DimsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.EnterDims(s)
	}
}

func (s *DimsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.ExitDims(s)
	}
}

func (p *Java9Parser) Dims() (localctx IDimsContext) {
	localctx = NewDimsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 30, Java9ParserRULE_dims)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(605)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == Java9ParserAT {
		{
			p.SetState(602)
			p.Annotation()
		}

		p.SetState(607)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(608)
		p.Match(Java9ParserLBRACK)
	}
	{
		p.SetState(609)
		p.Match(Java9ParserRBRACK)
	}
	p.SetState(620)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 21, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			p.SetState(613)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			for _la == Java9ParserAT {
				{
					p.SetState(610)
					p.Annotation()
				}

				p.SetState(615)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)
			}
			{
				p.SetState(616)
				p.Match(Java9ParserLBRACK)
			}
			{
				p.SetState(617)
				p.Match(Java9ParserRBRACK)
			}

		}
		p.SetState(622)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 21, p.GetParserRuleContext())
	}

	return localctx
}

// ITypeParameterContext is an interface to support dynamic dispatch.
type ITypeParameterContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTypeParameterContext differentiates from other interfaces.
	IsTypeParameterContext()
}

type TypeParameterContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeParameterContext() *TypeParameterContext {
	var p = new(TypeParameterContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Java9ParserRULE_typeParameter
	return p
}

func (*TypeParameterContext) IsTypeParameterContext() {}

func NewTypeParameterContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeParameterContext {
	var p = new(TypeParameterContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java9ParserRULE_typeParameter

	return p
}

func (s *TypeParameterContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeParameterContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *TypeParameterContext) AllTypeParameterModifier() []ITypeParameterModifierContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ITypeParameterModifierContext)(nil)).Elem())
	var tst = make([]ITypeParameterModifierContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ITypeParameterModifierContext)
		}
	}

	return tst
}

func (s *TypeParameterContext) TypeParameterModifier(i int) ITypeParameterModifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypeParameterModifierContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ITypeParameterModifierContext)
}

func (s *TypeParameterContext) TypeBound() ITypeBoundContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypeBoundContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITypeBoundContext)
}

func (s *TypeParameterContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeParameterContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeParameterContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.EnterTypeParameter(s)
	}
}

func (s *TypeParameterContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.ExitTypeParameter(s)
	}
}

func (p *Java9Parser) TypeParameter() (localctx ITypeParameterContext) {
	localctx = NewTypeParameterContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 32, Java9ParserRULE_typeParameter)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(626)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == Java9ParserAT {
		{
			p.SetState(623)
			p.TypeParameterModifier()
		}

		p.SetState(628)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(629)
		p.Identifier()
	}
	p.SetState(631)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Java9ParserEXTENDS {
		{
			p.SetState(630)
			p.TypeBound()
		}

	}

	return localctx
}

// ITypeParameterModifierContext is an interface to support dynamic dispatch.
type ITypeParameterModifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTypeParameterModifierContext differentiates from other interfaces.
	IsTypeParameterModifierContext()
}

type TypeParameterModifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeParameterModifierContext() *TypeParameterModifierContext {
	var p = new(TypeParameterModifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Java9ParserRULE_typeParameterModifier
	return p
}

func (*TypeParameterModifierContext) IsTypeParameterModifierContext() {}

func NewTypeParameterModifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeParameterModifierContext {
	var p = new(TypeParameterModifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java9ParserRULE_typeParameterModifier

	return p
}

func (s *TypeParameterModifierContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeParameterModifierContext) Annotation() IAnnotationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAnnotationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAnnotationContext)
}

func (s *TypeParameterModifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeParameterModifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeParameterModifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.EnterTypeParameterModifier(s)
	}
}

func (s *TypeParameterModifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.ExitTypeParameterModifier(s)
	}
}

func (p *Java9Parser) TypeParameterModifier() (localctx ITypeParameterModifierContext) {
	localctx = NewTypeParameterModifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 34, Java9ParserRULE_typeParameterModifier)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(633)
		p.Annotation()
	}

	return localctx
}

// ITypeBoundContext is an interface to support dynamic dispatch.
type ITypeBoundContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTypeBoundContext differentiates from other interfaces.
	IsTypeBoundContext()
}

type TypeBoundContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeBoundContext() *TypeBoundContext {
	var p = new(TypeBoundContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Java9ParserRULE_typeBound
	return p
}

func (*TypeBoundContext) IsTypeBoundContext() {}

func NewTypeBoundContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeBoundContext {
	var p = new(TypeBoundContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java9ParserRULE_typeBound

	return p
}

func (s *TypeBoundContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeBoundContext) EXTENDS() antlr.TerminalNode {
	return s.GetToken(Java9ParserEXTENDS, 0)
}

func (s *TypeBoundContext) TypeVariable() ITypeVariableContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypeVariableContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITypeVariableContext)
}

func (s *TypeBoundContext) ClassOrInterfaceType() IClassOrInterfaceTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IClassOrInterfaceTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IClassOrInterfaceTypeContext)
}

func (s *TypeBoundContext) AllAdditionalBound() []IAdditionalBoundContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAdditionalBoundContext)(nil)).Elem())
	var tst = make([]IAdditionalBoundContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAdditionalBoundContext)
		}
	}

	return tst
}

func (s *TypeBoundContext) AdditionalBound(i int) IAdditionalBoundContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAdditionalBoundContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAdditionalBoundContext)
}

func (s *TypeBoundContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeBoundContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeBoundContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.EnterTypeBound(s)
	}
}

func (s *TypeBoundContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.ExitTypeBound(s)
	}
}

func (p *Java9Parser) TypeBound() (localctx ITypeBoundContext) {
	localctx = NewTypeBoundContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 36, Java9ParserRULE_typeBound)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(645)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 25, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(635)
			p.Match(Java9ParserEXTENDS)
		}
		{
			p.SetState(636)
			p.TypeVariable()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(637)
			p.Match(Java9ParserEXTENDS)
		}
		{
			p.SetState(638)
			p.ClassOrInterfaceType()
		}
		p.SetState(642)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == Java9ParserBITAND {
			{
				p.SetState(639)
				p.AdditionalBound()
			}

			p.SetState(644)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	}

	return localctx
}

// IAdditionalBoundContext is an interface to support dynamic dispatch.
type IAdditionalBoundContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAdditionalBoundContext differentiates from other interfaces.
	IsAdditionalBoundContext()
}

type AdditionalBoundContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAdditionalBoundContext() *AdditionalBoundContext {
	var p = new(AdditionalBoundContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Java9ParserRULE_additionalBound
	return p
}

func (*AdditionalBoundContext) IsAdditionalBoundContext() {}

func NewAdditionalBoundContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AdditionalBoundContext {
	var p = new(AdditionalBoundContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java9ParserRULE_additionalBound

	return p
}

func (s *AdditionalBoundContext) GetParser() antlr.Parser { return s.parser }

func (s *AdditionalBoundContext) BITAND() antlr.TerminalNode {
	return s.GetToken(Java9ParserBITAND, 0)
}

func (s *AdditionalBoundContext) InterfaceType() IInterfaceTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInterfaceTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInterfaceTypeContext)
}

func (s *AdditionalBoundContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AdditionalBoundContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AdditionalBoundContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.EnterAdditionalBound(s)
	}
}

func (s *AdditionalBoundContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.ExitAdditionalBound(s)
	}
}

func (p *Java9Parser) AdditionalBound() (localctx IAdditionalBoundContext) {
	localctx = NewAdditionalBoundContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 38, Java9ParserRULE_additionalBound)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(647)
		p.Match(Java9ParserBITAND)
	}
	{
		p.SetState(648)
		p.InterfaceType()
	}

	return localctx
}

// ITypeArgumentsContext is an interface to support dynamic dispatch.
type ITypeArgumentsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTypeArgumentsContext differentiates from other interfaces.
	IsTypeArgumentsContext()
}

type TypeArgumentsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeArgumentsContext() *TypeArgumentsContext {
	var p = new(TypeArgumentsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Java9ParserRULE_typeArguments
	return p
}

func (*TypeArgumentsContext) IsTypeArgumentsContext() {}

func NewTypeArgumentsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeArgumentsContext {
	var p = new(TypeArgumentsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java9ParserRULE_typeArguments

	return p
}

func (s *TypeArgumentsContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeArgumentsContext) LT() antlr.TerminalNode {
	return s.GetToken(Java9ParserLT, 0)
}

func (s *TypeArgumentsContext) TypeArgumentList() ITypeArgumentListContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypeArgumentListContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITypeArgumentListContext)
}

func (s *TypeArgumentsContext) GT() antlr.TerminalNode {
	return s.GetToken(Java9ParserGT, 0)
}

func (s *TypeArgumentsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeArgumentsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeArgumentsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.EnterTypeArguments(s)
	}
}

func (s *TypeArgumentsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.ExitTypeArguments(s)
	}
}

func (p *Java9Parser) TypeArguments() (localctx ITypeArgumentsContext) {
	localctx = NewTypeArgumentsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 40, Java9ParserRULE_typeArguments)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(650)
		p.Match(Java9ParserLT)
	}
	{
		p.SetState(651)
		p.TypeArgumentList()
	}
	{
		p.SetState(652)
		p.Match(Java9ParserGT)
	}

	return localctx
}

// ITypeArgumentListContext is an interface to support dynamic dispatch.
type ITypeArgumentListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTypeArgumentListContext differentiates from other interfaces.
	IsTypeArgumentListContext()
}

type TypeArgumentListContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeArgumentListContext() *TypeArgumentListContext {
	var p = new(TypeArgumentListContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Java9ParserRULE_typeArgumentList
	return p
}

func (*TypeArgumentListContext) IsTypeArgumentListContext() {}

func NewTypeArgumentListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeArgumentListContext {
	var p = new(TypeArgumentListContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java9ParserRULE_typeArgumentList

	return p
}

func (s *TypeArgumentListContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeArgumentListContext) AllTypeArgument() []ITypeArgumentContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ITypeArgumentContext)(nil)).Elem())
	var tst = make([]ITypeArgumentContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ITypeArgumentContext)
		}
	}

	return tst
}

func (s *TypeArgumentListContext) TypeArgument(i int) ITypeArgumentContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypeArgumentContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ITypeArgumentContext)
}

func (s *TypeArgumentListContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(Java9ParserCOMMA)
}

func (s *TypeArgumentListContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(Java9ParserCOMMA, i)
}

func (s *TypeArgumentListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeArgumentListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeArgumentListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.EnterTypeArgumentList(s)
	}
}

func (s *TypeArgumentListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.ExitTypeArgumentList(s)
	}
}

func (p *Java9Parser) TypeArgumentList() (localctx ITypeArgumentListContext) {
	localctx = NewTypeArgumentListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 42, Java9ParserRULE_typeArgumentList)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(654)
		p.TypeArgument()
	}
	p.SetState(659)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == Java9ParserCOMMA {
		{
			p.SetState(655)
			p.Match(Java9ParserCOMMA)
		}
		{
			p.SetState(656)
			p.TypeArgument()
		}

		p.SetState(661)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// ITypeArgumentContext is an interface to support dynamic dispatch.
type ITypeArgumentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTypeArgumentContext differentiates from other interfaces.
	IsTypeArgumentContext()
}

type TypeArgumentContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeArgumentContext() *TypeArgumentContext {
	var p = new(TypeArgumentContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Java9ParserRULE_typeArgument
	return p
}

func (*TypeArgumentContext) IsTypeArgumentContext() {}

func NewTypeArgumentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeArgumentContext {
	var p = new(TypeArgumentContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java9ParserRULE_typeArgument

	return p
}

func (s *TypeArgumentContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeArgumentContext) ReferenceType() IReferenceTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IReferenceTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IReferenceTypeContext)
}

func (s *TypeArgumentContext) Wildcard() IWildcardContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IWildcardContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IWildcardContext)
}

func (s *TypeArgumentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeArgumentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeArgumentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.EnterTypeArgument(s)
	}
}

func (s *TypeArgumentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.ExitTypeArgument(s)
	}
}

func (p *Java9Parser) TypeArgument() (localctx ITypeArgumentContext) {
	localctx = NewTypeArgumentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 44, Java9ParserRULE_typeArgument)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(664)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 27, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(662)
			p.ReferenceType()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(663)
			p.Wildcard()
		}

	}

	return localctx
}

// IWildcardContext is an interface to support dynamic dispatch.
type IWildcardContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsWildcardContext differentiates from other interfaces.
	IsWildcardContext()
}

type WildcardContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWildcardContext() *WildcardContext {
	var p = new(WildcardContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Java9ParserRULE_wildcard
	return p
}

func (*WildcardContext) IsWildcardContext() {}

func NewWildcardContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WildcardContext {
	var p = new(WildcardContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java9ParserRULE_wildcard

	return p
}

func (s *WildcardContext) GetParser() antlr.Parser { return s.parser }

func (s *WildcardContext) QUESTION() antlr.TerminalNode {
	return s.GetToken(Java9ParserQUESTION, 0)
}

func (s *WildcardContext) AllAnnotation() []IAnnotationContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAnnotationContext)(nil)).Elem())
	var tst = make([]IAnnotationContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAnnotationContext)
		}
	}

	return tst
}

func (s *WildcardContext) Annotation(i int) IAnnotationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAnnotationContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAnnotationContext)
}

func (s *WildcardContext) WildcardBounds() IWildcardBoundsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IWildcardBoundsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IWildcardBoundsContext)
}

func (s *WildcardContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WildcardContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WildcardContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.EnterWildcard(s)
	}
}

func (s *WildcardContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.ExitWildcard(s)
	}
}

func (p *Java9Parser) Wildcard() (localctx IWildcardContext) {
	localctx = NewWildcardContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 46, Java9ParserRULE_wildcard)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(669)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == Java9ParserAT {
		{
			p.SetState(666)
			p.Annotation()
		}

		p.SetState(671)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(672)
		p.Match(Java9ParserQUESTION)
	}
	p.SetState(674)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Java9ParserEXTENDS || _la == Java9ParserSUPER {
		{
			p.SetState(673)
			p.WildcardBounds()
		}

	}

	return localctx
}

// IWildcardBoundsContext is an interface to support dynamic dispatch.
type IWildcardBoundsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsWildcardBoundsContext differentiates from other interfaces.
	IsWildcardBoundsContext()
}

type WildcardBoundsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWildcardBoundsContext() *WildcardBoundsContext {
	var p = new(WildcardBoundsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Java9ParserRULE_wildcardBounds
	return p
}

func (*WildcardBoundsContext) IsWildcardBoundsContext() {}

func NewWildcardBoundsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WildcardBoundsContext {
	var p = new(WildcardBoundsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java9ParserRULE_wildcardBounds

	return p
}

func (s *WildcardBoundsContext) GetParser() antlr.Parser { return s.parser }

func (s *WildcardBoundsContext) EXTENDS() antlr.TerminalNode {
	return s.GetToken(Java9ParserEXTENDS, 0)
}

func (s *WildcardBoundsContext) ReferenceType() IReferenceTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IReferenceTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IReferenceTypeContext)
}

func (s *WildcardBoundsContext) SUPER() antlr.TerminalNode {
	return s.GetToken(Java9ParserSUPER, 0)
}

func (s *WildcardBoundsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WildcardBoundsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WildcardBoundsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.EnterWildcardBounds(s)
	}
}

func (s *WildcardBoundsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.ExitWildcardBounds(s)
	}
}

func (p *Java9Parser) WildcardBounds() (localctx IWildcardBoundsContext) {
	localctx = NewWildcardBoundsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 48, Java9ParserRULE_wildcardBounds)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(680)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case Java9ParserEXTENDS:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(676)
			p.Match(Java9ParserEXTENDS)
		}
		{
			p.SetState(677)
			p.ReferenceType()
		}

	case Java9ParserSUPER:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(678)
			p.Match(Java9ParserSUPER)
		}
		{
			p.SetState(679)
			p.ReferenceType()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IModuleNameContext is an interface to support dynamic dispatch.
type IModuleNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsModuleNameContext differentiates from other interfaces.
	IsModuleNameContext()
}

type ModuleNameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyModuleNameContext() *ModuleNameContext {
	var p = new(ModuleNameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Java9ParserRULE_moduleName
	return p
}

func (*ModuleNameContext) IsModuleNameContext() {}

func NewModuleNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ModuleNameContext {
	var p = new(ModuleNameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java9ParserRULE_moduleName

	return p
}

func (s *ModuleNameContext) GetParser() antlr.Parser { return s.parser }

func (s *ModuleNameContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ModuleNameContext) ModuleName() IModuleNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IModuleNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IModuleNameContext)
}

func (s *ModuleNameContext) DOT() antlr.TerminalNode {
	return s.GetToken(Java9ParserDOT, 0)
}

func (s *ModuleNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ModuleNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ModuleNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.EnterModuleName(s)
	}
}

func (s *ModuleNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.ExitModuleName(s)
	}
}

func (p *Java9Parser) ModuleName() (localctx IModuleNameContext) {
	return p.moduleName(0)
}

func (p *Java9Parser) moduleName(_p int) (localctx IModuleNameContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()
	_parentState := p.GetState()
	localctx = NewModuleNameContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IModuleNameContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 50
	p.EnterRecursionRule(localctx, 50, Java9ParserRULE_moduleName, _p)

	defer func() {
		p.UnrollRecursionContexts(_parentctx)
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(683)
		p.Identifier()
	}

	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(690)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 31, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			localctx = NewModuleNameContext(p, _parentctx, _parentState)
			p.PushNewRecursionContext(localctx, _startState, Java9ParserRULE_moduleName)
			p.SetState(685)

			if !(p.Precpred(p.GetParserRuleContext(), 1)) {
				panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 1)", ""))
			}
			{
				p.SetState(686)
				p.Match(Java9ParserDOT)
			}
			{
				p.SetState(687)
				p.Identifier()
			}

		}
		p.SetState(692)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 31, p.GetParserRuleContext())
	}

	return localctx
}

// IPackageNameContext is an interface to support dynamic dispatch.
type IPackageNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPackageNameContext differentiates from other interfaces.
	IsPackageNameContext()
}

type PackageNameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPackageNameContext() *PackageNameContext {
	var p = new(PackageNameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Java9ParserRULE_packageName
	return p
}

func (*PackageNameContext) IsPackageNameContext() {}

func NewPackageNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PackageNameContext {
	var p = new(PackageNameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java9ParserRULE_packageName

	return p
}

func (s *PackageNameContext) GetParser() antlr.Parser { return s.parser }

func (s *PackageNameContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *PackageNameContext) PackageName() IPackageNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPackageNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPackageNameContext)
}

func (s *PackageNameContext) DOT() antlr.TerminalNode {
	return s.GetToken(Java9ParserDOT, 0)
}

func (s *PackageNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PackageNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PackageNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.EnterPackageName(s)
	}
}

func (s *PackageNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.ExitPackageName(s)
	}
}

func (p *Java9Parser) PackageName() (localctx IPackageNameContext) {
	return p.packageName(0)
}

func (p *Java9Parser) packageName(_p int) (localctx IPackageNameContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()
	_parentState := p.GetState()
	localctx = NewPackageNameContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IPackageNameContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 52
	p.EnterRecursionRule(localctx, 52, Java9ParserRULE_packageName, _p)

	defer func() {
		p.UnrollRecursionContexts(_parentctx)
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(694)
		p.Identifier()
	}

	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(701)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 32, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			localctx = NewPackageNameContext(p, _parentctx, _parentState)
			p.PushNewRecursionContext(localctx, _startState, Java9ParserRULE_packageName)
			p.SetState(696)

			if !(p.Precpred(p.GetParserRuleContext(), 1)) {
				panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 1)", ""))
			}
			{
				p.SetState(697)
				p.Match(Java9ParserDOT)
			}
			{
				p.SetState(698)
				p.Identifier()
			}

		}
		p.SetState(703)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 32, p.GetParserRuleContext())
	}

	return localctx
}

// ITypeNameContext is an interface to support dynamic dispatch.
type ITypeNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTypeNameContext differentiates from other interfaces.
	IsTypeNameContext()
}

type TypeNameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeNameContext() *TypeNameContext {
	var p = new(TypeNameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Java9ParserRULE_typeName
	return p
}

func (*TypeNameContext) IsTypeNameContext() {}

func NewTypeNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeNameContext {
	var p = new(TypeNameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java9ParserRULE_typeName

	return p
}

func (s *TypeNameContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeNameContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *TypeNameContext) PackageOrTypeName() IPackageOrTypeNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPackageOrTypeNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPackageOrTypeNameContext)
}

func (s *TypeNameContext) DOT() antlr.TerminalNode {
	return s.GetToken(Java9ParserDOT, 0)
}

func (s *TypeNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.EnterTypeName(s)
	}
}

func (s *TypeNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.ExitTypeName(s)
	}
}

func (p *Java9Parser) TypeName() (localctx ITypeNameContext) {
	localctx = NewTypeNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 54, Java9ParserRULE_typeName)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(709)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 33, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(704)
			p.Identifier()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(705)
			p.packageOrTypeName(0)
		}
		{
			p.SetState(706)
			p.Match(Java9ParserDOT)
		}
		{
			p.SetState(707)
			p.Identifier()
		}

	}

	return localctx
}

// IPackageOrTypeNameContext is an interface to support dynamic dispatch.
type IPackageOrTypeNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPackageOrTypeNameContext differentiates from other interfaces.
	IsPackageOrTypeNameContext()
}

type PackageOrTypeNameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPackageOrTypeNameContext() *PackageOrTypeNameContext {
	var p = new(PackageOrTypeNameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Java9ParserRULE_packageOrTypeName
	return p
}

func (*PackageOrTypeNameContext) IsPackageOrTypeNameContext() {}

func NewPackageOrTypeNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PackageOrTypeNameContext {
	var p = new(PackageOrTypeNameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java9ParserRULE_packageOrTypeName

	return p
}

func (s *PackageOrTypeNameContext) GetParser() antlr.Parser { return s.parser }

func (s *PackageOrTypeNameContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *PackageOrTypeNameContext) PackageOrTypeName() IPackageOrTypeNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPackageOrTypeNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPackageOrTypeNameContext)
}

func (s *PackageOrTypeNameContext) DOT() antlr.TerminalNode {
	return s.GetToken(Java9ParserDOT, 0)
}

func (s *PackageOrTypeNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PackageOrTypeNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PackageOrTypeNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.EnterPackageOrTypeName(s)
	}
}

func (s *PackageOrTypeNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.ExitPackageOrTypeName(s)
	}
}

func (p *Java9Parser) PackageOrTypeName() (localctx IPackageOrTypeNameContext) {
	return p.packageOrTypeName(0)
}

func (p *Java9Parser) packageOrTypeName(_p int) (localctx IPackageOrTypeNameContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()
	_parentState := p.GetState()
	localctx = NewPackageOrTypeNameContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IPackageOrTypeNameContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 56
	p.EnterRecursionRule(localctx, 56, Java9ParserRULE_packageOrTypeName, _p)

	defer func() {
		p.UnrollRecursionContexts(_parentctx)
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(712)
		p.Identifier()
	}

	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(719)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 34, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			localctx = NewPackageOrTypeNameContext(p, _parentctx, _parentState)
			p.PushNewRecursionContext(localctx, _startState, Java9ParserRULE_packageOrTypeName)
			p.SetState(714)

			if !(p.Precpred(p.GetParserRuleContext(), 1)) {
				panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 1)", ""))
			}
			{
				p.SetState(715)
				p.Match(Java9ParserDOT)
			}
			{
				p.SetState(716)
				p.Identifier()
			}

		}
		p.SetState(721)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 34, p.GetParserRuleContext())
	}

	return localctx
}

// IExpressionNameContext is an interface to support dynamic dispatch.
type IExpressionNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExpressionNameContext differentiates from other interfaces.
	IsExpressionNameContext()
}

type ExpressionNameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpressionNameContext() *ExpressionNameContext {
	var p = new(ExpressionNameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Java9ParserRULE_expressionName
	return p
}

func (*ExpressionNameContext) IsExpressionNameContext() {}

func NewExpressionNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExpressionNameContext {
	var p = new(ExpressionNameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java9ParserRULE_expressionName

	return p
}

func (s *ExpressionNameContext) GetParser() antlr.Parser { return s.parser }

func (s *ExpressionNameContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ExpressionNameContext) AmbiguousName() IAmbiguousNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAmbiguousNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAmbiguousNameContext)
}

func (s *ExpressionNameContext) DOT() antlr.TerminalNode {
	return s.GetToken(Java9ParserDOT, 0)
}

func (s *ExpressionNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExpressionNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExpressionNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.EnterExpressionName(s)
	}
}

func (s *ExpressionNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.ExitExpressionName(s)
	}
}

func (p *Java9Parser) ExpressionName() (localctx IExpressionNameContext) {
	localctx = NewExpressionNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 58, Java9ParserRULE_expressionName)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(727)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 35, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(722)
			p.Identifier()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(723)
			p.ambiguousName(0)
		}
		{
			p.SetState(724)
			p.Match(Java9ParserDOT)
		}
		{
			p.SetState(725)
			p.Identifier()
		}

	}

	return localctx
}

// IMethodNameContext is an interface to support dynamic dispatch.
type IMethodNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMethodNameContext differentiates from other interfaces.
	IsMethodNameContext()
}

type MethodNameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMethodNameContext() *MethodNameContext {
	var p = new(MethodNameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Java9ParserRULE_methodName
	return p
}

func (*MethodNameContext) IsMethodNameContext() {}

func NewMethodNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MethodNameContext {
	var p = new(MethodNameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java9ParserRULE_methodName

	return p
}

func (s *MethodNameContext) GetParser() antlr.Parser { return s.parser }

func (s *MethodNameContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *MethodNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MethodNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MethodNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.EnterMethodName(s)
	}
}

func (s *MethodNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.ExitMethodName(s)
	}
}

func (p *Java9Parser) MethodName() (localctx IMethodNameContext) {
	localctx = NewMethodNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 60, Java9ParserRULE_methodName)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(729)
		p.Identifier()
	}

	return localctx
}

// IAmbiguousNameContext is an interface to support dynamic dispatch.
type IAmbiguousNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAmbiguousNameContext differentiates from other interfaces.
	IsAmbiguousNameContext()
}

type AmbiguousNameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAmbiguousNameContext() *AmbiguousNameContext {
	var p = new(AmbiguousNameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Java9ParserRULE_ambiguousName
	return p
}

func (*AmbiguousNameContext) IsAmbiguousNameContext() {}

func NewAmbiguousNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AmbiguousNameContext {
	var p = new(AmbiguousNameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java9ParserRULE_ambiguousName

	return p
}

func (s *AmbiguousNameContext) GetParser() antlr.Parser { return s.parser }

func (s *AmbiguousNameContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *AmbiguousNameContext) AmbiguousName() IAmbiguousNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAmbiguousNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAmbiguousNameContext)
}

func (s *AmbiguousNameContext) DOT() antlr.TerminalNode {
	return s.GetToken(Java9ParserDOT, 0)
}

func (s *AmbiguousNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AmbiguousNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AmbiguousNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.EnterAmbiguousName(s)
	}
}

func (s *AmbiguousNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.ExitAmbiguousName(s)
	}
}

func (p *Java9Parser) AmbiguousName() (localctx IAmbiguousNameContext) {
	return p.ambiguousName(0)
}

func (p *Java9Parser) ambiguousName(_p int) (localctx IAmbiguousNameContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()
	_parentState := p.GetState()
	localctx = NewAmbiguousNameContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IAmbiguousNameContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 62
	p.EnterRecursionRule(localctx, 62, Java9ParserRULE_ambiguousName, _p)

	defer func() {
		p.UnrollRecursionContexts(_parentctx)
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(732)
		p.Identifier()
	}

	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(739)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 36, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			localctx = NewAmbiguousNameContext(p, _parentctx, _parentState)
			p.PushNewRecursionContext(localctx, _startState, Java9ParserRULE_ambiguousName)
			p.SetState(734)

			if !(p.Precpred(p.GetParserRuleContext(), 1)) {
				panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 1)", ""))
			}
			{
				p.SetState(735)
				p.Match(Java9ParserDOT)
			}
			{
				p.SetState(736)
				p.Identifier()
			}

		}
		p.SetState(741)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 36, p.GetParserRuleContext())
	}

	return localctx
}

// ICompilationUnitContext is an interface to support dynamic dispatch.
type ICompilationUnitContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCompilationUnitContext differentiates from other interfaces.
	IsCompilationUnitContext()
}

type CompilationUnitContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCompilationUnitContext() *CompilationUnitContext {
	var p = new(CompilationUnitContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Java9ParserRULE_compilationUnit
	return p
}

func (*CompilationUnitContext) IsCompilationUnitContext() {}

func NewCompilationUnitContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CompilationUnitContext {
	var p = new(CompilationUnitContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java9ParserRULE_compilationUnit

	return p
}

func (s *CompilationUnitContext) GetParser() antlr.Parser { return s.parser }

func (s *CompilationUnitContext) OrdinaryCompilation() IOrdinaryCompilationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOrdinaryCompilationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOrdinaryCompilationContext)
}

func (s *CompilationUnitContext) ModularCompilation() IModularCompilationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IModularCompilationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IModularCompilationContext)
}

func (s *CompilationUnitContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CompilationUnitContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CompilationUnitContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.EnterCompilationUnit(s)
	}
}

func (s *CompilationUnitContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.ExitCompilationUnit(s)
	}
}

func (p *Java9Parser) CompilationUnit() (localctx ICompilationUnitContext) {
	localctx = NewCompilationUnitContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 64, Java9ParserRULE_compilationUnit)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(744)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 37, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(742)
			p.OrdinaryCompilation()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(743)
			p.ModularCompilation()
		}

	}

	return localctx
}

// IOrdinaryCompilationContext is an interface to support dynamic dispatch.
type IOrdinaryCompilationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOrdinaryCompilationContext differentiates from other interfaces.
	IsOrdinaryCompilationContext()
}

type OrdinaryCompilationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOrdinaryCompilationContext() *OrdinaryCompilationContext {
	var p = new(OrdinaryCompilationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Java9ParserRULE_ordinaryCompilation
	return p
}

func (*OrdinaryCompilationContext) IsOrdinaryCompilationContext() {}

func NewOrdinaryCompilationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OrdinaryCompilationContext {
	var p = new(OrdinaryCompilationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java9ParserRULE_ordinaryCompilation

	return p
}

func (s *OrdinaryCompilationContext) GetParser() antlr.Parser { return s.parser }

func (s *OrdinaryCompilationContext) EOF() antlr.TerminalNode {
	return s.GetToken(Java9ParserEOF, 0)
}

func (s *OrdinaryCompilationContext) PackageDeclaration() IPackageDeclarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPackageDeclarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPackageDeclarationContext)
}

func (s *OrdinaryCompilationContext) AllImportDeclaration() []IImportDeclarationContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IImportDeclarationContext)(nil)).Elem())
	var tst = make([]IImportDeclarationContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IImportDeclarationContext)
		}
	}

	return tst
}

func (s *OrdinaryCompilationContext) ImportDeclaration(i int) IImportDeclarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IImportDeclarationContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IImportDeclarationContext)
}

func (s *OrdinaryCompilationContext) AllTypeDeclaration() []ITypeDeclarationContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ITypeDeclarationContext)(nil)).Elem())
	var tst = make([]ITypeDeclarationContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ITypeDeclarationContext)
		}
	}

	return tst
}

func (s *OrdinaryCompilationContext) TypeDeclaration(i int) ITypeDeclarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypeDeclarationContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ITypeDeclarationContext)
}

func (s *OrdinaryCompilationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OrdinaryCompilationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OrdinaryCompilationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.EnterOrdinaryCompilation(s)
	}
}

func (s *OrdinaryCompilationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.ExitOrdinaryCompilation(s)
	}
}

func (p *Java9Parser) OrdinaryCompilation() (localctx IOrdinaryCompilationContext) {
	localctx = NewOrdinaryCompilationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 66, Java9ParserRULE_ordinaryCompilation)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(747)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 38, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(746)
			p.PackageDeclaration()
		}

	}
	p.SetState(752)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == Java9ParserIMPORT {
		{
			p.SetState(749)
			p.ImportDeclaration()
		}

		p.SetState(754)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(758)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<Java9ParserABSTRACT)|(1<<Java9ParserCLASS)|(1<<Java9ParserENUM)|(1<<Java9ParserFINAL)|(1<<Java9ParserINTERFACE))) != 0) || (((_la-37)&-(0x1f+1)) == 0 && ((1<<uint((_la-37)))&((1<<(Java9ParserPRIVATE-37))|(1<<(Java9ParserPROTECTED-37))|(1<<(Java9ParserPUBLIC-37))|(1<<(Java9ParserSTATIC-37))|(1<<(Java9ParserSTRICTFP-37)))) != 0) || _la == Java9ParserSEMI || _la == Java9ParserAT {
		{
			p.SetState(755)
			p.TypeDeclaration()
		}

		p.SetState(760)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(761)
		p.Match(Java9ParserEOF)
	}

	return localctx
}

// IModularCompilationContext is an interface to support dynamic dispatch.
type IModularCompilationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsModularCompilationContext differentiates from other interfaces.
	IsModularCompilationContext()
}

type ModularCompilationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyModularCompilationContext() *ModularCompilationContext {
	var p = new(ModularCompilationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Java9ParserRULE_modularCompilation
	return p
}

func (*ModularCompilationContext) IsModularCompilationContext() {}

func NewModularCompilationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ModularCompilationContext {
	var p = new(ModularCompilationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java9ParserRULE_modularCompilation

	return p
}

func (s *ModularCompilationContext) GetParser() antlr.Parser { return s.parser }

func (s *ModularCompilationContext) ModuleDeclaration() IModuleDeclarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IModuleDeclarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IModuleDeclarationContext)
}

func (s *ModularCompilationContext) AllImportDeclaration() []IImportDeclarationContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IImportDeclarationContext)(nil)).Elem())
	var tst = make([]IImportDeclarationContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IImportDeclarationContext)
		}
	}

	return tst
}

func (s *ModularCompilationContext) ImportDeclaration(i int) IImportDeclarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IImportDeclarationContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IImportDeclarationContext)
}

func (s *ModularCompilationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ModularCompilationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ModularCompilationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.EnterModularCompilation(s)
	}
}

func (s *ModularCompilationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.ExitModularCompilation(s)
	}
}

func (p *Java9Parser) ModularCompilation() (localctx IModularCompilationContext) {
	localctx = NewModularCompilationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 68, Java9ParserRULE_modularCompilation)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(766)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == Java9ParserIMPORT {
		{
			p.SetState(763)
			p.ImportDeclaration()
		}

		p.SetState(768)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(769)
		p.ModuleDeclaration()
	}

	return localctx
}

// IPackageDeclarationContext is an interface to support dynamic dispatch.
type IPackageDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPackageDeclarationContext differentiates from other interfaces.
	IsPackageDeclarationContext()
}

type PackageDeclarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPackageDeclarationContext() *PackageDeclarationContext {
	var p = new(PackageDeclarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Java9ParserRULE_packageDeclaration
	return p
}

func (*PackageDeclarationContext) IsPackageDeclarationContext() {}

func NewPackageDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PackageDeclarationContext {
	var p = new(PackageDeclarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java9ParserRULE_packageDeclaration

	return p
}

func (s *PackageDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *PackageDeclarationContext) PACKAGE() antlr.TerminalNode {
	return s.GetToken(Java9ParserPACKAGE, 0)
}

func (s *PackageDeclarationContext) PackageName() IPackageNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPackageNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPackageNameContext)
}

func (s *PackageDeclarationContext) SEMI() antlr.TerminalNode {
	return s.GetToken(Java9ParserSEMI, 0)
}

func (s *PackageDeclarationContext) AllPackageModifier() []IPackageModifierContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IPackageModifierContext)(nil)).Elem())
	var tst = make([]IPackageModifierContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IPackageModifierContext)
		}
	}

	return tst
}

func (s *PackageDeclarationContext) PackageModifier(i int) IPackageModifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPackageModifierContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IPackageModifierContext)
}

func (s *PackageDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PackageDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PackageDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.EnterPackageDeclaration(s)
	}
}

func (s *PackageDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.ExitPackageDeclaration(s)
	}
}

func (p *Java9Parser) PackageDeclaration() (localctx IPackageDeclarationContext) {
	localctx = NewPackageDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 70, Java9ParserRULE_packageDeclaration)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(774)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == Java9ParserAT {
		{
			p.SetState(771)
			p.PackageModifier()
		}

		p.SetState(776)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(777)
		p.Match(Java9ParserPACKAGE)
	}
	{
		p.SetState(778)
		p.packageName(0)
	}
	{
		p.SetState(779)
		p.Match(Java9ParserSEMI)
	}

	return localctx
}

// IPackageModifierContext is an interface to support dynamic dispatch.
type IPackageModifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPackageModifierContext differentiates from other interfaces.
	IsPackageModifierContext()
}

type PackageModifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPackageModifierContext() *PackageModifierContext {
	var p = new(PackageModifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Java9ParserRULE_packageModifier
	return p
}

func (*PackageModifierContext) IsPackageModifierContext() {}

func NewPackageModifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PackageModifierContext {
	var p = new(PackageModifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java9ParserRULE_packageModifier

	return p
}

func (s *PackageModifierContext) GetParser() antlr.Parser { return s.parser }

func (s *PackageModifierContext) Annotation() IAnnotationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAnnotationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAnnotationContext)
}

func (s *PackageModifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PackageModifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PackageModifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.EnterPackageModifier(s)
	}
}

func (s *PackageModifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.ExitPackageModifier(s)
	}
}

func (p *Java9Parser) PackageModifier() (localctx IPackageModifierContext) {
	localctx = NewPackageModifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 72, Java9ParserRULE_packageModifier)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(781)
		p.Annotation()
	}

	return localctx
}

// IImportDeclarationContext is an interface to support dynamic dispatch.
type IImportDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsImportDeclarationContext differentiates from other interfaces.
	IsImportDeclarationContext()
}

type ImportDeclarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyImportDeclarationContext() *ImportDeclarationContext {
	var p = new(ImportDeclarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Java9ParserRULE_importDeclaration
	return p
}

func (*ImportDeclarationContext) IsImportDeclarationContext() {}

func NewImportDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ImportDeclarationContext {
	var p = new(ImportDeclarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java9ParserRULE_importDeclaration

	return p
}

func (s *ImportDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *ImportDeclarationContext) SingleTypeImportDeclaration() ISingleTypeImportDeclarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISingleTypeImportDeclarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISingleTypeImportDeclarationContext)
}

func (s *ImportDeclarationContext) TypeImportOnDemandDeclaration() ITypeImportOnDemandDeclarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypeImportOnDemandDeclarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITypeImportOnDemandDeclarationContext)
}

func (s *ImportDeclarationContext) SingleStaticImportDeclaration() ISingleStaticImportDeclarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISingleStaticImportDeclarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISingleStaticImportDeclarationContext)
}

func (s *ImportDeclarationContext) StaticImportOnDemandDeclaration() IStaticImportOnDemandDeclarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStaticImportOnDemandDeclarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IStaticImportOnDemandDeclarationContext)
}

func (s *ImportDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ImportDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ImportDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.EnterImportDeclaration(s)
	}
}

func (s *ImportDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.ExitImportDeclaration(s)
	}
}

func (p *Java9Parser) ImportDeclaration() (localctx IImportDeclarationContext) {
	localctx = NewImportDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 74, Java9ParserRULE_importDeclaration)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(787)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 43, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(783)
			p.SingleTypeImportDeclaration()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(784)
			p.TypeImportOnDemandDeclaration()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(785)
			p.SingleStaticImportDeclaration()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(786)
			p.StaticImportOnDemandDeclaration()
		}

	}

	return localctx
}

// ISingleTypeImportDeclarationContext is an interface to support dynamic dispatch.
type ISingleTypeImportDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSingleTypeImportDeclarationContext differentiates from other interfaces.
	IsSingleTypeImportDeclarationContext()
}

type SingleTypeImportDeclarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySingleTypeImportDeclarationContext() *SingleTypeImportDeclarationContext {
	var p = new(SingleTypeImportDeclarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Java9ParserRULE_singleTypeImportDeclaration
	return p
}

func (*SingleTypeImportDeclarationContext) IsSingleTypeImportDeclarationContext() {}

func NewSingleTypeImportDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SingleTypeImportDeclarationContext {
	var p = new(SingleTypeImportDeclarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java9ParserRULE_singleTypeImportDeclaration

	return p
}

func (s *SingleTypeImportDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *SingleTypeImportDeclarationContext) IMPORT() antlr.TerminalNode {
	return s.GetToken(Java9ParserIMPORT, 0)
}

func (s *SingleTypeImportDeclarationContext) TypeName() ITypeNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypeNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITypeNameContext)
}

func (s *SingleTypeImportDeclarationContext) SEMI() antlr.TerminalNode {
	return s.GetToken(Java9ParserSEMI, 0)
}

func (s *SingleTypeImportDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SingleTypeImportDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SingleTypeImportDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.EnterSingleTypeImportDeclaration(s)
	}
}

func (s *SingleTypeImportDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.ExitSingleTypeImportDeclaration(s)
	}
}

func (p *Java9Parser) SingleTypeImportDeclaration() (localctx ISingleTypeImportDeclarationContext) {
	localctx = NewSingleTypeImportDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 76, Java9ParserRULE_singleTypeImportDeclaration)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(789)
		p.Match(Java9ParserIMPORT)
	}
	{
		p.SetState(790)
		p.TypeName()
	}
	{
		p.SetState(791)
		p.Match(Java9ParserSEMI)
	}

	return localctx
}

// ITypeImportOnDemandDeclarationContext is an interface to support dynamic dispatch.
type ITypeImportOnDemandDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTypeImportOnDemandDeclarationContext differentiates from other interfaces.
	IsTypeImportOnDemandDeclarationContext()
}

type TypeImportOnDemandDeclarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeImportOnDemandDeclarationContext() *TypeImportOnDemandDeclarationContext {
	var p = new(TypeImportOnDemandDeclarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Java9ParserRULE_typeImportOnDemandDeclaration
	return p
}

func (*TypeImportOnDemandDeclarationContext) IsTypeImportOnDemandDeclarationContext() {}

func NewTypeImportOnDemandDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeImportOnDemandDeclarationContext {
	var p = new(TypeImportOnDemandDeclarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java9ParserRULE_typeImportOnDemandDeclaration

	return p
}

func (s *TypeImportOnDemandDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeImportOnDemandDeclarationContext) IMPORT() antlr.TerminalNode {
	return s.GetToken(Java9ParserIMPORT, 0)
}

func (s *TypeImportOnDemandDeclarationContext) PackageOrTypeName() IPackageOrTypeNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPackageOrTypeNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPackageOrTypeNameContext)
}

func (s *TypeImportOnDemandDeclarationContext) DOT() antlr.TerminalNode {
	return s.GetToken(Java9ParserDOT, 0)
}

func (s *TypeImportOnDemandDeclarationContext) MUL() antlr.TerminalNode {
	return s.GetToken(Java9ParserMUL, 0)
}

func (s *TypeImportOnDemandDeclarationContext) SEMI() antlr.TerminalNode {
	return s.GetToken(Java9ParserSEMI, 0)
}

func (s *TypeImportOnDemandDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeImportOnDemandDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeImportOnDemandDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.EnterTypeImportOnDemandDeclaration(s)
	}
}

func (s *TypeImportOnDemandDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.ExitTypeImportOnDemandDeclaration(s)
	}
}

func (p *Java9Parser) TypeImportOnDemandDeclaration() (localctx ITypeImportOnDemandDeclarationContext) {
	localctx = NewTypeImportOnDemandDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 78, Java9ParserRULE_typeImportOnDemandDeclaration)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(793)
		p.Match(Java9ParserIMPORT)
	}
	{
		p.SetState(794)
		p.packageOrTypeName(0)
	}
	{
		p.SetState(795)
		p.Match(Java9ParserDOT)
	}
	{
		p.SetState(796)
		p.Match(Java9ParserMUL)
	}
	{
		p.SetState(797)
		p.Match(Java9ParserSEMI)
	}

	return localctx
}

// ISingleStaticImportDeclarationContext is an interface to support dynamic dispatch.
type ISingleStaticImportDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSingleStaticImportDeclarationContext differentiates from other interfaces.
	IsSingleStaticImportDeclarationContext()
}

type SingleStaticImportDeclarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySingleStaticImportDeclarationContext() *SingleStaticImportDeclarationContext {
	var p = new(SingleStaticImportDeclarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Java9ParserRULE_singleStaticImportDeclaration
	return p
}

func (*SingleStaticImportDeclarationContext) IsSingleStaticImportDeclarationContext() {}

func NewSingleStaticImportDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SingleStaticImportDeclarationContext {
	var p = new(SingleStaticImportDeclarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java9ParserRULE_singleStaticImportDeclaration

	return p
}

func (s *SingleStaticImportDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *SingleStaticImportDeclarationContext) IMPORT() antlr.TerminalNode {
	return s.GetToken(Java9ParserIMPORT, 0)
}

func (s *SingleStaticImportDeclarationContext) STATIC() antlr.TerminalNode {
	return s.GetToken(Java9ParserSTATIC, 0)
}

func (s *SingleStaticImportDeclarationContext) TypeName() ITypeNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypeNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITypeNameContext)
}

func (s *SingleStaticImportDeclarationContext) DOT() antlr.TerminalNode {
	return s.GetToken(Java9ParserDOT, 0)
}

func (s *SingleStaticImportDeclarationContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *SingleStaticImportDeclarationContext) SEMI() antlr.TerminalNode {
	return s.GetToken(Java9ParserSEMI, 0)
}

func (s *SingleStaticImportDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SingleStaticImportDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SingleStaticImportDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.EnterSingleStaticImportDeclaration(s)
	}
}

func (s *SingleStaticImportDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.ExitSingleStaticImportDeclaration(s)
	}
}

func (p *Java9Parser) SingleStaticImportDeclaration() (localctx ISingleStaticImportDeclarationContext) {
	localctx = NewSingleStaticImportDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 80, Java9ParserRULE_singleStaticImportDeclaration)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(799)
		p.Match(Java9ParserIMPORT)
	}
	{
		p.SetState(800)
		p.Match(Java9ParserSTATIC)
	}
	{
		p.SetState(801)
		p.TypeName()
	}
	{
		p.SetState(802)
		p.Match(Java9ParserDOT)
	}
	{
		p.SetState(803)
		p.Identifier()
	}
	{
		p.SetState(804)
		p.Match(Java9ParserSEMI)
	}

	return localctx
}

// IStaticImportOnDemandDeclarationContext is an interface to support dynamic dispatch.
type IStaticImportOnDemandDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsStaticImportOnDemandDeclarationContext differentiates from other interfaces.
	IsStaticImportOnDemandDeclarationContext()
}

type StaticImportOnDemandDeclarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStaticImportOnDemandDeclarationContext() *StaticImportOnDemandDeclarationContext {
	var p = new(StaticImportOnDemandDeclarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Java9ParserRULE_staticImportOnDemandDeclaration
	return p
}

func (*StaticImportOnDemandDeclarationContext) IsStaticImportOnDemandDeclarationContext() {}

func NewStaticImportOnDemandDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StaticImportOnDemandDeclarationContext {
	var p = new(StaticImportOnDemandDeclarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java9ParserRULE_staticImportOnDemandDeclaration

	return p
}

func (s *StaticImportOnDemandDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *StaticImportOnDemandDeclarationContext) IMPORT() antlr.TerminalNode {
	return s.GetToken(Java9ParserIMPORT, 0)
}

func (s *StaticImportOnDemandDeclarationContext) STATIC() antlr.TerminalNode {
	return s.GetToken(Java9ParserSTATIC, 0)
}

func (s *StaticImportOnDemandDeclarationContext) TypeName() ITypeNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypeNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITypeNameContext)
}

func (s *StaticImportOnDemandDeclarationContext) DOT() antlr.TerminalNode {
	return s.GetToken(Java9ParserDOT, 0)
}

func (s *StaticImportOnDemandDeclarationContext) MUL() antlr.TerminalNode {
	return s.GetToken(Java9ParserMUL, 0)
}

func (s *StaticImportOnDemandDeclarationContext) SEMI() antlr.TerminalNode {
	return s.GetToken(Java9ParserSEMI, 0)
}

func (s *StaticImportOnDemandDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StaticImportOnDemandDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StaticImportOnDemandDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.EnterStaticImportOnDemandDeclaration(s)
	}
}

func (s *StaticImportOnDemandDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.ExitStaticImportOnDemandDeclaration(s)
	}
}

func (p *Java9Parser) StaticImportOnDemandDeclaration() (localctx IStaticImportOnDemandDeclarationContext) {
	localctx = NewStaticImportOnDemandDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 82, Java9ParserRULE_staticImportOnDemandDeclaration)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(806)
		p.Match(Java9ParserIMPORT)
	}
	{
		p.SetState(807)
		p.Match(Java9ParserSTATIC)
	}
	{
		p.SetState(808)
		p.TypeName()
	}
	{
		p.SetState(809)
		p.Match(Java9ParserDOT)
	}
	{
		p.SetState(810)
		p.Match(Java9ParserMUL)
	}
	{
		p.SetState(811)
		p.Match(Java9ParserSEMI)
	}

	return localctx
}

// ITypeDeclarationContext is an interface to support dynamic dispatch.
type ITypeDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTypeDeclarationContext differentiates from other interfaces.
	IsTypeDeclarationContext()
}

type TypeDeclarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeDeclarationContext() *TypeDeclarationContext {
	var p = new(TypeDeclarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Java9ParserRULE_typeDeclaration
	return p
}

func (*TypeDeclarationContext) IsTypeDeclarationContext() {}

func NewTypeDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeDeclarationContext {
	var p = new(TypeDeclarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java9ParserRULE_typeDeclaration

	return p
}

func (s *TypeDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeDeclarationContext) ClassDeclaration() IClassDeclarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IClassDeclarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IClassDeclarationContext)
}

func (s *TypeDeclarationContext) InterfaceDeclaration() IInterfaceDeclarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInterfaceDeclarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInterfaceDeclarationContext)
}

func (s *TypeDeclarationContext) SEMI() antlr.TerminalNode {
	return s.GetToken(Java9ParserSEMI, 0)
}

func (s *TypeDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.EnterTypeDeclaration(s)
	}
}

func (s *TypeDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.ExitTypeDeclaration(s)
	}
}

func (p *Java9Parser) TypeDeclaration() (localctx ITypeDeclarationContext) {
	localctx = NewTypeDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 84, Java9ParserRULE_typeDeclaration)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(816)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 44, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(813)
			p.ClassDeclaration()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(814)
			p.InterfaceDeclaration()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(815)
			p.Match(Java9ParserSEMI)
		}

	}

	return localctx
}

// IModuleDeclarationContext is an interface to support dynamic dispatch.
type IModuleDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsModuleDeclarationContext differentiates from other interfaces.
	IsModuleDeclarationContext()
}

type ModuleDeclarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyModuleDeclarationContext() *ModuleDeclarationContext {
	var p = new(ModuleDeclarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Java9ParserRULE_moduleDeclaration
	return p
}

func (*ModuleDeclarationContext) IsModuleDeclarationContext() {}

func NewModuleDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ModuleDeclarationContext {
	var p = new(ModuleDeclarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java9ParserRULE_moduleDeclaration

	return p
}

func (s *ModuleDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *ModuleDeclarationContext) MODULE() antlr.TerminalNode {
	return s.GetToken(Java9ParserMODULE, 0)
}

func (s *ModuleDeclarationContext) ModuleName() IModuleNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IModuleNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IModuleNameContext)
}

func (s *ModuleDeclarationContext) LBRACE() antlr.TerminalNode {
	return s.GetToken(Java9ParserLBRACE, 0)
}

func (s *ModuleDeclarationContext) RBRACE() antlr.TerminalNode {
	return s.GetToken(Java9ParserRBRACE, 0)
}

func (s *ModuleDeclarationContext) AllAnnotation() []IAnnotationContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAnnotationContext)(nil)).Elem())
	var tst = make([]IAnnotationContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAnnotationContext)
		}
	}

	return tst
}

func (s *ModuleDeclarationContext) Annotation(i int) IAnnotationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAnnotationContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAnnotationContext)
}

func (s *ModuleDeclarationContext) OPEN() antlr.TerminalNode {
	return s.GetToken(Java9ParserOPEN, 0)
}

func (s *ModuleDeclarationContext) AllModuleDirective() []IModuleDirectiveContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IModuleDirectiveContext)(nil)).Elem())
	var tst = make([]IModuleDirectiveContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IModuleDirectiveContext)
		}
	}

	return tst
}

func (s *ModuleDeclarationContext) ModuleDirective(i int) IModuleDirectiveContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IModuleDirectiveContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IModuleDirectiveContext)
}

func (s *ModuleDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ModuleDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ModuleDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.EnterModuleDeclaration(s)
	}
}

func (s *ModuleDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.ExitModuleDeclaration(s)
	}
}

func (p *Java9Parser) ModuleDeclaration() (localctx IModuleDeclarationContext) {
	localctx = NewModuleDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 86, Java9ParserRULE_moduleDeclaration)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(821)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == Java9ParserAT {
		{
			p.SetState(818)
			p.Annotation()
		}

		p.SetState(823)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(825)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Java9ParserOPEN {
		{
			p.SetState(824)
			p.Match(Java9ParserOPEN)
		}

	}
	{
		p.SetState(827)
		p.Match(Java9ParserMODULE)
	}
	{
		p.SetState(828)
		p.moduleName(0)
	}
	{
		p.SetState(829)
		p.Match(Java9ParserLBRACE)
	}
	p.SetState(833)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == Java9ParserEXPORTS || (((_la-35)&-(0x1f+1)) == 0 && ((1<<uint((_la-35)))&((1<<(Java9ParserOPERNS-35))|(1<<(Java9ParserPROVIDES-35))|(1<<(Java9ParserREQUIRES-35))|(1<<(Java9ParserUSES-35)))) != 0) {
		{
			p.SetState(830)
			p.ModuleDirective()
		}

		p.SetState(835)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(836)
		p.Match(Java9ParserRBRACE)
	}

	return localctx
}

// IModuleDirectiveContext is an interface to support dynamic dispatch.
type IModuleDirectiveContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsModuleDirectiveContext differentiates from other interfaces.
	IsModuleDirectiveContext()
}

type ModuleDirectiveContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyModuleDirectiveContext() *ModuleDirectiveContext {
	var p = new(ModuleDirectiveContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Java9ParserRULE_moduleDirective
	return p
}

func (*ModuleDirectiveContext) IsModuleDirectiveContext() {}

func NewModuleDirectiveContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ModuleDirectiveContext {
	var p = new(ModuleDirectiveContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java9ParserRULE_moduleDirective

	return p
}

func (s *ModuleDirectiveContext) GetParser() antlr.Parser { return s.parser }

func (s *ModuleDirectiveContext) REQUIRES() antlr.TerminalNode {
	return s.GetToken(Java9ParserREQUIRES, 0)
}

func (s *ModuleDirectiveContext) AllModuleName() []IModuleNameContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IModuleNameContext)(nil)).Elem())
	var tst = make([]IModuleNameContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IModuleNameContext)
		}
	}

	return tst
}

func (s *ModuleDirectiveContext) ModuleName(i int) IModuleNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IModuleNameContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IModuleNameContext)
}

func (s *ModuleDirectiveContext) SEMI() antlr.TerminalNode {
	return s.GetToken(Java9ParserSEMI, 0)
}

func (s *ModuleDirectiveContext) AllRequiresModifier() []IRequiresModifierContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IRequiresModifierContext)(nil)).Elem())
	var tst = make([]IRequiresModifierContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IRequiresModifierContext)
		}
	}

	return tst
}

func (s *ModuleDirectiveContext) RequiresModifier(i int) IRequiresModifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRequiresModifierContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IRequiresModifierContext)
}

func (s *ModuleDirectiveContext) EXPORTS() antlr.TerminalNode {
	return s.GetToken(Java9ParserEXPORTS, 0)
}

func (s *ModuleDirectiveContext) PackageName() IPackageNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPackageNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPackageNameContext)
}

func (s *ModuleDirectiveContext) TO() antlr.TerminalNode {
	return s.GetToken(Java9ParserTO, 0)
}

func (s *ModuleDirectiveContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(Java9ParserCOMMA)
}

func (s *ModuleDirectiveContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(Java9ParserCOMMA, i)
}

func (s *ModuleDirectiveContext) OPERNS() antlr.TerminalNode {
	return s.GetToken(Java9ParserOPERNS, 0)
}

func (s *ModuleDirectiveContext) USES() antlr.TerminalNode {
	return s.GetToken(Java9ParserUSES, 0)
}

func (s *ModuleDirectiveContext) AllTypeName() []ITypeNameContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ITypeNameContext)(nil)).Elem())
	var tst = make([]ITypeNameContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ITypeNameContext)
		}
	}

	return tst
}

func (s *ModuleDirectiveContext) TypeName(i int) ITypeNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypeNameContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ITypeNameContext)
}

func (s *ModuleDirectiveContext) PROVIDES() antlr.TerminalNode {
	return s.GetToken(Java9ParserPROVIDES, 0)
}

func (s *ModuleDirectiveContext) WITH() antlr.TerminalNode {
	return s.GetToken(Java9ParserWITH, 0)
}

func (s *ModuleDirectiveContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ModuleDirectiveContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ModuleDirectiveContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.EnterModuleDirective(s)
	}
}

func (s *ModuleDirectiveContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.ExitModuleDirective(s)
	}
}

func (p *Java9Parser) ModuleDirective() (localctx IModuleDirectiveContext) {
	localctx = NewModuleDirectiveContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 88, Java9ParserRULE_moduleDirective)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(895)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case Java9ParserREQUIRES:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(838)
			p.Match(Java9ParserREQUIRES)
		}
		p.SetState(842)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == Java9ParserSTATIC || _la == Java9ParserTRANSITIVE {
			{
				p.SetState(839)
				p.RequiresModifier()
			}

			p.SetState(844)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(845)
			p.moduleName(0)
		}
		{
			p.SetState(846)
			p.Match(Java9ParserSEMI)
		}

	case Java9ParserEXPORTS:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(848)
			p.Match(Java9ParserEXPORTS)
		}
		{
			p.SetState(849)
			p.packageName(0)
		}
		p.SetState(859)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == Java9ParserTO {
			{
				p.SetState(850)
				p.Match(Java9ParserTO)
			}
			{
				p.SetState(851)
				p.moduleName(0)
			}
			p.SetState(856)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			for _la == Java9ParserCOMMA {
				{
					p.SetState(852)
					p.Match(Java9ParserCOMMA)
				}
				{
					p.SetState(853)
					p.moduleName(0)
				}

				p.SetState(858)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)
			}

		}
		{
			p.SetState(861)
			p.Match(Java9ParserSEMI)
		}

	case Java9ParserOPERNS:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(863)
			p.Match(Java9ParserOPERNS)
		}
		{
			p.SetState(864)
			p.packageName(0)
		}
		p.SetState(874)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == Java9ParserTO {
			{
				p.SetState(865)
				p.Match(Java9ParserTO)
			}
			{
				p.SetState(866)
				p.moduleName(0)
			}
			p.SetState(871)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			for _la == Java9ParserCOMMA {
				{
					p.SetState(867)
					p.Match(Java9ParserCOMMA)
				}
				{
					p.SetState(868)
					p.moduleName(0)
				}

				p.SetState(873)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)
			}

		}
		{
			p.SetState(876)
			p.Match(Java9ParserSEMI)
		}

	case Java9ParserUSES:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(878)
			p.Match(Java9ParserUSES)
		}
		{
			p.SetState(879)
			p.TypeName()
		}
		{
			p.SetState(880)
			p.Match(Java9ParserSEMI)
		}

	case Java9ParserPROVIDES:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(882)
			p.Match(Java9ParserPROVIDES)
		}
		{
			p.SetState(883)
			p.TypeName()
		}
		{
			p.SetState(884)
			p.Match(Java9ParserWITH)
		}
		{
			p.SetState(885)
			p.TypeName()
		}
		p.SetState(890)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == Java9ParserCOMMA {
			{
				p.SetState(886)
				p.Match(Java9ParserCOMMA)
			}
			{
				p.SetState(887)
				p.TypeName()
			}

			p.SetState(892)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(893)
			p.Match(Java9ParserSEMI)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IRequiresModifierContext is an interface to support dynamic dispatch.
type IRequiresModifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRequiresModifierContext differentiates from other interfaces.
	IsRequiresModifierContext()
}

type RequiresModifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRequiresModifierContext() *RequiresModifierContext {
	var p = new(RequiresModifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Java9ParserRULE_requiresModifier
	return p
}

func (*RequiresModifierContext) IsRequiresModifierContext() {}

func NewRequiresModifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RequiresModifierContext {
	var p = new(RequiresModifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java9ParserRULE_requiresModifier

	return p
}

func (s *RequiresModifierContext) GetParser() antlr.Parser { return s.parser }

func (s *RequiresModifierContext) TRANSITIVE() antlr.TerminalNode {
	return s.GetToken(Java9ParserTRANSITIVE, 0)
}

func (s *RequiresModifierContext) STATIC() antlr.TerminalNode {
	return s.GetToken(Java9ParserSTATIC, 0)
}

func (s *RequiresModifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RequiresModifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RequiresModifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.EnterRequiresModifier(s)
	}
}

func (s *RequiresModifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.ExitRequiresModifier(s)
	}
}

func (p *Java9Parser) RequiresModifier() (localctx IRequiresModifierContext) {
	localctx = NewRequiresModifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 90, Java9ParserRULE_requiresModifier)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(897)
		_la = p.GetTokenStream().LA(1)

		if !(_la == Java9ParserSTATIC || _la == Java9ParserTRANSITIVE) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IClassDeclarationContext is an interface to support dynamic dispatch.
type IClassDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsClassDeclarationContext differentiates from other interfaces.
	IsClassDeclarationContext()
}

type ClassDeclarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyClassDeclarationContext() *ClassDeclarationContext {
	var p = new(ClassDeclarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Java9ParserRULE_classDeclaration
	return p
}

func (*ClassDeclarationContext) IsClassDeclarationContext() {}

func NewClassDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ClassDeclarationContext {
	var p = new(ClassDeclarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java9ParserRULE_classDeclaration

	return p
}

func (s *ClassDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *ClassDeclarationContext) NormalClassDeclaration() INormalClassDeclarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INormalClassDeclarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INormalClassDeclarationContext)
}

func (s *ClassDeclarationContext) EnumDeclaration() IEnumDeclarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEnumDeclarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEnumDeclarationContext)
}

func (s *ClassDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ClassDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ClassDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.EnterClassDeclaration(s)
	}
}

func (s *ClassDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.ExitClassDeclaration(s)
	}
}

func (p *Java9Parser) ClassDeclaration() (localctx IClassDeclarationContext) {
	localctx = NewClassDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 92, Java9ParserRULE_classDeclaration)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(901)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 55, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(899)
			p.NormalClassDeclaration()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(900)
			p.EnumDeclaration()
		}

	}

	return localctx
}

// INormalClassDeclarationContext is an interface to support dynamic dispatch.
type INormalClassDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsNormalClassDeclarationContext differentiates from other interfaces.
	IsNormalClassDeclarationContext()
}

type NormalClassDeclarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNormalClassDeclarationContext() *NormalClassDeclarationContext {
	var p = new(NormalClassDeclarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Java9ParserRULE_normalClassDeclaration
	return p
}

func (*NormalClassDeclarationContext) IsNormalClassDeclarationContext() {}

func NewNormalClassDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NormalClassDeclarationContext {
	var p = new(NormalClassDeclarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java9ParserRULE_normalClassDeclaration

	return p
}

func (s *NormalClassDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *NormalClassDeclarationContext) CLASS() antlr.TerminalNode {
	return s.GetToken(Java9ParserCLASS, 0)
}

func (s *NormalClassDeclarationContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *NormalClassDeclarationContext) ClassBody() IClassBodyContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IClassBodyContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IClassBodyContext)
}

func (s *NormalClassDeclarationContext) AllClassModifier() []IClassModifierContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IClassModifierContext)(nil)).Elem())
	var tst = make([]IClassModifierContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IClassModifierContext)
		}
	}

	return tst
}

func (s *NormalClassDeclarationContext) ClassModifier(i int) IClassModifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IClassModifierContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IClassModifierContext)
}

func (s *NormalClassDeclarationContext) TypeParameters() ITypeParametersContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypeParametersContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITypeParametersContext)
}

func (s *NormalClassDeclarationContext) Superclass() ISuperclassContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISuperclassContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISuperclassContext)
}

func (s *NormalClassDeclarationContext) Superinterfaces() ISuperinterfacesContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISuperinterfacesContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISuperinterfacesContext)
}

func (s *NormalClassDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NormalClassDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NormalClassDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.EnterNormalClassDeclaration(s)
	}
}

func (s *NormalClassDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.ExitNormalClassDeclaration(s)
	}
}

func (p *Java9Parser) NormalClassDeclaration() (localctx INormalClassDeclarationContext) {
	localctx = NewNormalClassDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 94, Java9ParserRULE_normalClassDeclaration)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(906)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == Java9ParserABSTRACT || _la == Java9ParserFINAL || (((_la-37)&-(0x1f+1)) == 0 && ((1<<uint((_la-37)))&((1<<(Java9ParserPRIVATE-37))|(1<<(Java9ParserPROTECTED-37))|(1<<(Java9ParserPUBLIC-37))|(1<<(Java9ParserSTATIC-37))|(1<<(Java9ParserSTRICTFP-37)))) != 0) || _la == Java9ParserAT {
		{
			p.SetState(903)
			p.ClassModifier()
		}

		p.SetState(908)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(909)
		p.Match(Java9ParserCLASS)
	}
	{
		p.SetState(910)
		p.Identifier()
	}
	p.SetState(912)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Java9ParserLT {
		{
			p.SetState(911)
			p.TypeParameters()
		}

	}
	p.SetState(915)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Java9ParserEXTENDS {
		{
			p.SetState(914)
			p.Superclass()
		}

	}
	p.SetState(918)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Java9ParserIMPLEMENTS {
		{
			p.SetState(917)
			p.Superinterfaces()
		}

	}
	{
		p.SetState(920)
		p.ClassBody()
	}

	return localctx
}

// IClassModifierContext is an interface to support dynamic dispatch.
type IClassModifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsClassModifierContext differentiates from other interfaces.
	IsClassModifierContext()
}

type ClassModifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyClassModifierContext() *ClassModifierContext {
	var p = new(ClassModifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Java9ParserRULE_classModifier
	return p
}

func (*ClassModifierContext) IsClassModifierContext() {}

func NewClassModifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ClassModifierContext {
	var p = new(ClassModifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java9ParserRULE_classModifier

	return p
}

func (s *ClassModifierContext) GetParser() antlr.Parser { return s.parser }

func (s *ClassModifierContext) Annotation() IAnnotationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAnnotationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAnnotationContext)
}

func (s *ClassModifierContext) PUBLIC() antlr.TerminalNode {
	return s.GetToken(Java9ParserPUBLIC, 0)
}

func (s *ClassModifierContext) PROTECTED() antlr.TerminalNode {
	return s.GetToken(Java9ParserPROTECTED, 0)
}

func (s *ClassModifierContext) PRIVATE() antlr.TerminalNode {
	return s.GetToken(Java9ParserPRIVATE, 0)
}

func (s *ClassModifierContext) ABSTRACT() antlr.TerminalNode {
	return s.GetToken(Java9ParserABSTRACT, 0)
}

func (s *ClassModifierContext) STATIC() antlr.TerminalNode {
	return s.GetToken(Java9ParserSTATIC, 0)
}

func (s *ClassModifierContext) FINAL() antlr.TerminalNode {
	return s.GetToken(Java9ParserFINAL, 0)
}

func (s *ClassModifierContext) STRICTFP() antlr.TerminalNode {
	return s.GetToken(Java9ParserSTRICTFP, 0)
}

func (s *ClassModifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ClassModifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ClassModifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.EnterClassModifier(s)
	}
}

func (s *ClassModifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.ExitClassModifier(s)
	}
}

func (p *Java9Parser) ClassModifier() (localctx IClassModifierContext) {
	localctx = NewClassModifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 96, Java9ParserRULE_classModifier)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(930)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case Java9ParserAT:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(922)
			p.Annotation()
		}

	case Java9ParserPUBLIC:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(923)
			p.Match(Java9ParserPUBLIC)
		}

	case Java9ParserPROTECTED:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(924)
			p.Match(Java9ParserPROTECTED)
		}

	case Java9ParserPRIVATE:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(925)
			p.Match(Java9ParserPRIVATE)
		}

	case Java9ParserABSTRACT:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(926)
			p.Match(Java9ParserABSTRACT)
		}

	case Java9ParserSTATIC:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(927)
			p.Match(Java9ParserSTATIC)
		}

	case Java9ParserFINAL:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(928)
			p.Match(Java9ParserFINAL)
		}

	case Java9ParserSTRICTFP:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(929)
			p.Match(Java9ParserSTRICTFP)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ITypeParametersContext is an interface to support dynamic dispatch.
type ITypeParametersContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTypeParametersContext differentiates from other interfaces.
	IsTypeParametersContext()
}

type TypeParametersContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeParametersContext() *TypeParametersContext {
	var p = new(TypeParametersContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Java9ParserRULE_typeParameters
	return p
}

func (*TypeParametersContext) IsTypeParametersContext() {}

func NewTypeParametersContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeParametersContext {
	var p = new(TypeParametersContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java9ParserRULE_typeParameters

	return p
}

func (s *TypeParametersContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeParametersContext) LT() antlr.TerminalNode {
	return s.GetToken(Java9ParserLT, 0)
}

func (s *TypeParametersContext) TypeParameterList() ITypeParameterListContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypeParameterListContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITypeParameterListContext)
}

func (s *TypeParametersContext) GT() antlr.TerminalNode {
	return s.GetToken(Java9ParserGT, 0)
}

func (s *TypeParametersContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeParametersContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeParametersContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.EnterTypeParameters(s)
	}
}

func (s *TypeParametersContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.ExitTypeParameters(s)
	}
}

func (p *Java9Parser) TypeParameters() (localctx ITypeParametersContext) {
	localctx = NewTypeParametersContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 98, Java9ParserRULE_typeParameters)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(932)
		p.Match(Java9ParserLT)
	}
	{
		p.SetState(933)
		p.TypeParameterList()
	}
	{
		p.SetState(934)
		p.Match(Java9ParserGT)
	}

	return localctx
}

// ITypeParameterListContext is an interface to support dynamic dispatch.
type ITypeParameterListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTypeParameterListContext differentiates from other interfaces.
	IsTypeParameterListContext()
}

type TypeParameterListContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeParameterListContext() *TypeParameterListContext {
	var p = new(TypeParameterListContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Java9ParserRULE_typeParameterList
	return p
}

func (*TypeParameterListContext) IsTypeParameterListContext() {}

func NewTypeParameterListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeParameterListContext {
	var p = new(TypeParameterListContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java9ParserRULE_typeParameterList

	return p
}

func (s *TypeParameterListContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeParameterListContext) AllTypeParameter() []ITypeParameterContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ITypeParameterContext)(nil)).Elem())
	var tst = make([]ITypeParameterContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ITypeParameterContext)
		}
	}

	return tst
}

func (s *TypeParameterListContext) TypeParameter(i int) ITypeParameterContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypeParameterContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ITypeParameterContext)
}

func (s *TypeParameterListContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(Java9ParserCOMMA)
}

func (s *TypeParameterListContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(Java9ParserCOMMA, i)
}

func (s *TypeParameterListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeParameterListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeParameterListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.EnterTypeParameterList(s)
	}
}

func (s *TypeParameterListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.ExitTypeParameterList(s)
	}
}

func (p *Java9Parser) TypeParameterList() (localctx ITypeParameterListContext) {
	localctx = NewTypeParameterListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 100, Java9ParserRULE_typeParameterList)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(936)
		p.TypeParameter()
	}
	p.SetState(941)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == Java9ParserCOMMA {
		{
			p.SetState(937)
			p.Match(Java9ParserCOMMA)
		}
		{
			p.SetState(938)
			p.TypeParameter()
		}

		p.SetState(943)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// ISuperclassContext is an interface to support dynamic dispatch.
type ISuperclassContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSuperclassContext differentiates from other interfaces.
	IsSuperclassContext()
}

type SuperclassContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySuperclassContext() *SuperclassContext {
	var p = new(SuperclassContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Java9ParserRULE_superclass
	return p
}

func (*SuperclassContext) IsSuperclassContext() {}

func NewSuperclassContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SuperclassContext {
	var p = new(SuperclassContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java9ParserRULE_superclass

	return p
}

func (s *SuperclassContext) GetParser() antlr.Parser { return s.parser }

func (s *SuperclassContext) EXTENDS() antlr.TerminalNode {
	return s.GetToken(Java9ParserEXTENDS, 0)
}

func (s *SuperclassContext) ClassType() IClassTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IClassTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IClassTypeContext)
}

func (s *SuperclassContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SuperclassContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SuperclassContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.EnterSuperclass(s)
	}
}

func (s *SuperclassContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.ExitSuperclass(s)
	}
}

func (p *Java9Parser) Superclass() (localctx ISuperclassContext) {
	localctx = NewSuperclassContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 102, Java9ParserRULE_superclass)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(944)
		p.Match(Java9ParserEXTENDS)
	}
	{
		p.SetState(945)
		p.ClassType()
	}

	return localctx
}

// ISuperinterfacesContext is an interface to support dynamic dispatch.
type ISuperinterfacesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSuperinterfacesContext differentiates from other interfaces.
	IsSuperinterfacesContext()
}

type SuperinterfacesContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySuperinterfacesContext() *SuperinterfacesContext {
	var p = new(SuperinterfacesContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Java9ParserRULE_superinterfaces
	return p
}

func (*SuperinterfacesContext) IsSuperinterfacesContext() {}

func NewSuperinterfacesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SuperinterfacesContext {
	var p = new(SuperinterfacesContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java9ParserRULE_superinterfaces

	return p
}

func (s *SuperinterfacesContext) GetParser() antlr.Parser { return s.parser }

func (s *SuperinterfacesContext) IMPLEMENTS() antlr.TerminalNode {
	return s.GetToken(Java9ParserIMPLEMENTS, 0)
}

func (s *SuperinterfacesContext) InterfaceTypeList() IInterfaceTypeListContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInterfaceTypeListContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInterfaceTypeListContext)
}

func (s *SuperinterfacesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SuperinterfacesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SuperinterfacesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.EnterSuperinterfaces(s)
	}
}

func (s *SuperinterfacesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.ExitSuperinterfaces(s)
	}
}

func (p *Java9Parser) Superinterfaces() (localctx ISuperinterfacesContext) {
	localctx = NewSuperinterfacesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 104, Java9ParserRULE_superinterfaces)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(947)
		p.Match(Java9ParserIMPLEMENTS)
	}
	{
		p.SetState(948)
		p.InterfaceTypeList()
	}

	return localctx
}

// IInterfaceTypeListContext is an interface to support dynamic dispatch.
type IInterfaceTypeListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsInterfaceTypeListContext differentiates from other interfaces.
	IsInterfaceTypeListContext()
}

type InterfaceTypeListContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInterfaceTypeListContext() *InterfaceTypeListContext {
	var p = new(InterfaceTypeListContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Java9ParserRULE_interfaceTypeList
	return p
}

func (*InterfaceTypeListContext) IsInterfaceTypeListContext() {}

func NewInterfaceTypeListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InterfaceTypeListContext {
	var p = new(InterfaceTypeListContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java9ParserRULE_interfaceTypeList

	return p
}

func (s *InterfaceTypeListContext) GetParser() antlr.Parser { return s.parser }

func (s *InterfaceTypeListContext) AllInterfaceType() []IInterfaceTypeContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IInterfaceTypeContext)(nil)).Elem())
	var tst = make([]IInterfaceTypeContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IInterfaceTypeContext)
		}
	}

	return tst
}

func (s *InterfaceTypeListContext) InterfaceType(i int) IInterfaceTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInterfaceTypeContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IInterfaceTypeContext)
}

func (s *InterfaceTypeListContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(Java9ParserCOMMA)
}

func (s *InterfaceTypeListContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(Java9ParserCOMMA, i)
}

func (s *InterfaceTypeListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InterfaceTypeListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InterfaceTypeListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.EnterInterfaceTypeList(s)
	}
}

func (s *InterfaceTypeListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.ExitInterfaceTypeList(s)
	}
}

func (p *Java9Parser) InterfaceTypeList() (localctx IInterfaceTypeListContext) {
	localctx = NewInterfaceTypeListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 106, Java9ParserRULE_interfaceTypeList)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(950)
		p.InterfaceType()
	}
	p.SetState(955)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == Java9ParserCOMMA {
		{
			p.SetState(951)
			p.Match(Java9ParserCOMMA)
		}
		{
			p.SetState(952)
			p.InterfaceType()
		}

		p.SetState(957)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IClassBodyContext is an interface to support dynamic dispatch.
type IClassBodyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsClassBodyContext differentiates from other interfaces.
	IsClassBodyContext()
}

type ClassBodyContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyClassBodyContext() *ClassBodyContext {
	var p = new(ClassBodyContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Java9ParserRULE_classBody
	return p
}

func (*ClassBodyContext) IsClassBodyContext() {}

func NewClassBodyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ClassBodyContext {
	var p = new(ClassBodyContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java9ParserRULE_classBody

	return p
}

func (s *ClassBodyContext) GetParser() antlr.Parser { return s.parser }

func (s *ClassBodyContext) LBRACE() antlr.TerminalNode {
	return s.GetToken(Java9ParserLBRACE, 0)
}

func (s *ClassBodyContext) RBRACE() antlr.TerminalNode {
	return s.GetToken(Java9ParserRBRACE, 0)
}

func (s *ClassBodyContext) AllClassBodyDeclaration() []IClassBodyDeclarationContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IClassBodyDeclarationContext)(nil)).Elem())
	var tst = make([]IClassBodyDeclarationContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IClassBodyDeclarationContext)
		}
	}

	return tst
}

func (s *ClassBodyContext) ClassBodyDeclaration(i int) IClassBodyDeclarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IClassBodyDeclarationContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IClassBodyDeclarationContext)
}

func (s *ClassBodyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ClassBodyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ClassBodyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.EnterClassBody(s)
	}
}

func (s *ClassBodyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.ExitClassBody(s)
	}
}

func (p *Java9Parser) ClassBody() (localctx IClassBodyContext) {
	localctx = NewClassBodyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 108, Java9ParserRULE_classBody)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(958)
		p.Match(Java9ParserLBRACE)
	}
	p.SetState(962)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<Java9ParserABSTRACT)|(1<<Java9ParserBOOLEAN)|(1<<Java9ParserBYTE)|(1<<Java9ParserCHAR)|(1<<Java9ParserCLASS)|(1<<Java9ParserDOUBLE)|(1<<Java9ParserENUM)|(1<<Java9ParserEXPORTS)|(1<<Java9ParserFINAL)|(1<<Java9ParserFLOAT)|(1<<Java9ParserINT)|(1<<Java9ParserINTERFACE)|(1<<Java9ParserLONG)|(1<<Java9ParserMODULE))) != 0) || (((_la-32)&-(0x1f+1)) == 0 && ((1<<uint((_la-32)))&((1<<(Java9ParserNATIVE-32))|(1<<(Java9ParserOPEN-32))|(1<<(Java9ParserOPERNS-32))|(1<<(Java9ParserPRIVATE-32))|(1<<(Java9ParserPROTECTED-32))|(1<<(Java9ParserPROVIDES-32))|(1<<(Java9ParserPUBLIC-32))|(1<<(Java9ParserREQUIRES-32))|(1<<(Java9ParserSHORT-32))|(1<<(Java9ParserSTATIC-32))|(1<<(Java9ParserSTRICTFP-32))|(1<<(Java9ParserSYNCHRONIZED-32))|(1<<(Java9ParserTO-32))|(1<<(Java9ParserTRANSIENT-32))|(1<<(Java9ParserUSES-32))|(1<<(Java9ParserVOID-32))|(1<<(Java9ParserVOLATILE-32))|(1<<(Java9ParserWITH-32)))) != 0) || (((_la-70)&-(0x1f+1)) == 0 && ((1<<uint((_la-70)))&((1<<(Java9ParserLBRACE-70))|(1<<(Java9ParserSEMI-70))|(1<<(Java9ParserAT-70))|(1<<(Java9ParserLT-70)))) != 0) || _la == Java9ParserIdentifier {
		{
			p.SetState(959)
			p.ClassBodyDeclaration()
		}

		p.SetState(964)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(965)
		p.Match(Java9ParserRBRACE)
	}

	return localctx
}

// IClassBodyDeclarationContext is an interface to support dynamic dispatch.
type IClassBodyDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsClassBodyDeclarationContext differentiates from other interfaces.
	IsClassBodyDeclarationContext()
}

type ClassBodyDeclarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyClassBodyDeclarationContext() *ClassBodyDeclarationContext {
	var p = new(ClassBodyDeclarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Java9ParserRULE_classBodyDeclaration
	return p
}

func (*ClassBodyDeclarationContext) IsClassBodyDeclarationContext() {}

func NewClassBodyDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ClassBodyDeclarationContext {
	var p = new(ClassBodyDeclarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java9ParserRULE_classBodyDeclaration

	return p
}

func (s *ClassBodyDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *ClassBodyDeclarationContext) ClassMemberDeclaration() IClassMemberDeclarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IClassMemberDeclarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IClassMemberDeclarationContext)
}

func (s *ClassBodyDeclarationContext) InstanceInitializer() IInstanceInitializerContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInstanceInitializerContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInstanceInitializerContext)
}

func (s *ClassBodyDeclarationContext) StaticInitializer() IStaticInitializerContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStaticInitializerContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IStaticInitializerContext)
}

func (s *ClassBodyDeclarationContext) ConstructorDeclaration() IConstructorDeclarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConstructorDeclarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConstructorDeclarationContext)
}

func (s *ClassBodyDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ClassBodyDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ClassBodyDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.EnterClassBodyDeclaration(s)
	}
}

func (s *ClassBodyDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.ExitClassBodyDeclaration(s)
	}
}

func (p *Java9Parser) ClassBodyDeclaration() (localctx IClassBodyDeclarationContext) {
	localctx = NewClassBodyDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 110, Java9ParserRULE_classBodyDeclaration)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(971)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 64, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(967)
			p.ClassMemberDeclaration()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(968)
			p.InstanceInitializer()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(969)
			p.StaticInitializer()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(970)
			p.ConstructorDeclaration()
		}

	}

	return localctx
}

// IClassMemberDeclarationContext is an interface to support dynamic dispatch.
type IClassMemberDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsClassMemberDeclarationContext differentiates from other interfaces.
	IsClassMemberDeclarationContext()
}

type ClassMemberDeclarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyClassMemberDeclarationContext() *ClassMemberDeclarationContext {
	var p = new(ClassMemberDeclarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Java9ParserRULE_classMemberDeclaration
	return p
}

func (*ClassMemberDeclarationContext) IsClassMemberDeclarationContext() {}

func NewClassMemberDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ClassMemberDeclarationContext {
	var p = new(ClassMemberDeclarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java9ParserRULE_classMemberDeclaration

	return p
}

func (s *ClassMemberDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *ClassMemberDeclarationContext) FieldDeclaration() IFieldDeclarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFieldDeclarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFieldDeclarationContext)
}

func (s *ClassMemberDeclarationContext) MethodDeclaration() IMethodDeclarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMethodDeclarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMethodDeclarationContext)
}

func (s *ClassMemberDeclarationContext) ClassDeclaration() IClassDeclarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IClassDeclarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IClassDeclarationContext)
}

func (s *ClassMemberDeclarationContext) InterfaceDeclaration() IInterfaceDeclarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInterfaceDeclarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInterfaceDeclarationContext)
}

func (s *ClassMemberDeclarationContext) SEMI() antlr.TerminalNode {
	return s.GetToken(Java9ParserSEMI, 0)
}

func (s *ClassMemberDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ClassMemberDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ClassMemberDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.EnterClassMemberDeclaration(s)
	}
}

func (s *ClassMemberDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.ExitClassMemberDeclaration(s)
	}
}

func (p *Java9Parser) ClassMemberDeclaration() (localctx IClassMemberDeclarationContext) {
	localctx = NewClassMemberDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 112, Java9ParserRULE_classMemberDeclaration)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(978)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 65, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(973)
			p.FieldDeclaration()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(974)
			p.MethodDeclaration()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(975)
			p.ClassDeclaration()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(976)
			p.InterfaceDeclaration()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(977)
			p.Match(Java9ParserSEMI)
		}

	}

	return localctx
}

// IFieldDeclarationContext is an interface to support dynamic dispatch.
type IFieldDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFieldDeclarationContext differentiates from other interfaces.
	IsFieldDeclarationContext()
}

type FieldDeclarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFieldDeclarationContext() *FieldDeclarationContext {
	var p = new(FieldDeclarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Java9ParserRULE_fieldDeclaration
	return p
}

func (*FieldDeclarationContext) IsFieldDeclarationContext() {}

func NewFieldDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FieldDeclarationContext {
	var p = new(FieldDeclarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java9ParserRULE_fieldDeclaration

	return p
}

func (s *FieldDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *FieldDeclarationContext) UnannType() IUnannTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUnannTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IUnannTypeContext)
}

func (s *FieldDeclarationContext) VariableDeclaratorList() IVariableDeclaratorListContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVariableDeclaratorListContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IVariableDeclaratorListContext)
}

func (s *FieldDeclarationContext) SEMI() antlr.TerminalNode {
	return s.GetToken(Java9ParserSEMI, 0)
}

func (s *FieldDeclarationContext) AllFieldModifier() []IFieldModifierContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IFieldModifierContext)(nil)).Elem())
	var tst = make([]IFieldModifierContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IFieldModifierContext)
		}
	}

	return tst
}

func (s *FieldDeclarationContext) FieldModifier(i int) IFieldModifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFieldModifierContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IFieldModifierContext)
}

func (s *FieldDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FieldDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FieldDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.EnterFieldDeclaration(s)
	}
}

func (s *FieldDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.ExitFieldDeclaration(s)
	}
}

func (p *Java9Parser) FieldDeclaration() (localctx IFieldDeclarationContext) {
	localctx = NewFieldDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 114, Java9ParserRULE_fieldDeclaration)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(983)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for (((_la-19)&-(0x1f+1)) == 0 && ((1<<uint((_la-19)))&((1<<(Java9ParserFINAL-19))|(1<<(Java9ParserPRIVATE-19))|(1<<(Java9ParserPROTECTED-19))|(1<<(Java9ParserPUBLIC-19))|(1<<(Java9ParserSTATIC-19)))) != 0) || (((_la-53)&-(0x1f+1)) == 0 && ((1<<uint((_la-53)))&((1<<(Java9ParserTRANSIENT-53))|(1<<(Java9ParserVOLATILE-53))|(1<<(Java9ParserAT-53)))) != 0) {
		{
			p.SetState(980)
			p.FieldModifier()
		}

		p.SetState(985)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(986)
		p.UnannType()
	}
	{
		p.SetState(987)
		p.VariableDeclaratorList()
	}
	{
		p.SetState(988)
		p.Match(Java9ParserSEMI)
	}

	return localctx
}

// IFieldModifierContext is an interface to support dynamic dispatch.
type IFieldModifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFieldModifierContext differentiates from other interfaces.
	IsFieldModifierContext()
}

type FieldModifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFieldModifierContext() *FieldModifierContext {
	var p = new(FieldModifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Java9ParserRULE_fieldModifier
	return p
}

func (*FieldModifierContext) IsFieldModifierContext() {}

func NewFieldModifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FieldModifierContext {
	var p = new(FieldModifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java9ParserRULE_fieldModifier

	return p
}

func (s *FieldModifierContext) GetParser() antlr.Parser { return s.parser }

func (s *FieldModifierContext) Annotation() IAnnotationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAnnotationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAnnotationContext)
}

func (s *FieldModifierContext) PUBLIC() antlr.TerminalNode {
	return s.GetToken(Java9ParserPUBLIC, 0)
}

func (s *FieldModifierContext) PROTECTED() antlr.TerminalNode {
	return s.GetToken(Java9ParserPROTECTED, 0)
}

func (s *FieldModifierContext) PRIVATE() antlr.TerminalNode {
	return s.GetToken(Java9ParserPRIVATE, 0)
}

func (s *FieldModifierContext) STATIC() antlr.TerminalNode {
	return s.GetToken(Java9ParserSTATIC, 0)
}

func (s *FieldModifierContext) FINAL() antlr.TerminalNode {
	return s.GetToken(Java9ParserFINAL, 0)
}

func (s *FieldModifierContext) TRANSIENT() antlr.TerminalNode {
	return s.GetToken(Java9ParserTRANSIENT, 0)
}

func (s *FieldModifierContext) VOLATILE() antlr.TerminalNode {
	return s.GetToken(Java9ParserVOLATILE, 0)
}

func (s *FieldModifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FieldModifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FieldModifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.EnterFieldModifier(s)
	}
}

func (s *FieldModifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.ExitFieldModifier(s)
	}
}

func (p *Java9Parser) FieldModifier() (localctx IFieldModifierContext) {
	localctx = NewFieldModifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 116, Java9ParserRULE_fieldModifier)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(998)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case Java9ParserAT:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(990)
			p.Annotation()
		}

	case Java9ParserPUBLIC:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(991)
			p.Match(Java9ParserPUBLIC)
		}

	case Java9ParserPROTECTED:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(992)
			p.Match(Java9ParserPROTECTED)
		}

	case Java9ParserPRIVATE:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(993)
			p.Match(Java9ParserPRIVATE)
		}

	case Java9ParserSTATIC:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(994)
			p.Match(Java9ParserSTATIC)
		}

	case Java9ParserFINAL:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(995)
			p.Match(Java9ParserFINAL)
		}

	case Java9ParserTRANSIENT:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(996)
			p.Match(Java9ParserTRANSIENT)
		}

	case Java9ParserVOLATILE:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(997)
			p.Match(Java9ParserVOLATILE)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IVariableDeclaratorListContext is an interface to support dynamic dispatch.
type IVariableDeclaratorListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsVariableDeclaratorListContext differentiates from other interfaces.
	IsVariableDeclaratorListContext()
}

type VariableDeclaratorListContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyVariableDeclaratorListContext() *VariableDeclaratorListContext {
	var p = new(VariableDeclaratorListContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Java9ParserRULE_variableDeclaratorList
	return p
}

func (*VariableDeclaratorListContext) IsVariableDeclaratorListContext() {}

func NewVariableDeclaratorListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *VariableDeclaratorListContext {
	var p = new(VariableDeclaratorListContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java9ParserRULE_variableDeclaratorList

	return p
}

func (s *VariableDeclaratorListContext) GetParser() antlr.Parser { return s.parser }

func (s *VariableDeclaratorListContext) AllVariableDeclarator() []IVariableDeclaratorContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IVariableDeclaratorContext)(nil)).Elem())
	var tst = make([]IVariableDeclaratorContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IVariableDeclaratorContext)
		}
	}

	return tst
}

func (s *VariableDeclaratorListContext) VariableDeclarator(i int) IVariableDeclaratorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVariableDeclaratorContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IVariableDeclaratorContext)
}

func (s *VariableDeclaratorListContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(Java9ParserCOMMA)
}

func (s *VariableDeclaratorListContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(Java9ParserCOMMA, i)
}

func (s *VariableDeclaratorListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VariableDeclaratorListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *VariableDeclaratorListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.EnterVariableDeclaratorList(s)
	}
}

func (s *VariableDeclaratorListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.ExitVariableDeclaratorList(s)
	}
}

func (p *Java9Parser) VariableDeclaratorList() (localctx IVariableDeclaratorListContext) {
	localctx = NewVariableDeclaratorListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 118, Java9ParserRULE_variableDeclaratorList)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1000)
		p.VariableDeclarator()
	}
	p.SetState(1005)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == Java9ParserCOMMA {
		{
			p.SetState(1001)
			p.Match(Java9ParserCOMMA)
		}
		{
			p.SetState(1002)
			p.VariableDeclarator()
		}

		p.SetState(1007)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IVariableDeclaratorContext is an interface to support dynamic dispatch.
type IVariableDeclaratorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsVariableDeclaratorContext differentiates from other interfaces.
	IsVariableDeclaratorContext()
}

type VariableDeclaratorContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyVariableDeclaratorContext() *VariableDeclaratorContext {
	var p = new(VariableDeclaratorContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Java9ParserRULE_variableDeclarator
	return p
}

func (*VariableDeclaratorContext) IsVariableDeclaratorContext() {}

func NewVariableDeclaratorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *VariableDeclaratorContext {
	var p = new(VariableDeclaratorContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java9ParserRULE_variableDeclarator

	return p
}

func (s *VariableDeclaratorContext) GetParser() antlr.Parser { return s.parser }

func (s *VariableDeclaratorContext) VariableDeclaratorId() IVariableDeclaratorIdContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVariableDeclaratorIdContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IVariableDeclaratorIdContext)
}

func (s *VariableDeclaratorContext) ASSIGN() antlr.TerminalNode {
	return s.GetToken(Java9ParserASSIGN, 0)
}

func (s *VariableDeclaratorContext) VariableInitializer() IVariableInitializerContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVariableInitializerContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IVariableInitializerContext)
}

func (s *VariableDeclaratorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VariableDeclaratorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *VariableDeclaratorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.EnterVariableDeclarator(s)
	}
}

func (s *VariableDeclaratorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.ExitVariableDeclarator(s)
	}
}

func (p *Java9Parser) VariableDeclarator() (localctx IVariableDeclaratorContext) {
	localctx = NewVariableDeclaratorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 120, Java9ParserRULE_variableDeclarator)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1008)
		p.VariableDeclaratorId()
	}
	p.SetState(1011)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Java9ParserASSIGN {
		{
			p.SetState(1009)
			p.Match(Java9ParserASSIGN)
		}
		{
			p.SetState(1010)
			p.VariableInitializer()
		}

	}

	return localctx
}

// IVariableDeclaratorIdContext is an interface to support dynamic dispatch.
type IVariableDeclaratorIdContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsVariableDeclaratorIdContext differentiates from other interfaces.
	IsVariableDeclaratorIdContext()
}

type VariableDeclaratorIdContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyVariableDeclaratorIdContext() *VariableDeclaratorIdContext {
	var p = new(VariableDeclaratorIdContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Java9ParserRULE_variableDeclaratorId
	return p
}

func (*VariableDeclaratorIdContext) IsVariableDeclaratorIdContext() {}

func NewVariableDeclaratorIdContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *VariableDeclaratorIdContext {
	var p = new(VariableDeclaratorIdContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java9ParserRULE_variableDeclaratorId

	return p
}

func (s *VariableDeclaratorIdContext) GetParser() antlr.Parser { return s.parser }

func (s *VariableDeclaratorIdContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *VariableDeclaratorIdContext) Dims() IDimsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDimsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDimsContext)
}

func (s *VariableDeclaratorIdContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VariableDeclaratorIdContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *VariableDeclaratorIdContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.EnterVariableDeclaratorId(s)
	}
}

func (s *VariableDeclaratorIdContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.ExitVariableDeclaratorId(s)
	}
}

func (p *Java9Parser) VariableDeclaratorId() (localctx IVariableDeclaratorIdContext) {
	localctx = NewVariableDeclaratorIdContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 122, Java9ParserRULE_variableDeclaratorId)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1013)
		p.Identifier()
	}
	p.SetState(1015)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Java9ParserLBRACK || _la == Java9ParserAT {
		{
			p.SetState(1014)
			p.Dims()
		}

	}

	return localctx
}

// IVariableInitializerContext is an interface to support dynamic dispatch.
type IVariableInitializerContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsVariableInitializerContext differentiates from other interfaces.
	IsVariableInitializerContext()
}

type VariableInitializerContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyVariableInitializerContext() *VariableInitializerContext {
	var p = new(VariableInitializerContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Java9ParserRULE_variableInitializer
	return p
}

func (*VariableInitializerContext) IsVariableInitializerContext() {}

func NewVariableInitializerContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *VariableInitializerContext {
	var p = new(VariableInitializerContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java9ParserRULE_variableInitializer

	return p
}

func (s *VariableInitializerContext) GetParser() antlr.Parser { return s.parser }

func (s *VariableInitializerContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *VariableInitializerContext) ArrayInitializer() IArrayInitializerContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IArrayInitializerContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IArrayInitializerContext)
}

func (s *VariableInitializerContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VariableInitializerContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *VariableInitializerContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.EnterVariableInitializer(s)
	}
}

func (s *VariableInitializerContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.ExitVariableInitializer(s)
	}
}

func (p *Java9Parser) VariableInitializer() (localctx IVariableInitializerContext) {
	localctx = NewVariableInitializerContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 124, Java9ParserRULE_variableInitializer)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1019)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case Java9ParserBOOLEAN, Java9ParserBYTE, Java9ParserCHAR, Java9ParserDOUBLE, Java9ParserEXPORTS, Java9ParserFLOAT, Java9ParserINT, Java9ParserLONG, Java9ParserMODULE, Java9ParserNEW, Java9ParserOPEN, Java9ParserOPERNS, Java9ParserPROVIDES, Java9ParserREQUIRES, Java9ParserSHORT, Java9ParserSUPER, Java9ParserTHIS, Java9ParserTO, Java9ParserUSES, Java9ParserVOID, Java9ParserWITH, Java9ParserIntegerLiteral, Java9ParserFloatingPointLiteral, Java9ParserBooleanLiteral, Java9ParserCharacterLiteral, Java9ParserStringLiteral, Java9ParserNullLiteral, Java9ParserLPAREN, Java9ParserAT, Java9ParserBANG, Java9ParserTILDE, Java9ParserINC, Java9ParserDEC, Java9ParserADD, Java9ParserSUB, Java9ParserIdentifier:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1017)
			p.Expression()
		}

	case Java9ParserLBRACE:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1018)
			p.ArrayInitializer()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IUnannTypeContext is an interface to support dynamic dispatch.
type IUnannTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsUnannTypeContext differentiates from other interfaces.
	IsUnannTypeContext()
}

type UnannTypeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUnannTypeContext() *UnannTypeContext {
	var p = new(UnannTypeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Java9ParserRULE_unannType
	return p
}

func (*UnannTypeContext) IsUnannTypeContext() {}

func NewUnannTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UnannTypeContext {
	var p = new(UnannTypeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java9ParserRULE_unannType

	return p
}

func (s *UnannTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *UnannTypeContext) UnannPrimitiveType() IUnannPrimitiveTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUnannPrimitiveTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IUnannPrimitiveTypeContext)
}

func (s *UnannTypeContext) UnannReferenceType() IUnannReferenceTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUnannReferenceTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IUnannReferenceTypeContext)
}

func (s *UnannTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnannTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UnannTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.EnterUnannType(s)
	}
}

func (s *UnannTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.ExitUnannType(s)
	}
}

func (p *Java9Parser) UnannType() (localctx IUnannTypeContext) {
	localctx = NewUnannTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 126, Java9ParserRULE_unannType)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1023)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 72, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1021)
			p.UnannPrimitiveType()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1022)
			p.UnannReferenceType()
		}

	}

	return localctx
}

// IUnannPrimitiveTypeContext is an interface to support dynamic dispatch.
type IUnannPrimitiveTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsUnannPrimitiveTypeContext differentiates from other interfaces.
	IsUnannPrimitiveTypeContext()
}

type UnannPrimitiveTypeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUnannPrimitiveTypeContext() *UnannPrimitiveTypeContext {
	var p = new(UnannPrimitiveTypeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Java9ParserRULE_unannPrimitiveType
	return p
}

func (*UnannPrimitiveTypeContext) IsUnannPrimitiveTypeContext() {}

func NewUnannPrimitiveTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UnannPrimitiveTypeContext {
	var p = new(UnannPrimitiveTypeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java9ParserRULE_unannPrimitiveType

	return p
}

func (s *UnannPrimitiveTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *UnannPrimitiveTypeContext) NumericType() INumericTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INumericTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INumericTypeContext)
}

func (s *UnannPrimitiveTypeContext) BOOLEAN() antlr.TerminalNode {
	return s.GetToken(Java9ParserBOOLEAN, 0)
}

func (s *UnannPrimitiveTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnannPrimitiveTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UnannPrimitiveTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.EnterUnannPrimitiveType(s)
	}
}

func (s *UnannPrimitiveTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.ExitUnannPrimitiveType(s)
	}
}

func (p *Java9Parser) UnannPrimitiveType() (localctx IUnannPrimitiveTypeContext) {
	localctx = NewUnannPrimitiveTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 128, Java9ParserRULE_unannPrimitiveType)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1027)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case Java9ParserBYTE, Java9ParserCHAR, Java9ParserDOUBLE, Java9ParserFLOAT, Java9ParserINT, Java9ParserLONG, Java9ParserSHORT:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1025)
			p.NumericType()
		}

	case Java9ParserBOOLEAN:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1026)
			p.Match(Java9ParserBOOLEAN)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IUnannReferenceTypeContext is an interface to support dynamic dispatch.
type IUnannReferenceTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsUnannReferenceTypeContext differentiates from other interfaces.
	IsUnannReferenceTypeContext()
}

type UnannReferenceTypeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUnannReferenceTypeContext() *UnannReferenceTypeContext {
	var p = new(UnannReferenceTypeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Java9ParserRULE_unannReferenceType
	return p
}

func (*UnannReferenceTypeContext) IsUnannReferenceTypeContext() {}

func NewUnannReferenceTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UnannReferenceTypeContext {
	var p = new(UnannReferenceTypeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java9ParserRULE_unannReferenceType

	return p
}

func (s *UnannReferenceTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *UnannReferenceTypeContext) UnannClassOrInterfaceType() IUnannClassOrInterfaceTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUnannClassOrInterfaceTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IUnannClassOrInterfaceTypeContext)
}

func (s *UnannReferenceTypeContext) UnannTypeVariable() IUnannTypeVariableContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUnannTypeVariableContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IUnannTypeVariableContext)
}

func (s *UnannReferenceTypeContext) UnannArrayType() IUnannArrayTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUnannArrayTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IUnannArrayTypeContext)
}

func (s *UnannReferenceTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnannReferenceTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UnannReferenceTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.EnterUnannReferenceType(s)
	}
}

func (s *UnannReferenceTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.ExitUnannReferenceType(s)
	}
}

func (p *Java9Parser) UnannReferenceType() (localctx IUnannReferenceTypeContext) {
	localctx = NewUnannReferenceTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 130, Java9ParserRULE_unannReferenceType)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1032)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 74, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1029)
			p.UnannClassOrInterfaceType()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1030)
			p.UnannTypeVariable()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1031)
			p.UnannArrayType()
		}

	}

	return localctx
}

// IUnannClassOrInterfaceTypeContext is an interface to support dynamic dispatch.
type IUnannClassOrInterfaceTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsUnannClassOrInterfaceTypeContext differentiates from other interfaces.
	IsUnannClassOrInterfaceTypeContext()
}

type UnannClassOrInterfaceTypeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUnannClassOrInterfaceTypeContext() *UnannClassOrInterfaceTypeContext {
	var p = new(UnannClassOrInterfaceTypeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Java9ParserRULE_unannClassOrInterfaceType
	return p
}

func (*UnannClassOrInterfaceTypeContext) IsUnannClassOrInterfaceTypeContext() {}

func NewUnannClassOrInterfaceTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UnannClassOrInterfaceTypeContext {
	var p = new(UnannClassOrInterfaceTypeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java9ParserRULE_unannClassOrInterfaceType

	return p
}

func (s *UnannClassOrInterfaceTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *UnannClassOrInterfaceTypeContext) UnannClassType_lfno_unannClassOrInterfaceType() IUnannClassType_lfno_unannClassOrInterfaceTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUnannClassType_lfno_unannClassOrInterfaceTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IUnannClassType_lfno_unannClassOrInterfaceTypeContext)
}

func (s *UnannClassOrInterfaceTypeContext) UnannInterfaceType_lfno_unannClassOrInterfaceType() IUnannInterfaceType_lfno_unannClassOrInterfaceTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUnannInterfaceType_lfno_unannClassOrInterfaceTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IUnannInterfaceType_lfno_unannClassOrInterfaceTypeContext)
}

func (s *UnannClassOrInterfaceTypeContext) AllUnannClassType_lf_unannClassOrInterfaceType() []IUnannClassType_lf_unannClassOrInterfaceTypeContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IUnannClassType_lf_unannClassOrInterfaceTypeContext)(nil)).Elem())
	var tst = make([]IUnannClassType_lf_unannClassOrInterfaceTypeContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IUnannClassType_lf_unannClassOrInterfaceTypeContext)
		}
	}

	return tst
}

func (s *UnannClassOrInterfaceTypeContext) UnannClassType_lf_unannClassOrInterfaceType(i int) IUnannClassType_lf_unannClassOrInterfaceTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUnannClassType_lf_unannClassOrInterfaceTypeContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IUnannClassType_lf_unannClassOrInterfaceTypeContext)
}

func (s *UnannClassOrInterfaceTypeContext) AllUnannInterfaceType_lf_unannClassOrInterfaceType() []IUnannInterfaceType_lf_unannClassOrInterfaceTypeContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IUnannInterfaceType_lf_unannClassOrInterfaceTypeContext)(nil)).Elem())
	var tst = make([]IUnannInterfaceType_lf_unannClassOrInterfaceTypeContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IUnannInterfaceType_lf_unannClassOrInterfaceTypeContext)
		}
	}

	return tst
}

func (s *UnannClassOrInterfaceTypeContext) UnannInterfaceType_lf_unannClassOrInterfaceType(i int) IUnannInterfaceType_lf_unannClassOrInterfaceTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUnannInterfaceType_lf_unannClassOrInterfaceTypeContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IUnannInterfaceType_lf_unannClassOrInterfaceTypeContext)
}

func (s *UnannClassOrInterfaceTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnannClassOrInterfaceTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UnannClassOrInterfaceTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.EnterUnannClassOrInterfaceType(s)
	}
}

func (s *UnannClassOrInterfaceTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.ExitUnannClassOrInterfaceType(s)
	}
}

func (p *Java9Parser) UnannClassOrInterfaceType() (localctx IUnannClassOrInterfaceTypeContext) {
	localctx = NewUnannClassOrInterfaceTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 132, Java9ParserRULE_unannClassOrInterfaceType)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1036)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 75, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(1034)
			p.UnannClassType_lfno_unannClassOrInterfaceType()
		}

	case 2:
		{
			p.SetState(1035)
			p.UnannInterfaceType_lfno_unannClassOrInterfaceType()
		}

	}
	p.SetState(1042)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 77, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			p.SetState(1040)
			p.GetErrorHandler().Sync(p)
			switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 76, p.GetParserRuleContext()) {
			case 1:
				{
					p.SetState(1038)
					p.UnannClassType_lf_unannClassOrInterfaceType()
				}

			case 2:
				{
					p.SetState(1039)
					p.UnannInterfaceType_lf_unannClassOrInterfaceType()
				}

			}

		}
		p.SetState(1044)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 77, p.GetParserRuleContext())
	}

	return localctx
}

// IUnannClassTypeContext is an interface to support dynamic dispatch.
type IUnannClassTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsUnannClassTypeContext differentiates from other interfaces.
	IsUnannClassTypeContext()
}

type UnannClassTypeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUnannClassTypeContext() *UnannClassTypeContext {
	var p = new(UnannClassTypeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Java9ParserRULE_unannClassType
	return p
}

func (*UnannClassTypeContext) IsUnannClassTypeContext() {}

func NewUnannClassTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UnannClassTypeContext {
	var p = new(UnannClassTypeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java9ParserRULE_unannClassType

	return p
}

func (s *UnannClassTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *UnannClassTypeContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *UnannClassTypeContext) TypeArguments() ITypeArgumentsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypeArgumentsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITypeArgumentsContext)
}

func (s *UnannClassTypeContext) UnannClassOrInterfaceType() IUnannClassOrInterfaceTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUnannClassOrInterfaceTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IUnannClassOrInterfaceTypeContext)
}

func (s *UnannClassTypeContext) DOT() antlr.TerminalNode {
	return s.GetToken(Java9ParserDOT, 0)
}

func (s *UnannClassTypeContext) AllAnnotation() []IAnnotationContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAnnotationContext)(nil)).Elem())
	var tst = make([]IAnnotationContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAnnotationContext)
		}
	}

	return tst
}

func (s *UnannClassTypeContext) Annotation(i int) IAnnotationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAnnotationContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAnnotationContext)
}

func (s *UnannClassTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnannClassTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UnannClassTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.EnterUnannClassType(s)
	}
}

func (s *UnannClassTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.ExitUnannClassType(s)
	}
}

func (p *Java9Parser) UnannClassType() (localctx IUnannClassTypeContext) {
	localctx = NewUnannClassTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 134, Java9ParserRULE_unannClassType)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1061)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 81, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1045)
			p.Identifier()
		}
		p.SetState(1047)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == Java9ParserLT {
			{
				p.SetState(1046)
				p.TypeArguments()
			}

		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1049)
			p.UnannClassOrInterfaceType()
		}
		{
			p.SetState(1050)
			p.Match(Java9ParserDOT)
		}
		p.SetState(1054)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == Java9ParserAT {
			{
				p.SetState(1051)
				p.Annotation()
			}

			p.SetState(1056)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1057)
			p.Identifier()
		}
		p.SetState(1059)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == Java9ParserLT {
			{
				p.SetState(1058)
				p.TypeArguments()
			}

		}

	}

	return localctx
}

// IUnannClassType_lf_unannClassOrInterfaceTypeContext is an interface to support dynamic dispatch.
type IUnannClassType_lf_unannClassOrInterfaceTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsUnannClassType_lf_unannClassOrInterfaceTypeContext differentiates from other interfaces.
	IsUnannClassType_lf_unannClassOrInterfaceTypeContext()
}

type UnannClassType_lf_unannClassOrInterfaceTypeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUnannClassType_lf_unannClassOrInterfaceTypeContext() *UnannClassType_lf_unannClassOrInterfaceTypeContext {
	var p = new(UnannClassType_lf_unannClassOrInterfaceTypeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Java9ParserRULE_unannClassType_lf_unannClassOrInterfaceType
	return p
}

func (*UnannClassType_lf_unannClassOrInterfaceTypeContext) IsUnannClassType_lf_unannClassOrInterfaceTypeContext() {
}

func NewUnannClassType_lf_unannClassOrInterfaceTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UnannClassType_lf_unannClassOrInterfaceTypeContext {
	var p = new(UnannClassType_lf_unannClassOrInterfaceTypeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java9ParserRULE_unannClassType_lf_unannClassOrInterfaceType

	return p
}

func (s *UnannClassType_lf_unannClassOrInterfaceTypeContext) GetParser() antlr.Parser {
	return s.parser
}

func (s *UnannClassType_lf_unannClassOrInterfaceTypeContext) DOT() antlr.TerminalNode {
	return s.GetToken(Java9ParserDOT, 0)
}

func (s *UnannClassType_lf_unannClassOrInterfaceTypeContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *UnannClassType_lf_unannClassOrInterfaceTypeContext) AllAnnotation() []IAnnotationContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAnnotationContext)(nil)).Elem())
	var tst = make([]IAnnotationContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAnnotationContext)
		}
	}

	return tst
}

func (s *UnannClassType_lf_unannClassOrInterfaceTypeContext) Annotation(i int) IAnnotationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAnnotationContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAnnotationContext)
}

func (s *UnannClassType_lf_unannClassOrInterfaceTypeContext) TypeArguments() ITypeArgumentsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypeArgumentsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITypeArgumentsContext)
}

func (s *UnannClassType_lf_unannClassOrInterfaceTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnannClassType_lf_unannClassOrInterfaceTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UnannClassType_lf_unannClassOrInterfaceTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.EnterUnannClassType_lf_unannClassOrInterfaceType(s)
	}
}

func (s *UnannClassType_lf_unannClassOrInterfaceTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.ExitUnannClassType_lf_unannClassOrInterfaceType(s)
	}
}

func (p *Java9Parser) UnannClassType_lf_unannClassOrInterfaceType() (localctx IUnannClassType_lf_unannClassOrInterfaceTypeContext) {
	localctx = NewUnannClassType_lf_unannClassOrInterfaceTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 136, Java9ParserRULE_unannClassType_lf_unannClassOrInterfaceType)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1063)
		p.Match(Java9ParserDOT)
	}
	p.SetState(1067)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == Java9ParserAT {
		{
			p.SetState(1064)
			p.Annotation()
		}

		p.SetState(1069)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1070)
		p.Identifier()
	}
	p.SetState(1072)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Java9ParserLT {
		{
			p.SetState(1071)
			p.TypeArguments()
		}

	}

	return localctx
}

// IUnannClassType_lfno_unannClassOrInterfaceTypeContext is an interface to support dynamic dispatch.
type IUnannClassType_lfno_unannClassOrInterfaceTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsUnannClassType_lfno_unannClassOrInterfaceTypeContext differentiates from other interfaces.
	IsUnannClassType_lfno_unannClassOrInterfaceTypeContext()
}

type UnannClassType_lfno_unannClassOrInterfaceTypeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUnannClassType_lfno_unannClassOrInterfaceTypeContext() *UnannClassType_lfno_unannClassOrInterfaceTypeContext {
	var p = new(UnannClassType_lfno_unannClassOrInterfaceTypeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Java9ParserRULE_unannClassType_lfno_unannClassOrInterfaceType
	return p
}

func (*UnannClassType_lfno_unannClassOrInterfaceTypeContext) IsUnannClassType_lfno_unannClassOrInterfaceTypeContext() {
}

func NewUnannClassType_lfno_unannClassOrInterfaceTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UnannClassType_lfno_unannClassOrInterfaceTypeContext {
	var p = new(UnannClassType_lfno_unannClassOrInterfaceTypeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java9ParserRULE_unannClassType_lfno_unannClassOrInterfaceType

	return p
}

func (s *UnannClassType_lfno_unannClassOrInterfaceTypeContext) GetParser() antlr.Parser {
	return s.parser
}

func (s *UnannClassType_lfno_unannClassOrInterfaceTypeContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *UnannClassType_lfno_unannClassOrInterfaceTypeContext) TypeArguments() ITypeArgumentsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypeArgumentsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITypeArgumentsContext)
}

func (s *UnannClassType_lfno_unannClassOrInterfaceTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnannClassType_lfno_unannClassOrInterfaceTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UnannClassType_lfno_unannClassOrInterfaceTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.EnterUnannClassType_lfno_unannClassOrInterfaceType(s)
	}
}

func (s *UnannClassType_lfno_unannClassOrInterfaceTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.ExitUnannClassType_lfno_unannClassOrInterfaceType(s)
	}
}

func (p *Java9Parser) UnannClassType_lfno_unannClassOrInterfaceType() (localctx IUnannClassType_lfno_unannClassOrInterfaceTypeContext) {
	localctx = NewUnannClassType_lfno_unannClassOrInterfaceTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 138, Java9ParserRULE_unannClassType_lfno_unannClassOrInterfaceType)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1074)
		p.Identifier()
	}
	p.SetState(1076)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Java9ParserLT {
		{
			p.SetState(1075)
			p.TypeArguments()
		}

	}

	return localctx
}

// IUnannInterfaceTypeContext is an interface to support dynamic dispatch.
type IUnannInterfaceTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsUnannInterfaceTypeContext differentiates from other interfaces.
	IsUnannInterfaceTypeContext()
}

type UnannInterfaceTypeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUnannInterfaceTypeContext() *UnannInterfaceTypeContext {
	var p = new(UnannInterfaceTypeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Java9ParserRULE_unannInterfaceType
	return p
}

func (*UnannInterfaceTypeContext) IsUnannInterfaceTypeContext() {}

func NewUnannInterfaceTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UnannInterfaceTypeContext {
	var p = new(UnannInterfaceTypeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java9ParserRULE_unannInterfaceType

	return p
}

func (s *UnannInterfaceTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *UnannInterfaceTypeContext) UnannClassType() IUnannClassTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUnannClassTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IUnannClassTypeContext)
}

func (s *UnannInterfaceTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnannInterfaceTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UnannInterfaceTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.EnterUnannInterfaceType(s)
	}
}

func (s *UnannInterfaceTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.ExitUnannInterfaceType(s)
	}
}

func (p *Java9Parser) UnannInterfaceType() (localctx IUnannInterfaceTypeContext) {
	localctx = NewUnannInterfaceTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 140, Java9ParserRULE_unannInterfaceType)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1078)
		p.UnannClassType()
	}

	return localctx
}

// IUnannInterfaceType_lf_unannClassOrInterfaceTypeContext is an interface to support dynamic dispatch.
type IUnannInterfaceType_lf_unannClassOrInterfaceTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsUnannInterfaceType_lf_unannClassOrInterfaceTypeContext differentiates from other interfaces.
	IsUnannInterfaceType_lf_unannClassOrInterfaceTypeContext()
}

type UnannInterfaceType_lf_unannClassOrInterfaceTypeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUnannInterfaceType_lf_unannClassOrInterfaceTypeContext() *UnannInterfaceType_lf_unannClassOrInterfaceTypeContext {
	var p = new(UnannInterfaceType_lf_unannClassOrInterfaceTypeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Java9ParserRULE_unannInterfaceType_lf_unannClassOrInterfaceType
	return p
}

func (*UnannInterfaceType_lf_unannClassOrInterfaceTypeContext) IsUnannInterfaceType_lf_unannClassOrInterfaceTypeContext() {
}

func NewUnannInterfaceType_lf_unannClassOrInterfaceTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UnannInterfaceType_lf_unannClassOrInterfaceTypeContext {
	var p = new(UnannInterfaceType_lf_unannClassOrInterfaceTypeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java9ParserRULE_unannInterfaceType_lf_unannClassOrInterfaceType

	return p
}

func (s *UnannInterfaceType_lf_unannClassOrInterfaceTypeContext) GetParser() antlr.Parser {
	return s.parser
}

func (s *UnannInterfaceType_lf_unannClassOrInterfaceTypeContext) UnannClassType_lf_unannClassOrInterfaceType() IUnannClassType_lf_unannClassOrInterfaceTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUnannClassType_lf_unannClassOrInterfaceTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IUnannClassType_lf_unannClassOrInterfaceTypeContext)
}

func (s *UnannInterfaceType_lf_unannClassOrInterfaceTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnannInterfaceType_lf_unannClassOrInterfaceTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UnannInterfaceType_lf_unannClassOrInterfaceTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.EnterUnannInterfaceType_lf_unannClassOrInterfaceType(s)
	}
}

func (s *UnannInterfaceType_lf_unannClassOrInterfaceTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.ExitUnannInterfaceType_lf_unannClassOrInterfaceType(s)
	}
}

func (p *Java9Parser) UnannInterfaceType_lf_unannClassOrInterfaceType() (localctx IUnannInterfaceType_lf_unannClassOrInterfaceTypeContext) {
	localctx = NewUnannInterfaceType_lf_unannClassOrInterfaceTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 142, Java9ParserRULE_unannInterfaceType_lf_unannClassOrInterfaceType)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1080)
		p.UnannClassType_lf_unannClassOrInterfaceType()
	}

	return localctx
}

// IUnannInterfaceType_lfno_unannClassOrInterfaceTypeContext is an interface to support dynamic dispatch.
type IUnannInterfaceType_lfno_unannClassOrInterfaceTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsUnannInterfaceType_lfno_unannClassOrInterfaceTypeContext differentiates from other interfaces.
	IsUnannInterfaceType_lfno_unannClassOrInterfaceTypeContext()
}

type UnannInterfaceType_lfno_unannClassOrInterfaceTypeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUnannInterfaceType_lfno_unannClassOrInterfaceTypeContext() *UnannInterfaceType_lfno_unannClassOrInterfaceTypeContext {
	var p = new(UnannInterfaceType_lfno_unannClassOrInterfaceTypeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Java9ParserRULE_unannInterfaceType_lfno_unannClassOrInterfaceType
	return p
}

func (*UnannInterfaceType_lfno_unannClassOrInterfaceTypeContext) IsUnannInterfaceType_lfno_unannClassOrInterfaceTypeContext() {
}

func NewUnannInterfaceType_lfno_unannClassOrInterfaceTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UnannInterfaceType_lfno_unannClassOrInterfaceTypeContext {
	var p = new(UnannInterfaceType_lfno_unannClassOrInterfaceTypeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java9ParserRULE_unannInterfaceType_lfno_unannClassOrInterfaceType

	return p
}

func (s *UnannInterfaceType_lfno_unannClassOrInterfaceTypeContext) GetParser() antlr.Parser {
	return s.parser
}

func (s *UnannInterfaceType_lfno_unannClassOrInterfaceTypeContext) UnannClassType_lfno_unannClassOrInterfaceType() IUnannClassType_lfno_unannClassOrInterfaceTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUnannClassType_lfno_unannClassOrInterfaceTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IUnannClassType_lfno_unannClassOrInterfaceTypeContext)
}

func (s *UnannInterfaceType_lfno_unannClassOrInterfaceTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnannInterfaceType_lfno_unannClassOrInterfaceTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UnannInterfaceType_lfno_unannClassOrInterfaceTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.EnterUnannInterfaceType_lfno_unannClassOrInterfaceType(s)
	}
}

func (s *UnannInterfaceType_lfno_unannClassOrInterfaceTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.ExitUnannInterfaceType_lfno_unannClassOrInterfaceType(s)
	}
}

func (p *Java9Parser) UnannInterfaceType_lfno_unannClassOrInterfaceType() (localctx IUnannInterfaceType_lfno_unannClassOrInterfaceTypeContext) {
	localctx = NewUnannInterfaceType_lfno_unannClassOrInterfaceTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 144, Java9ParserRULE_unannInterfaceType_lfno_unannClassOrInterfaceType)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1082)
		p.UnannClassType_lfno_unannClassOrInterfaceType()
	}

	return localctx
}

// IUnannTypeVariableContext is an interface to support dynamic dispatch.
type IUnannTypeVariableContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsUnannTypeVariableContext differentiates from other interfaces.
	IsUnannTypeVariableContext()
}

type UnannTypeVariableContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUnannTypeVariableContext() *UnannTypeVariableContext {
	var p = new(UnannTypeVariableContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Java9ParserRULE_unannTypeVariable
	return p
}

func (*UnannTypeVariableContext) IsUnannTypeVariableContext() {}

func NewUnannTypeVariableContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UnannTypeVariableContext {
	var p = new(UnannTypeVariableContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java9ParserRULE_unannTypeVariable

	return p
}

func (s *UnannTypeVariableContext) GetParser() antlr.Parser { return s.parser }

func (s *UnannTypeVariableContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *UnannTypeVariableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnannTypeVariableContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UnannTypeVariableContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.EnterUnannTypeVariable(s)
	}
}

func (s *UnannTypeVariableContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.ExitUnannTypeVariable(s)
	}
}

func (p *Java9Parser) UnannTypeVariable() (localctx IUnannTypeVariableContext) {
	localctx = NewUnannTypeVariableContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 146, Java9ParserRULE_unannTypeVariable)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1084)
		p.Identifier()
	}

	return localctx
}

// IUnannArrayTypeContext is an interface to support dynamic dispatch.
type IUnannArrayTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsUnannArrayTypeContext differentiates from other interfaces.
	IsUnannArrayTypeContext()
}

type UnannArrayTypeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUnannArrayTypeContext() *UnannArrayTypeContext {
	var p = new(UnannArrayTypeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Java9ParserRULE_unannArrayType
	return p
}

func (*UnannArrayTypeContext) IsUnannArrayTypeContext() {}

func NewUnannArrayTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UnannArrayTypeContext {
	var p = new(UnannArrayTypeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java9ParserRULE_unannArrayType

	return p
}

func (s *UnannArrayTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *UnannArrayTypeContext) UnannPrimitiveType() IUnannPrimitiveTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUnannPrimitiveTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IUnannPrimitiveTypeContext)
}

func (s *UnannArrayTypeContext) Dims() IDimsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDimsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDimsContext)
}

func (s *UnannArrayTypeContext) UnannClassOrInterfaceType() IUnannClassOrInterfaceTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUnannClassOrInterfaceTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IUnannClassOrInterfaceTypeContext)
}

func (s *UnannArrayTypeContext) UnannTypeVariable() IUnannTypeVariableContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUnannTypeVariableContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IUnannTypeVariableContext)
}

func (s *UnannArrayTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnannArrayTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UnannArrayTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.EnterUnannArrayType(s)
	}
}

func (s *UnannArrayTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.ExitUnannArrayType(s)
	}
}

func (p *Java9Parser) UnannArrayType() (localctx IUnannArrayTypeContext) {
	localctx = NewUnannArrayTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 148, Java9ParserRULE_unannArrayType)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1095)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 85, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1086)
			p.UnannPrimitiveType()
		}
		{
			p.SetState(1087)
			p.Dims()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1089)
			p.UnannClassOrInterfaceType()
		}
		{
			p.SetState(1090)
			p.Dims()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1092)
			p.UnannTypeVariable()
		}
		{
			p.SetState(1093)
			p.Dims()
		}

	}

	return localctx
}

// IMethodDeclarationContext is an interface to support dynamic dispatch.
type IMethodDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMethodDeclarationContext differentiates from other interfaces.
	IsMethodDeclarationContext()
}

type MethodDeclarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMethodDeclarationContext() *MethodDeclarationContext {
	var p = new(MethodDeclarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Java9ParserRULE_methodDeclaration
	return p
}

func (*MethodDeclarationContext) IsMethodDeclarationContext() {}

func NewMethodDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MethodDeclarationContext {
	var p = new(MethodDeclarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java9ParserRULE_methodDeclaration

	return p
}

func (s *MethodDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *MethodDeclarationContext) MethodHeader() IMethodHeaderContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMethodHeaderContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMethodHeaderContext)
}

func (s *MethodDeclarationContext) MethodBody() IMethodBodyContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMethodBodyContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMethodBodyContext)
}

func (s *MethodDeclarationContext) AllMethodModifier() []IMethodModifierContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IMethodModifierContext)(nil)).Elem())
	var tst = make([]IMethodModifierContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IMethodModifierContext)
		}
	}

	return tst
}

func (s *MethodDeclarationContext) MethodModifier(i int) IMethodModifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMethodModifierContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IMethodModifierContext)
}

func (s *MethodDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MethodDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MethodDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.EnterMethodDeclaration(s)
	}
}

func (s *MethodDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.ExitMethodDeclaration(s)
	}
}

func (p *Java9Parser) MethodDeclaration() (localctx IMethodDeclarationContext) {
	localctx = NewMethodDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 150, Java9ParserRULE_methodDeclaration)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1100)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == Java9ParserABSTRACT || _la == Java9ParserFINAL || (((_la-32)&-(0x1f+1)) == 0 && ((1<<uint((_la-32)))&((1<<(Java9ParserNATIVE-32))|(1<<(Java9ParserPRIVATE-32))|(1<<(Java9ParserPROTECTED-32))|(1<<(Java9ParserPUBLIC-32))|(1<<(Java9ParserSTATIC-32))|(1<<(Java9ParserSTRICTFP-32))|(1<<(Java9ParserSYNCHRONIZED-32)))) != 0) || _la == Java9ParserAT {
		{
			p.SetState(1097)
			p.MethodModifier()
		}

		p.SetState(1102)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1103)
		p.MethodHeader()
	}
	{
		p.SetState(1104)
		p.MethodBody()
	}

	return localctx
}

// IMethodModifierContext is an interface to support dynamic dispatch.
type IMethodModifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMethodModifierContext differentiates from other interfaces.
	IsMethodModifierContext()
}

type MethodModifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMethodModifierContext() *MethodModifierContext {
	var p = new(MethodModifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Java9ParserRULE_methodModifier
	return p
}

func (*MethodModifierContext) IsMethodModifierContext() {}

func NewMethodModifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MethodModifierContext {
	var p = new(MethodModifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java9ParserRULE_methodModifier

	return p
}

func (s *MethodModifierContext) GetParser() antlr.Parser { return s.parser }

func (s *MethodModifierContext) Annotation() IAnnotationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAnnotationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAnnotationContext)
}

func (s *MethodModifierContext) PUBLIC() antlr.TerminalNode {
	return s.GetToken(Java9ParserPUBLIC, 0)
}

func (s *MethodModifierContext) PROTECTED() antlr.TerminalNode {
	return s.GetToken(Java9ParserPROTECTED, 0)
}

func (s *MethodModifierContext) PRIVATE() antlr.TerminalNode {
	return s.GetToken(Java9ParserPRIVATE, 0)
}

func (s *MethodModifierContext) ABSTRACT() antlr.TerminalNode {
	return s.GetToken(Java9ParserABSTRACT, 0)
}

func (s *MethodModifierContext) STATIC() antlr.TerminalNode {
	return s.GetToken(Java9ParserSTATIC, 0)
}

func (s *MethodModifierContext) FINAL() antlr.TerminalNode {
	return s.GetToken(Java9ParserFINAL, 0)
}

func (s *MethodModifierContext) SYNCHRONIZED() antlr.TerminalNode {
	return s.GetToken(Java9ParserSYNCHRONIZED, 0)
}

func (s *MethodModifierContext) NATIVE() antlr.TerminalNode {
	return s.GetToken(Java9ParserNATIVE, 0)
}

func (s *MethodModifierContext) STRICTFP() antlr.TerminalNode {
	return s.GetToken(Java9ParserSTRICTFP, 0)
}

func (s *MethodModifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MethodModifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MethodModifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.EnterMethodModifier(s)
	}
}

func (s *MethodModifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.ExitMethodModifier(s)
	}
}

func (p *Java9Parser) MethodModifier() (localctx IMethodModifierContext) {
	localctx = NewMethodModifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 152, Java9ParserRULE_methodModifier)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1116)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case Java9ParserAT:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1106)
			p.Annotation()
		}

	case Java9ParserPUBLIC:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1107)
			p.Match(Java9ParserPUBLIC)
		}

	case Java9ParserPROTECTED:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1108)
			p.Match(Java9ParserPROTECTED)
		}

	case Java9ParserPRIVATE:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1109)
			p.Match(Java9ParserPRIVATE)
		}

	case Java9ParserABSTRACT:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1110)
			p.Match(Java9ParserABSTRACT)
		}

	case Java9ParserSTATIC:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(1111)
			p.Match(Java9ParserSTATIC)
		}

	case Java9ParserFINAL:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(1112)
			p.Match(Java9ParserFINAL)
		}

	case Java9ParserSYNCHRONIZED:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(1113)
			p.Match(Java9ParserSYNCHRONIZED)
		}

	case Java9ParserNATIVE:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(1114)
			p.Match(Java9ParserNATIVE)
		}

	case Java9ParserSTRICTFP:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(1115)
			p.Match(Java9ParserSTRICTFP)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IMethodHeaderContext is an interface to support dynamic dispatch.
type IMethodHeaderContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMethodHeaderContext differentiates from other interfaces.
	IsMethodHeaderContext()
}

type MethodHeaderContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMethodHeaderContext() *MethodHeaderContext {
	var p = new(MethodHeaderContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Java9ParserRULE_methodHeader
	return p
}

func (*MethodHeaderContext) IsMethodHeaderContext() {}

func NewMethodHeaderContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MethodHeaderContext {
	var p = new(MethodHeaderContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java9ParserRULE_methodHeader

	return p
}

func (s *MethodHeaderContext) GetParser() antlr.Parser { return s.parser }

func (s *MethodHeaderContext) Result() IResultContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IResultContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IResultContext)
}

func (s *MethodHeaderContext) MethodDeclarator() IMethodDeclaratorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMethodDeclaratorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMethodDeclaratorContext)
}

func (s *MethodHeaderContext) Throws_() IThrows_Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IThrows_Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IThrows_Context)
}

func (s *MethodHeaderContext) TypeParameters() ITypeParametersContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypeParametersContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITypeParametersContext)
}

func (s *MethodHeaderContext) AllAnnotation() []IAnnotationContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAnnotationContext)(nil)).Elem())
	var tst = make([]IAnnotationContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAnnotationContext)
		}
	}

	return tst
}

func (s *MethodHeaderContext) Annotation(i int) IAnnotationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAnnotationContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAnnotationContext)
}

func (s *MethodHeaderContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MethodHeaderContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MethodHeaderContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.EnterMethodHeader(s)
	}
}

func (s *MethodHeaderContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.ExitMethodHeader(s)
	}
}

func (p *Java9Parser) MethodHeader() (localctx IMethodHeaderContext) {
	localctx = NewMethodHeaderContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 154, Java9ParserRULE_methodHeader)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1135)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case Java9ParserBOOLEAN, Java9ParserBYTE, Java9ParserCHAR, Java9ParserDOUBLE, Java9ParserEXPORTS, Java9ParserFLOAT, Java9ParserINT, Java9ParserLONG, Java9ParserMODULE, Java9ParserOPEN, Java9ParserOPERNS, Java9ParserPROVIDES, Java9ParserREQUIRES, Java9ParserSHORT, Java9ParserTO, Java9ParserUSES, Java9ParserVOID, Java9ParserWITH, Java9ParserIdentifier:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1118)
			p.Result()
		}
		{
			p.SetState(1119)
			p.MethodDeclarator()
		}
		p.SetState(1121)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == Java9ParserTHROWS {
			{
				p.SetState(1120)
				p.Throws_()
			}

		}

	case Java9ParserLT:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1123)
			p.TypeParameters()
		}
		p.SetState(1127)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == Java9ParserAT {
			{
				p.SetState(1124)
				p.Annotation()
			}

			p.SetState(1129)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1130)
			p.Result()
		}
		{
			p.SetState(1131)
			p.MethodDeclarator()
		}
		p.SetState(1133)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == Java9ParserTHROWS {
			{
				p.SetState(1132)
				p.Throws_()
			}

		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IResultContext is an interface to support dynamic dispatch.
type IResultContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsResultContext differentiates from other interfaces.
	IsResultContext()
}

type ResultContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyResultContext() *ResultContext {
	var p = new(ResultContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Java9ParserRULE_result
	return p
}

func (*ResultContext) IsResultContext() {}

func NewResultContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ResultContext {
	var p = new(ResultContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java9ParserRULE_result

	return p
}

func (s *ResultContext) GetParser() antlr.Parser { return s.parser }

func (s *ResultContext) UnannType() IUnannTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUnannTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IUnannTypeContext)
}

func (s *ResultContext) VOID() antlr.TerminalNode {
	return s.GetToken(Java9ParserVOID, 0)
}

func (s *ResultContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ResultContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ResultContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.EnterResult(s)
	}
}

func (s *ResultContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.ExitResult(s)
	}
}

func (p *Java9Parser) Result() (localctx IResultContext) {
	localctx = NewResultContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 156, Java9ParserRULE_result)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1139)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case Java9ParserBOOLEAN, Java9ParserBYTE, Java9ParserCHAR, Java9ParserDOUBLE, Java9ParserEXPORTS, Java9ParserFLOAT, Java9ParserINT, Java9ParserLONG, Java9ParserMODULE, Java9ParserOPEN, Java9ParserOPERNS, Java9ParserPROVIDES, Java9ParserREQUIRES, Java9ParserSHORT, Java9ParserTO, Java9ParserUSES, Java9ParserWITH, Java9ParserIdentifier:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1137)
			p.UnannType()
		}

	case Java9ParserVOID:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1138)
			p.Match(Java9ParserVOID)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IMethodDeclaratorContext is an interface to support dynamic dispatch.
type IMethodDeclaratorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMethodDeclaratorContext differentiates from other interfaces.
	IsMethodDeclaratorContext()
}

type MethodDeclaratorContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMethodDeclaratorContext() *MethodDeclaratorContext {
	var p = new(MethodDeclaratorContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Java9ParserRULE_methodDeclarator
	return p
}

func (*MethodDeclaratorContext) IsMethodDeclaratorContext() {}

func NewMethodDeclaratorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MethodDeclaratorContext {
	var p = new(MethodDeclaratorContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java9ParserRULE_methodDeclarator

	return p
}

func (s *MethodDeclaratorContext) GetParser() antlr.Parser { return s.parser }

func (s *MethodDeclaratorContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *MethodDeclaratorContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(Java9ParserLPAREN, 0)
}

func (s *MethodDeclaratorContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(Java9ParserRPAREN, 0)
}

func (s *MethodDeclaratorContext) FormalParameterList() IFormalParameterListContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFormalParameterListContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFormalParameterListContext)
}

func (s *MethodDeclaratorContext) Dims() IDimsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDimsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDimsContext)
}

func (s *MethodDeclaratorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MethodDeclaratorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MethodDeclaratorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.EnterMethodDeclarator(s)
	}
}

func (s *MethodDeclaratorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.ExitMethodDeclarator(s)
	}
}

func (p *Java9Parser) MethodDeclarator() (localctx IMethodDeclaratorContext) {
	localctx = NewMethodDeclaratorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 158, Java9ParserRULE_methodDeclarator)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1141)
		p.Identifier()
	}
	{
		p.SetState(1142)
		p.Match(Java9ParserLPAREN)
	}
	p.SetState(1144)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<Java9ParserBOOLEAN)|(1<<Java9ParserBYTE)|(1<<Java9ParserCHAR)|(1<<Java9ParserDOUBLE)|(1<<Java9ParserEXPORTS)|(1<<Java9ParserFINAL)|(1<<Java9ParserFLOAT)|(1<<Java9ParserINT)|(1<<Java9ParserLONG)|(1<<Java9ParserMODULE))) != 0) || (((_la-34)&-(0x1f+1)) == 0 && ((1<<uint((_la-34)))&((1<<(Java9ParserOPEN-34))|(1<<(Java9ParserOPERNS-34))|(1<<(Java9ParserPROVIDES-34))|(1<<(Java9ParserREQUIRES-34))|(1<<(Java9ParserSHORT-34))|(1<<(Java9ParserTO-34))|(1<<(Java9ParserUSES-34))|(1<<(Java9ParserWITH-34)))) != 0) || _la == Java9ParserAT || _la == Java9ParserIdentifier {
		{
			p.SetState(1143)
			p.FormalParameterList()
		}

	}
	{
		p.SetState(1146)
		p.Match(Java9ParserRPAREN)
	}
	p.SetState(1148)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Java9ParserLBRACK || _la == Java9ParserAT {
		{
			p.SetState(1147)
			p.Dims()
		}

	}

	return localctx
}

// IFormalParameterListContext is an interface to support dynamic dispatch.
type IFormalParameterListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFormalParameterListContext differentiates from other interfaces.
	IsFormalParameterListContext()
}

type FormalParameterListContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFormalParameterListContext() *FormalParameterListContext {
	var p = new(FormalParameterListContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Java9ParserRULE_formalParameterList
	return p
}

func (*FormalParameterListContext) IsFormalParameterListContext() {}

func NewFormalParameterListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FormalParameterListContext {
	var p = new(FormalParameterListContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java9ParserRULE_formalParameterList

	return p
}

func (s *FormalParameterListContext) GetParser() antlr.Parser { return s.parser }

func (s *FormalParameterListContext) FormalParameters() IFormalParametersContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFormalParametersContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFormalParametersContext)
}

func (s *FormalParameterListContext) COMMA() antlr.TerminalNode {
	return s.GetToken(Java9ParserCOMMA, 0)
}

func (s *FormalParameterListContext) LastFormalParameter() ILastFormalParameterContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILastFormalParameterContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILastFormalParameterContext)
}

func (s *FormalParameterListContext) ReceiverParameter() IReceiverParameterContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IReceiverParameterContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IReceiverParameterContext)
}

func (s *FormalParameterListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FormalParameterListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FormalParameterListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.EnterFormalParameterList(s)
	}
}

func (s *FormalParameterListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.ExitFormalParameterList(s)
	}
}

func (p *Java9Parser) FormalParameterList() (localctx IFormalParameterListContext) {
	localctx = NewFormalParameterListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 160, Java9ParserRULE_formalParameterList)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1156)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 95, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1150)
			p.FormalParameters()
		}
		{
			p.SetState(1151)
			p.Match(Java9ParserCOMMA)
		}
		{
			p.SetState(1152)
			p.LastFormalParameter()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1154)
			p.LastFormalParameter()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1155)
			p.ReceiverParameter()
		}

	}

	return localctx
}

// IFormalParametersContext is an interface to support dynamic dispatch.
type IFormalParametersContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFormalParametersContext differentiates from other interfaces.
	IsFormalParametersContext()
}

type FormalParametersContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFormalParametersContext() *FormalParametersContext {
	var p = new(FormalParametersContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Java9ParserRULE_formalParameters
	return p
}

func (*FormalParametersContext) IsFormalParametersContext() {}

func NewFormalParametersContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FormalParametersContext {
	var p = new(FormalParametersContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java9ParserRULE_formalParameters

	return p
}

func (s *FormalParametersContext) GetParser() antlr.Parser { return s.parser }

func (s *FormalParametersContext) AllFormalParameter() []IFormalParameterContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IFormalParameterContext)(nil)).Elem())
	var tst = make([]IFormalParameterContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IFormalParameterContext)
		}
	}

	return tst
}

func (s *FormalParametersContext) FormalParameter(i int) IFormalParameterContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFormalParameterContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IFormalParameterContext)
}

func (s *FormalParametersContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(Java9ParserCOMMA)
}

func (s *FormalParametersContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(Java9ParserCOMMA, i)
}

func (s *FormalParametersContext) ReceiverParameter() IReceiverParameterContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IReceiverParameterContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IReceiverParameterContext)
}

func (s *FormalParametersContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FormalParametersContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FormalParametersContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.EnterFormalParameters(s)
	}
}

func (s *FormalParametersContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.ExitFormalParameters(s)
	}
}

func (p *Java9Parser) FormalParameters() (localctx IFormalParametersContext) {
	localctx = NewFormalParametersContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 162, Java9ParserRULE_formalParameters)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.SetState(1174)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 98, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1158)
			p.FormalParameter()
		}
		p.SetState(1163)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 96, p.GetParserRuleContext())

		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(1159)
					p.Match(Java9ParserCOMMA)
				}
				{
					p.SetState(1160)
					p.FormalParameter()
				}

			}
			p.SetState(1165)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 96, p.GetParserRuleContext())
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1166)
			p.ReceiverParameter()
		}
		p.SetState(1171)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 97, p.GetParserRuleContext())

		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(1167)
					p.Match(Java9ParserCOMMA)
				}
				{
					p.SetState(1168)
					p.FormalParameter()
				}

			}
			p.SetState(1173)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 97, p.GetParserRuleContext())
		}

	}

	return localctx
}

// IFormalParameterContext is an interface to support dynamic dispatch.
type IFormalParameterContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFormalParameterContext differentiates from other interfaces.
	IsFormalParameterContext()
}

type FormalParameterContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFormalParameterContext() *FormalParameterContext {
	var p = new(FormalParameterContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Java9ParserRULE_formalParameter
	return p
}

func (*FormalParameterContext) IsFormalParameterContext() {}

func NewFormalParameterContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FormalParameterContext {
	var p = new(FormalParameterContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java9ParserRULE_formalParameter

	return p
}

func (s *FormalParameterContext) GetParser() antlr.Parser { return s.parser }

func (s *FormalParameterContext) UnannType() IUnannTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUnannTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IUnannTypeContext)
}

func (s *FormalParameterContext) VariableDeclaratorId() IVariableDeclaratorIdContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVariableDeclaratorIdContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IVariableDeclaratorIdContext)
}

func (s *FormalParameterContext) AllVariableModifier() []IVariableModifierContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IVariableModifierContext)(nil)).Elem())
	var tst = make([]IVariableModifierContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IVariableModifierContext)
		}
	}

	return tst
}

func (s *FormalParameterContext) VariableModifier(i int) IVariableModifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVariableModifierContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IVariableModifierContext)
}

func (s *FormalParameterContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FormalParameterContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FormalParameterContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.EnterFormalParameter(s)
	}
}

func (s *FormalParameterContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.ExitFormalParameter(s)
	}
}

func (p *Java9Parser) FormalParameter() (localctx IFormalParameterContext) {
	localctx = NewFormalParameterContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 164, Java9ParserRULE_formalParameter)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1179)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == Java9ParserFINAL || _la == Java9ParserAT {
		{
			p.SetState(1176)
			p.VariableModifier()
		}

		p.SetState(1181)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1182)
		p.UnannType()
	}
	{
		p.SetState(1183)
		p.VariableDeclaratorId()
	}

	return localctx
}

// IVariableModifierContext is an interface to support dynamic dispatch.
type IVariableModifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsVariableModifierContext differentiates from other interfaces.
	IsVariableModifierContext()
}

type VariableModifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyVariableModifierContext() *VariableModifierContext {
	var p = new(VariableModifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Java9ParserRULE_variableModifier
	return p
}

func (*VariableModifierContext) IsVariableModifierContext() {}

func NewVariableModifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *VariableModifierContext {
	var p = new(VariableModifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java9ParserRULE_variableModifier

	return p
}

func (s *VariableModifierContext) GetParser() antlr.Parser { return s.parser }

func (s *VariableModifierContext) Annotation() IAnnotationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAnnotationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAnnotationContext)
}

func (s *VariableModifierContext) FINAL() antlr.TerminalNode {
	return s.GetToken(Java9ParserFINAL, 0)
}

func (s *VariableModifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VariableModifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *VariableModifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.EnterVariableModifier(s)
	}
}

func (s *VariableModifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.ExitVariableModifier(s)
	}
}

func (p *Java9Parser) VariableModifier() (localctx IVariableModifierContext) {
	localctx = NewVariableModifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 166, Java9ParserRULE_variableModifier)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1187)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case Java9ParserAT:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1185)
			p.Annotation()
		}

	case Java9ParserFINAL:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1186)
			p.Match(Java9ParserFINAL)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ILastFormalParameterContext is an interface to support dynamic dispatch.
type ILastFormalParameterContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLastFormalParameterContext differentiates from other interfaces.
	IsLastFormalParameterContext()
}

type LastFormalParameterContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLastFormalParameterContext() *LastFormalParameterContext {
	var p = new(LastFormalParameterContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Java9ParserRULE_lastFormalParameter
	return p
}

func (*LastFormalParameterContext) IsLastFormalParameterContext() {}

func NewLastFormalParameterContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LastFormalParameterContext {
	var p = new(LastFormalParameterContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java9ParserRULE_lastFormalParameter

	return p
}

func (s *LastFormalParameterContext) GetParser() antlr.Parser { return s.parser }

func (s *LastFormalParameterContext) UnannType() IUnannTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUnannTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IUnannTypeContext)
}

func (s *LastFormalParameterContext) ELLIPSIS() antlr.TerminalNode {
	return s.GetToken(Java9ParserELLIPSIS, 0)
}

func (s *LastFormalParameterContext) VariableDeclaratorId() IVariableDeclaratorIdContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVariableDeclaratorIdContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IVariableDeclaratorIdContext)
}

func (s *LastFormalParameterContext) AllVariableModifier() []IVariableModifierContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IVariableModifierContext)(nil)).Elem())
	var tst = make([]IVariableModifierContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IVariableModifierContext)
		}
	}

	return tst
}

func (s *LastFormalParameterContext) VariableModifier(i int) IVariableModifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVariableModifierContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IVariableModifierContext)
}

func (s *LastFormalParameterContext) AllAnnotation() []IAnnotationContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAnnotationContext)(nil)).Elem())
	var tst = make([]IAnnotationContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAnnotationContext)
		}
	}

	return tst
}

func (s *LastFormalParameterContext) Annotation(i int) IAnnotationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAnnotationContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAnnotationContext)
}

func (s *LastFormalParameterContext) FormalParameter() IFormalParameterContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFormalParameterContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFormalParameterContext)
}

func (s *LastFormalParameterContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LastFormalParameterContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LastFormalParameterContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.EnterLastFormalParameter(s)
	}
}

func (s *LastFormalParameterContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.ExitLastFormalParameter(s)
	}
}

func (p *Java9Parser) LastFormalParameter() (localctx ILastFormalParameterContext) {
	localctx = NewLastFormalParameterContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 168, Java9ParserRULE_lastFormalParameter)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1206)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 103, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(1192)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == Java9ParserFINAL || _la == Java9ParserAT {
			{
				p.SetState(1189)
				p.VariableModifier()
			}

			p.SetState(1194)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1195)
			p.UnannType()
		}
		p.SetState(1199)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == Java9ParserAT {
			{
				p.SetState(1196)
				p.Annotation()
			}

			p.SetState(1201)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1202)
			p.Match(Java9ParserELLIPSIS)
		}
		{
			p.SetState(1203)
			p.VariableDeclaratorId()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1205)
			p.FormalParameter()
		}

	}

	return localctx
}

// IReceiverParameterContext is an interface to support dynamic dispatch.
type IReceiverParameterContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsReceiverParameterContext differentiates from other interfaces.
	IsReceiverParameterContext()
}

type ReceiverParameterContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReceiverParameterContext() *ReceiverParameterContext {
	var p = new(ReceiverParameterContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Java9ParserRULE_receiverParameter
	return p
}

func (*ReceiverParameterContext) IsReceiverParameterContext() {}

func NewReceiverParameterContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReceiverParameterContext {
	var p = new(ReceiverParameterContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java9ParserRULE_receiverParameter

	return p
}

func (s *ReceiverParameterContext) GetParser() antlr.Parser { return s.parser }

func (s *ReceiverParameterContext) UnannType() IUnannTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUnannTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IUnannTypeContext)
}

func (s *ReceiverParameterContext) THIS() antlr.TerminalNode {
	return s.GetToken(Java9ParserTHIS, 0)
}

func (s *ReceiverParameterContext) AllAnnotation() []IAnnotationContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAnnotationContext)(nil)).Elem())
	var tst = make([]IAnnotationContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAnnotationContext)
		}
	}

	return tst
}

func (s *ReceiverParameterContext) Annotation(i int) IAnnotationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAnnotationContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAnnotationContext)
}

func (s *ReceiverParameterContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ReceiverParameterContext) DOT() antlr.TerminalNode {
	return s.GetToken(Java9ParserDOT, 0)
}

func (s *ReceiverParameterContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReceiverParameterContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReceiverParameterContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.EnterReceiverParameter(s)
	}
}

func (s *ReceiverParameterContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.ExitReceiverParameter(s)
	}
}

func (p *Java9Parser) ReceiverParameter() (localctx IReceiverParameterContext) {
	localctx = NewReceiverParameterContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 170, Java9ParserRULE_receiverParameter)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1211)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == Java9ParserAT {
		{
			p.SetState(1208)
			p.Annotation()
		}

		p.SetState(1213)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1214)
		p.UnannType()
	}
	p.SetState(1218)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Java9ParserEXPORTS || _la == Java9ParserMODULE || (((_la-34)&-(0x1f+1)) == 0 && ((1<<uint((_la-34)))&((1<<(Java9ParserOPEN-34))|(1<<(Java9ParserOPERNS-34))|(1<<(Java9ParserPROVIDES-34))|(1<<(Java9ParserREQUIRES-34))|(1<<(Java9ParserTO-34))|(1<<(Java9ParserUSES-34))|(1<<(Java9ParserWITH-34)))) != 0) || _la == Java9ParserIdentifier {
		{
			p.SetState(1215)
			p.Identifier()
		}
		{
			p.SetState(1216)
			p.Match(Java9ParserDOT)
		}

	}
	{
		p.SetState(1220)
		p.Match(Java9ParserTHIS)
	}

	return localctx
}

// IThrows_Context is an interface to support dynamic dispatch.
type IThrows_Context interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsThrows_Context differentiates from other interfaces.
	IsThrows_Context()
}

type Throws_Context struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyThrows_Context() *Throws_Context {
	var p = new(Throws_Context)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Java9ParserRULE_throws_
	return p
}

func (*Throws_Context) IsThrows_Context() {}

func NewThrows_Context(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Throws_Context {
	var p = new(Throws_Context)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java9ParserRULE_throws_

	return p
}

func (s *Throws_Context) GetParser() antlr.Parser { return s.parser }

func (s *Throws_Context) THROWS() antlr.TerminalNode {
	return s.GetToken(Java9ParserTHROWS, 0)
}

func (s *Throws_Context) ExceptionTypeList() IExceptionTypeListContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExceptionTypeListContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExceptionTypeListContext)
}

func (s *Throws_Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Throws_Context) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Throws_Context) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.EnterThrows_(s)
	}
}

func (s *Throws_Context) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.ExitThrows_(s)
	}
}

func (p *Java9Parser) Throws_() (localctx IThrows_Context) {
	localctx = NewThrows_Context(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 172, Java9ParserRULE_throws_)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1222)
		p.Match(Java9ParserTHROWS)
	}
	{
		p.SetState(1223)
		p.ExceptionTypeList()
	}

	return localctx
}

// IExceptionTypeListContext is an interface to support dynamic dispatch.
type IExceptionTypeListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExceptionTypeListContext differentiates from other interfaces.
	IsExceptionTypeListContext()
}

type ExceptionTypeListContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExceptionTypeListContext() *ExceptionTypeListContext {
	var p = new(ExceptionTypeListContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Java9ParserRULE_exceptionTypeList
	return p
}

func (*ExceptionTypeListContext) IsExceptionTypeListContext() {}

func NewExceptionTypeListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExceptionTypeListContext {
	var p = new(ExceptionTypeListContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java9ParserRULE_exceptionTypeList

	return p
}

func (s *ExceptionTypeListContext) GetParser() antlr.Parser { return s.parser }

func (s *ExceptionTypeListContext) AllExceptionType() []IExceptionTypeContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExceptionTypeContext)(nil)).Elem())
	var tst = make([]IExceptionTypeContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExceptionTypeContext)
		}
	}

	return tst
}

func (s *ExceptionTypeListContext) ExceptionType(i int) IExceptionTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExceptionTypeContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExceptionTypeContext)
}

func (s *ExceptionTypeListContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(Java9ParserCOMMA)
}

func (s *ExceptionTypeListContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(Java9ParserCOMMA, i)
}

func (s *ExceptionTypeListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExceptionTypeListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExceptionTypeListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.EnterExceptionTypeList(s)
	}
}

func (s *ExceptionTypeListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.ExitExceptionTypeList(s)
	}
}

func (p *Java9Parser) ExceptionTypeList() (localctx IExceptionTypeListContext) {
	localctx = NewExceptionTypeListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 174, Java9ParserRULE_exceptionTypeList)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1225)
		p.ExceptionType()
	}
	p.SetState(1230)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == Java9ParserCOMMA {
		{
			p.SetState(1226)
			p.Match(Java9ParserCOMMA)
		}
		{
			p.SetState(1227)
			p.ExceptionType()
		}

		p.SetState(1232)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IExceptionTypeContext is an interface to support dynamic dispatch.
type IExceptionTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExceptionTypeContext differentiates from other interfaces.
	IsExceptionTypeContext()
}

type ExceptionTypeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExceptionTypeContext() *ExceptionTypeContext {
	var p = new(ExceptionTypeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Java9ParserRULE_exceptionType
	return p
}

func (*ExceptionTypeContext) IsExceptionTypeContext() {}

func NewExceptionTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExceptionTypeContext {
	var p = new(ExceptionTypeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java9ParserRULE_exceptionType

	return p
}

func (s *ExceptionTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *ExceptionTypeContext) ClassType() IClassTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IClassTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IClassTypeContext)
}

func (s *ExceptionTypeContext) TypeVariable() ITypeVariableContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypeVariableContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITypeVariableContext)
}

func (s *ExceptionTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExceptionTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExceptionTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.EnterExceptionType(s)
	}
}

func (s *ExceptionTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.ExitExceptionType(s)
	}
}

func (p *Java9Parser) ExceptionType() (localctx IExceptionTypeContext) {
	localctx = NewExceptionTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 176, Java9ParserRULE_exceptionType)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1235)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 107, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1233)
			p.ClassType()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1234)
			p.TypeVariable()
		}

	}

	return localctx
}

// IMethodBodyContext is an interface to support dynamic dispatch.
type IMethodBodyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMethodBodyContext differentiates from other interfaces.
	IsMethodBodyContext()
}

type MethodBodyContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMethodBodyContext() *MethodBodyContext {
	var p = new(MethodBodyContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Java9ParserRULE_methodBody
	return p
}

func (*MethodBodyContext) IsMethodBodyContext() {}

func NewMethodBodyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MethodBodyContext {
	var p = new(MethodBodyContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java9ParserRULE_methodBody

	return p
}

func (s *MethodBodyContext) GetParser() antlr.Parser { return s.parser }

func (s *MethodBodyContext) Block() IBlockContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBlockContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBlockContext)
}

func (s *MethodBodyContext) SEMI() antlr.TerminalNode {
	return s.GetToken(Java9ParserSEMI, 0)
}

func (s *MethodBodyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MethodBodyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MethodBodyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.EnterMethodBody(s)
	}
}

func (s *MethodBodyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.ExitMethodBody(s)
	}
}

func (p *Java9Parser) MethodBody() (localctx IMethodBodyContext) {
	localctx = NewMethodBodyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 178, Java9ParserRULE_methodBody)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1239)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case Java9ParserLBRACE:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1237)
			p.Block()
		}

	case Java9ParserSEMI:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1238)
			p.Match(Java9ParserSEMI)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IInstanceInitializerContext is an interface to support dynamic dispatch.
type IInstanceInitializerContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsInstanceInitializerContext differentiates from other interfaces.
	IsInstanceInitializerContext()
}

type InstanceInitializerContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInstanceInitializerContext() *InstanceInitializerContext {
	var p = new(InstanceInitializerContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Java9ParserRULE_instanceInitializer
	return p
}

func (*InstanceInitializerContext) IsInstanceInitializerContext() {}

func NewInstanceInitializerContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InstanceInitializerContext {
	var p = new(InstanceInitializerContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java9ParserRULE_instanceInitializer

	return p
}

func (s *InstanceInitializerContext) GetParser() antlr.Parser { return s.parser }

func (s *InstanceInitializerContext) Block() IBlockContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBlockContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBlockContext)
}

func (s *InstanceInitializerContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InstanceInitializerContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InstanceInitializerContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.EnterInstanceInitializer(s)
	}
}

func (s *InstanceInitializerContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.ExitInstanceInitializer(s)
	}
}

func (p *Java9Parser) InstanceInitializer() (localctx IInstanceInitializerContext) {
	localctx = NewInstanceInitializerContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 180, Java9ParserRULE_instanceInitializer)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1241)
		p.Block()
	}

	return localctx
}

// IStaticInitializerContext is an interface to support dynamic dispatch.
type IStaticInitializerContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsStaticInitializerContext differentiates from other interfaces.
	IsStaticInitializerContext()
}

type StaticInitializerContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStaticInitializerContext() *StaticInitializerContext {
	var p = new(StaticInitializerContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Java9ParserRULE_staticInitializer
	return p
}

func (*StaticInitializerContext) IsStaticInitializerContext() {}

func NewStaticInitializerContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StaticInitializerContext {
	var p = new(StaticInitializerContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java9ParserRULE_staticInitializer

	return p
}

func (s *StaticInitializerContext) GetParser() antlr.Parser { return s.parser }

func (s *StaticInitializerContext) STATIC() antlr.TerminalNode {
	return s.GetToken(Java9ParserSTATIC, 0)
}

func (s *StaticInitializerContext) Block() IBlockContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBlockContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBlockContext)
}

func (s *StaticInitializerContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StaticInitializerContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StaticInitializerContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.EnterStaticInitializer(s)
	}
}

func (s *StaticInitializerContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.ExitStaticInitializer(s)
	}
}

func (p *Java9Parser) StaticInitializer() (localctx IStaticInitializerContext) {
	localctx = NewStaticInitializerContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 182, Java9ParserRULE_staticInitializer)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1243)
		p.Match(Java9ParserSTATIC)
	}
	{
		p.SetState(1244)
		p.Block()
	}

	return localctx
}

// IConstructorDeclarationContext is an interface to support dynamic dispatch.
type IConstructorDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsConstructorDeclarationContext differentiates from other interfaces.
	IsConstructorDeclarationContext()
}

type ConstructorDeclarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConstructorDeclarationContext() *ConstructorDeclarationContext {
	var p = new(ConstructorDeclarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Java9ParserRULE_constructorDeclaration
	return p
}

func (*ConstructorDeclarationContext) IsConstructorDeclarationContext() {}

func NewConstructorDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ConstructorDeclarationContext {
	var p = new(ConstructorDeclarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java9ParserRULE_constructorDeclaration

	return p
}

func (s *ConstructorDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *ConstructorDeclarationContext) ConstructorDeclarator() IConstructorDeclaratorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConstructorDeclaratorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConstructorDeclaratorContext)
}

func (s *ConstructorDeclarationContext) ConstructorBody() IConstructorBodyContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConstructorBodyContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConstructorBodyContext)
}

func (s *ConstructorDeclarationContext) AllConstructorModifier() []IConstructorModifierContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IConstructorModifierContext)(nil)).Elem())
	var tst = make([]IConstructorModifierContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IConstructorModifierContext)
		}
	}

	return tst
}

func (s *ConstructorDeclarationContext) ConstructorModifier(i int) IConstructorModifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConstructorModifierContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IConstructorModifierContext)
}

func (s *ConstructorDeclarationContext) Throws_() IThrows_Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IThrows_Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IThrows_Context)
}

func (s *ConstructorDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ConstructorDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ConstructorDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.EnterConstructorDeclaration(s)
	}
}

func (s *ConstructorDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.ExitConstructorDeclaration(s)
	}
}

func (p *Java9Parser) ConstructorDeclaration() (localctx IConstructorDeclarationContext) {
	localctx = NewConstructorDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 184, Java9ParserRULE_constructorDeclaration)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1249)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for (((_la-37)&-(0x1f+1)) == 0 && ((1<<uint((_la-37)))&((1<<(Java9ParserPRIVATE-37))|(1<<(Java9ParserPROTECTED-37))|(1<<(Java9ParserPUBLIC-37)))) != 0) || _la == Java9ParserAT {
		{
			p.SetState(1246)
			p.ConstructorModifier()
		}

		p.SetState(1251)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1252)
		p.ConstructorDeclarator()
	}
	p.SetState(1254)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Java9ParserTHROWS {
		{
			p.SetState(1253)
			p.Throws_()
		}

	}
	{
		p.SetState(1256)
		p.ConstructorBody()
	}

	return localctx
}

// IConstructorModifierContext is an interface to support dynamic dispatch.
type IConstructorModifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsConstructorModifierContext differentiates from other interfaces.
	IsConstructorModifierContext()
}

type ConstructorModifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConstructorModifierContext() *ConstructorModifierContext {
	var p = new(ConstructorModifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Java9ParserRULE_constructorModifier
	return p
}

func (*ConstructorModifierContext) IsConstructorModifierContext() {}

func NewConstructorModifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ConstructorModifierContext {
	var p = new(ConstructorModifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java9ParserRULE_constructorModifier

	return p
}

func (s *ConstructorModifierContext) GetParser() antlr.Parser { return s.parser }

func (s *ConstructorModifierContext) Annotation() IAnnotationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAnnotationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAnnotationContext)
}

func (s *ConstructorModifierContext) PUBLIC() antlr.TerminalNode {
	return s.GetToken(Java9ParserPUBLIC, 0)
}

func (s *ConstructorModifierContext) PROTECTED() antlr.TerminalNode {
	return s.GetToken(Java9ParserPROTECTED, 0)
}

func (s *ConstructorModifierContext) PRIVATE() antlr.TerminalNode {
	return s.GetToken(Java9ParserPRIVATE, 0)
}

func (s *ConstructorModifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ConstructorModifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ConstructorModifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.EnterConstructorModifier(s)
	}
}

func (s *ConstructorModifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.ExitConstructorModifier(s)
	}
}

func (p *Java9Parser) ConstructorModifier() (localctx IConstructorModifierContext) {
	localctx = NewConstructorModifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 186, Java9ParserRULE_constructorModifier)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1262)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case Java9ParserAT:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1258)
			p.Annotation()
		}

	case Java9ParserPUBLIC:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1259)
			p.Match(Java9ParserPUBLIC)
		}

	case Java9ParserPROTECTED:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1260)
			p.Match(Java9ParserPROTECTED)
		}

	case Java9ParserPRIVATE:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1261)
			p.Match(Java9ParserPRIVATE)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IConstructorDeclaratorContext is an interface to support dynamic dispatch.
type IConstructorDeclaratorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsConstructorDeclaratorContext differentiates from other interfaces.
	IsConstructorDeclaratorContext()
}

type ConstructorDeclaratorContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConstructorDeclaratorContext() *ConstructorDeclaratorContext {
	var p = new(ConstructorDeclaratorContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Java9ParserRULE_constructorDeclarator
	return p
}

func (*ConstructorDeclaratorContext) IsConstructorDeclaratorContext() {}

func NewConstructorDeclaratorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ConstructorDeclaratorContext {
	var p = new(ConstructorDeclaratorContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java9ParserRULE_constructorDeclarator

	return p
}

func (s *ConstructorDeclaratorContext) GetParser() antlr.Parser { return s.parser }

func (s *ConstructorDeclaratorContext) SimpleTypeName() ISimpleTypeNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISimpleTypeNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISimpleTypeNameContext)
}

func (s *ConstructorDeclaratorContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(Java9ParserLPAREN, 0)
}

func (s *ConstructorDeclaratorContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(Java9ParserRPAREN, 0)
}

func (s *ConstructorDeclaratorContext) TypeParameters() ITypeParametersContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypeParametersContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITypeParametersContext)
}

func (s *ConstructorDeclaratorContext) FormalParameterList() IFormalParameterListContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFormalParameterListContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFormalParameterListContext)
}

func (s *ConstructorDeclaratorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ConstructorDeclaratorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ConstructorDeclaratorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.EnterConstructorDeclarator(s)
	}
}

func (s *ConstructorDeclaratorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.ExitConstructorDeclarator(s)
	}
}

func (p *Java9Parser) ConstructorDeclarator() (localctx IConstructorDeclaratorContext) {
	localctx = NewConstructorDeclaratorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 188, Java9ParserRULE_constructorDeclarator)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1265)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Java9ParserLT {
		{
			p.SetState(1264)
			p.TypeParameters()
		}

	}
	{
		p.SetState(1267)
		p.SimpleTypeName()
	}
	{
		p.SetState(1268)
		p.Match(Java9ParserLPAREN)
	}
	p.SetState(1270)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<Java9ParserBOOLEAN)|(1<<Java9ParserBYTE)|(1<<Java9ParserCHAR)|(1<<Java9ParserDOUBLE)|(1<<Java9ParserEXPORTS)|(1<<Java9ParserFINAL)|(1<<Java9ParserFLOAT)|(1<<Java9ParserINT)|(1<<Java9ParserLONG)|(1<<Java9ParserMODULE))) != 0) || (((_la-34)&-(0x1f+1)) == 0 && ((1<<uint((_la-34)))&((1<<(Java9ParserOPEN-34))|(1<<(Java9ParserOPERNS-34))|(1<<(Java9ParserPROVIDES-34))|(1<<(Java9ParserREQUIRES-34))|(1<<(Java9ParserSHORT-34))|(1<<(Java9ParserTO-34))|(1<<(Java9ParserUSES-34))|(1<<(Java9ParserWITH-34)))) != 0) || _la == Java9ParserAT || _la == Java9ParserIdentifier {
		{
			p.SetState(1269)
			p.FormalParameterList()
		}

	}
	{
		p.SetState(1272)
		p.Match(Java9ParserRPAREN)
	}

	return localctx
}

// ISimpleTypeNameContext is an interface to support dynamic dispatch.
type ISimpleTypeNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSimpleTypeNameContext differentiates from other interfaces.
	IsSimpleTypeNameContext()
}

type SimpleTypeNameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySimpleTypeNameContext() *SimpleTypeNameContext {
	var p = new(SimpleTypeNameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Java9ParserRULE_simpleTypeName
	return p
}

func (*SimpleTypeNameContext) IsSimpleTypeNameContext() {}

func NewSimpleTypeNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SimpleTypeNameContext {
	var p = new(SimpleTypeNameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java9ParserRULE_simpleTypeName

	return p
}

func (s *SimpleTypeNameContext) GetParser() antlr.Parser { return s.parser }

func (s *SimpleTypeNameContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *SimpleTypeNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SimpleTypeNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SimpleTypeNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.EnterSimpleTypeName(s)
	}
}

func (s *SimpleTypeNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.ExitSimpleTypeName(s)
	}
}

func (p *Java9Parser) SimpleTypeName() (localctx ISimpleTypeNameContext) {
	localctx = NewSimpleTypeNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 190, Java9ParserRULE_simpleTypeName)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1274)
		p.Identifier()
	}

	return localctx
}

// IConstructorBodyContext is an interface to support dynamic dispatch.
type IConstructorBodyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsConstructorBodyContext differentiates from other interfaces.
	IsConstructorBodyContext()
}

type ConstructorBodyContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConstructorBodyContext() *ConstructorBodyContext {
	var p = new(ConstructorBodyContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Java9ParserRULE_constructorBody
	return p
}

func (*ConstructorBodyContext) IsConstructorBodyContext() {}

func NewConstructorBodyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ConstructorBodyContext {
	var p = new(ConstructorBodyContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java9ParserRULE_constructorBody

	return p
}

func (s *ConstructorBodyContext) GetParser() antlr.Parser { return s.parser }

func (s *ConstructorBodyContext) LBRACE() antlr.TerminalNode {
	return s.GetToken(Java9ParserLBRACE, 0)
}

func (s *ConstructorBodyContext) RBRACE() antlr.TerminalNode {
	return s.GetToken(Java9ParserRBRACE, 0)
}

func (s *ConstructorBodyContext) ExplicitConstructorInvocation() IExplicitConstructorInvocationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExplicitConstructorInvocationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExplicitConstructorInvocationContext)
}

func (s *ConstructorBodyContext) BlockStatements() IBlockStatementsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBlockStatementsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBlockStatementsContext)
}

func (s *ConstructorBodyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ConstructorBodyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ConstructorBodyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.EnterConstructorBody(s)
	}
}

func (s *ConstructorBodyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.ExitConstructorBody(s)
	}
}

func (p *Java9Parser) ConstructorBody() (localctx IConstructorBodyContext) {
	localctx = NewConstructorBodyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 192, Java9ParserRULE_constructorBody)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1276)
		p.Match(Java9ParserLBRACE)
	}
	p.SetState(1278)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 114, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1277)
			p.ExplicitConstructorInvocation()
		}

	}
	p.SetState(1281)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<Java9ParserABSTRACT)|(1<<Java9ParserASSERT)|(1<<Java9ParserBOOLEAN)|(1<<Java9ParserBREAK)|(1<<Java9ParserBYTE)|(1<<Java9ParserCHAR)|(1<<Java9ParserCLASS)|(1<<Java9ParserCONTINUE)|(1<<Java9ParserDO)|(1<<Java9ParserDOUBLE)|(1<<Java9ParserENUM)|(1<<Java9ParserEXPORTS)|(1<<Java9ParserFINAL)|(1<<Java9ParserFLOAT)|(1<<Java9ParserFOR)|(1<<Java9ParserIF)|(1<<Java9ParserINT)|(1<<Java9ParserLONG)|(1<<Java9ParserMODULE))) != 0) || (((_la-33)&-(0x1f+1)) == 0 && ((1<<uint((_la-33)))&((1<<(Java9ParserNEW-33))|(1<<(Java9ParserOPEN-33))|(1<<(Java9ParserOPERNS-33))|(1<<(Java9ParserPRIVATE-33))|(1<<(Java9ParserPROTECTED-33))|(1<<(Java9ParserPROVIDES-33))|(1<<(Java9ParserPUBLIC-33))|(1<<(Java9ParserREQUIRES-33))|(1<<(Java9ParserRETURN-33))|(1<<(Java9ParserSHORT-33))|(1<<(Java9ParserSTATIC-33))|(1<<(Java9ParserSTRICTFP-33))|(1<<(Java9ParserSUPER-33))|(1<<(Java9ParserSWITCH-33))|(1<<(Java9ParserSYNCHRONIZED-33))|(1<<(Java9ParserTHIS-33))|(1<<(Java9ParserTHROW-33))|(1<<(Java9ParserTO-33))|(1<<(Java9ParserTRY-33))|(1<<(Java9ParserUSES-33))|(1<<(Java9ParserVOID-33))|(1<<(Java9ParserWHILE-33))|(1<<(Java9ParserWITH-33))|(1<<(Java9ParserIntegerLiteral-33))|(1<<(Java9ParserFloatingPointLiteral-33))|(1<<(Java9ParserBooleanLiteral-33)))) != 0) || (((_la-65)&-(0x1f+1)) == 0 && ((1<<uint((_la-65)))&((1<<(Java9ParserCharacterLiteral-65))|(1<<(Java9ParserStringLiteral-65))|(1<<(Java9ParserNullLiteral-65))|(1<<(Java9ParserLPAREN-65))|(1<<(Java9ParserLBRACE-65))|(1<<(Java9ParserSEMI-65))|(1<<(Java9ParserAT-65))|(1<<(Java9ParserINC-65))|(1<<(Java9ParserDEC-65)))) != 0) || _la == Java9ParserIdentifier {
		{
			p.SetState(1280)
			p.BlockStatements()
		}

	}
	{
		p.SetState(1283)
		p.Match(Java9ParserRBRACE)
	}

	return localctx
}

// IExplicitConstructorInvocationContext is an interface to support dynamic dispatch.
type IExplicitConstructorInvocationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExplicitConstructorInvocationContext differentiates from other interfaces.
	IsExplicitConstructorInvocationContext()
}

type ExplicitConstructorInvocationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExplicitConstructorInvocationContext() *ExplicitConstructorInvocationContext {
	var p = new(ExplicitConstructorInvocationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Java9ParserRULE_explicitConstructorInvocation
	return p
}

func (*ExplicitConstructorInvocationContext) IsExplicitConstructorInvocationContext() {}

func NewExplicitConstructorInvocationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExplicitConstructorInvocationContext {
	var p = new(ExplicitConstructorInvocationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java9ParserRULE_explicitConstructorInvocation

	return p
}

func (s *ExplicitConstructorInvocationContext) GetParser() antlr.Parser { return s.parser }

func (s *ExplicitConstructorInvocationContext) THIS() antlr.TerminalNode {
	return s.GetToken(Java9ParserTHIS, 0)
}

func (s *ExplicitConstructorInvocationContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(Java9ParserLPAREN, 0)
}

func (s *ExplicitConstructorInvocationContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(Java9ParserRPAREN, 0)
}

func (s *ExplicitConstructorInvocationContext) SEMI() antlr.TerminalNode {
	return s.GetToken(Java9ParserSEMI, 0)
}

func (s *ExplicitConstructorInvocationContext) TypeArguments() ITypeArgumentsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypeArgumentsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITypeArgumentsContext)
}

func (s *ExplicitConstructorInvocationContext) ArgumentList() IArgumentListContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IArgumentListContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IArgumentListContext)
}

func (s *ExplicitConstructorInvocationContext) SUPER() antlr.TerminalNode {
	return s.GetToken(Java9ParserSUPER, 0)
}

func (s *ExplicitConstructorInvocationContext) ExpressionName() IExpressionNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionNameContext)
}

func (s *ExplicitConstructorInvocationContext) DOT() antlr.TerminalNode {
	return s.GetToken(Java9ParserDOT, 0)
}

func (s *ExplicitConstructorInvocationContext) Primary() IPrimaryContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPrimaryContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPrimaryContext)
}

func (s *ExplicitConstructorInvocationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExplicitConstructorInvocationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExplicitConstructorInvocationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.EnterExplicitConstructorInvocation(s)
	}
}

func (s *ExplicitConstructorInvocationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.ExitExplicitConstructorInvocation(s)
	}
}

func (p *Java9Parser) ExplicitConstructorInvocation() (localctx IExplicitConstructorInvocationContext) {
	localctx = NewExplicitConstructorInvocationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 194, Java9ParserRULE_explicitConstructorInvocation)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1331)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 124, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(1286)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == Java9ParserLT {
			{
				p.SetState(1285)
				p.TypeArguments()
			}

		}
		{
			p.SetState(1288)
			p.Match(Java9ParserTHIS)
		}
		{
			p.SetState(1289)
			p.Match(Java9ParserLPAREN)
		}
		p.SetState(1291)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<Java9ParserBOOLEAN)|(1<<Java9ParserBYTE)|(1<<Java9ParserCHAR)|(1<<Java9ParserDOUBLE)|(1<<Java9ParserEXPORTS)|(1<<Java9ParserFLOAT)|(1<<Java9ParserINT)|(1<<Java9ParserLONG)|(1<<Java9ParserMODULE))) != 0) || (((_la-33)&-(0x1f+1)) == 0 && ((1<<uint((_la-33)))&((1<<(Java9ParserNEW-33))|(1<<(Java9ParserOPEN-33))|(1<<(Java9ParserOPERNS-33))|(1<<(Java9ParserPROVIDES-33))|(1<<(Java9ParserREQUIRES-33))|(1<<(Java9ParserSHORT-33))|(1<<(Java9ParserSUPER-33))|(1<<(Java9ParserTHIS-33))|(1<<(Java9ParserTO-33))|(1<<(Java9ParserUSES-33))|(1<<(Java9ParserVOID-33))|(1<<(Java9ParserWITH-33))|(1<<(Java9ParserIntegerLiteral-33))|(1<<(Java9ParserFloatingPointLiteral-33))|(1<<(Java9ParserBooleanLiteral-33)))) != 0) || (((_la-65)&-(0x1f+1)) == 0 && ((1<<uint((_la-65)))&((1<<(Java9ParserCharacterLiteral-65))|(1<<(Java9ParserStringLiteral-65))|(1<<(Java9ParserNullLiteral-65))|(1<<(Java9ParserLPAREN-65))|(1<<(Java9ParserAT-65))|(1<<(Java9ParserBANG-65))|(1<<(Java9ParserTILDE-65))|(1<<(Java9ParserINC-65))|(1<<(Java9ParserDEC-65))|(1<<(Java9ParserADD-65)))) != 0) || _la == Java9ParserSUB || _la == Java9ParserIdentifier {
			{
				p.SetState(1290)
				p.ArgumentList()
			}

		}
		{
			p.SetState(1293)
			p.Match(Java9ParserRPAREN)
		}
		{
			p.SetState(1294)
			p.Match(Java9ParserSEMI)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		p.SetState(1296)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == Java9ParserLT {
			{
				p.SetState(1295)
				p.TypeArguments()
			}

		}
		{
			p.SetState(1298)
			p.Match(Java9ParserSUPER)
		}
		{
			p.SetState(1299)
			p.Match(Java9ParserLPAREN)
		}
		p.SetState(1301)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<Java9ParserBOOLEAN)|(1<<Java9ParserBYTE)|(1<<Java9ParserCHAR)|(1<<Java9ParserDOUBLE)|(1<<Java9ParserEXPORTS)|(1<<Java9ParserFLOAT)|(1<<Java9ParserINT)|(1<<Java9ParserLONG)|(1<<Java9ParserMODULE))) != 0) || (((_la-33)&-(0x1f+1)) == 0 && ((1<<uint((_la-33)))&((1<<(Java9ParserNEW-33))|(1<<(Java9ParserOPEN-33))|(1<<(Java9ParserOPERNS-33))|(1<<(Java9ParserPROVIDES-33))|(1<<(Java9ParserREQUIRES-33))|(1<<(Java9ParserSHORT-33))|(1<<(Java9ParserSUPER-33))|(1<<(Java9ParserTHIS-33))|(1<<(Java9ParserTO-33))|(1<<(Java9ParserUSES-33))|(1<<(Java9ParserVOID-33))|(1<<(Java9ParserWITH-33))|(1<<(Java9ParserIntegerLiteral-33))|(1<<(Java9ParserFloatingPointLiteral-33))|(1<<(Java9ParserBooleanLiteral-33)))) != 0) || (((_la-65)&-(0x1f+1)) == 0 && ((1<<uint((_la-65)))&((1<<(Java9ParserCharacterLiteral-65))|(1<<(Java9ParserStringLiteral-65))|(1<<(Java9ParserNullLiteral-65))|(1<<(Java9ParserLPAREN-65))|(1<<(Java9ParserAT-65))|(1<<(Java9ParserBANG-65))|(1<<(Java9ParserTILDE-65))|(1<<(Java9ParserINC-65))|(1<<(Java9ParserDEC-65))|(1<<(Java9ParserADD-65)))) != 0) || _la == Java9ParserSUB || _la == Java9ParserIdentifier {
			{
				p.SetState(1300)
				p.ArgumentList()
			}

		}
		{
			p.SetState(1303)
			p.Match(Java9ParserRPAREN)
		}
		{
			p.SetState(1304)
			p.Match(Java9ParserSEMI)
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1305)
			p.ExpressionName()
		}
		{
			p.SetState(1306)
			p.Match(Java9ParserDOT)
		}
		p.SetState(1308)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == Java9ParserLT {
			{
				p.SetState(1307)
				p.TypeArguments()
			}

		}
		{
			p.SetState(1310)
			p.Match(Java9ParserSUPER)
		}
		{
			p.SetState(1311)
			p.Match(Java9ParserLPAREN)
		}
		p.SetState(1313)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<Java9ParserBOOLEAN)|(1<<Java9ParserBYTE)|(1<<Java9ParserCHAR)|(1<<Java9ParserDOUBLE)|(1<<Java9ParserEXPORTS)|(1<<Java9ParserFLOAT)|(1<<Java9ParserINT)|(1<<Java9ParserLONG)|(1<<Java9ParserMODULE))) != 0) || (((_la-33)&-(0x1f+1)) == 0 && ((1<<uint((_la-33)))&((1<<(Java9ParserNEW-33))|(1<<(Java9ParserOPEN-33))|(1<<(Java9ParserOPERNS-33))|(1<<(Java9ParserPROVIDES-33))|(1<<(Java9ParserREQUIRES-33))|(1<<(Java9ParserSHORT-33))|(1<<(Java9ParserSUPER-33))|(1<<(Java9ParserTHIS-33))|(1<<(Java9ParserTO-33))|(1<<(Java9ParserUSES-33))|(1<<(Java9ParserVOID-33))|(1<<(Java9ParserWITH-33))|(1<<(Java9ParserIntegerLiteral-33))|(1<<(Java9ParserFloatingPointLiteral-33))|(1<<(Java9ParserBooleanLiteral-33)))) != 0) || (((_la-65)&-(0x1f+1)) == 0 && ((1<<uint((_la-65)))&((1<<(Java9ParserCharacterLiteral-65))|(1<<(Java9ParserStringLiteral-65))|(1<<(Java9ParserNullLiteral-65))|(1<<(Java9ParserLPAREN-65))|(1<<(Java9ParserAT-65))|(1<<(Java9ParserBANG-65))|(1<<(Java9ParserTILDE-65))|(1<<(Java9ParserINC-65))|(1<<(Java9ParserDEC-65))|(1<<(Java9ParserADD-65)))) != 0) || _la == Java9ParserSUB || _la == Java9ParserIdentifier {
			{
				p.SetState(1312)
				p.ArgumentList()
			}

		}
		{
			p.SetState(1315)
			p.Match(Java9ParserRPAREN)
		}
		{
			p.SetState(1316)
			p.Match(Java9ParserSEMI)
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1318)
			p.Primary()
		}
		{
			p.SetState(1319)
			p.Match(Java9ParserDOT)
		}
		p.SetState(1321)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == Java9ParserLT {
			{
				p.SetState(1320)
				p.TypeArguments()
			}

		}
		{
			p.SetState(1323)
			p.Match(Java9ParserSUPER)
		}
		{
			p.SetState(1324)
			p.Match(Java9ParserLPAREN)
		}
		p.SetState(1326)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<Java9ParserBOOLEAN)|(1<<Java9ParserBYTE)|(1<<Java9ParserCHAR)|(1<<Java9ParserDOUBLE)|(1<<Java9ParserEXPORTS)|(1<<Java9ParserFLOAT)|(1<<Java9ParserINT)|(1<<Java9ParserLONG)|(1<<Java9ParserMODULE))) != 0) || (((_la-33)&-(0x1f+1)) == 0 && ((1<<uint((_la-33)))&((1<<(Java9ParserNEW-33))|(1<<(Java9ParserOPEN-33))|(1<<(Java9ParserOPERNS-33))|(1<<(Java9ParserPROVIDES-33))|(1<<(Java9ParserREQUIRES-33))|(1<<(Java9ParserSHORT-33))|(1<<(Java9ParserSUPER-33))|(1<<(Java9ParserTHIS-33))|(1<<(Java9ParserTO-33))|(1<<(Java9ParserUSES-33))|(1<<(Java9ParserVOID-33))|(1<<(Java9ParserWITH-33))|(1<<(Java9ParserIntegerLiteral-33))|(1<<(Java9ParserFloatingPointLiteral-33))|(1<<(Java9ParserBooleanLiteral-33)))) != 0) || (((_la-65)&-(0x1f+1)) == 0 && ((1<<uint((_la-65)))&((1<<(Java9ParserCharacterLiteral-65))|(1<<(Java9ParserStringLiteral-65))|(1<<(Java9ParserNullLiteral-65))|(1<<(Java9ParserLPAREN-65))|(1<<(Java9ParserAT-65))|(1<<(Java9ParserBANG-65))|(1<<(Java9ParserTILDE-65))|(1<<(Java9ParserINC-65))|(1<<(Java9ParserDEC-65))|(1<<(Java9ParserADD-65)))) != 0) || _la == Java9ParserSUB || _la == Java9ParserIdentifier {
			{
				p.SetState(1325)
				p.ArgumentList()
			}

		}
		{
			p.SetState(1328)
			p.Match(Java9ParserRPAREN)
		}
		{
			p.SetState(1329)
			p.Match(Java9ParserSEMI)
		}

	}

	return localctx
}

// IEnumDeclarationContext is an interface to support dynamic dispatch.
type IEnumDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEnumDeclarationContext differentiates from other interfaces.
	IsEnumDeclarationContext()
}

type EnumDeclarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEnumDeclarationContext() *EnumDeclarationContext {
	var p = new(EnumDeclarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Java9ParserRULE_enumDeclaration
	return p
}

func (*EnumDeclarationContext) IsEnumDeclarationContext() {}

func NewEnumDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EnumDeclarationContext {
	var p = new(EnumDeclarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java9ParserRULE_enumDeclaration

	return p
}

func (s *EnumDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *EnumDeclarationContext) ENUM() antlr.TerminalNode {
	return s.GetToken(Java9ParserENUM, 0)
}

func (s *EnumDeclarationContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *EnumDeclarationContext) EnumBody() IEnumBodyContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEnumBodyContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEnumBodyContext)
}

func (s *EnumDeclarationContext) AllClassModifier() []IClassModifierContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IClassModifierContext)(nil)).Elem())
	var tst = make([]IClassModifierContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IClassModifierContext)
		}
	}

	return tst
}

func (s *EnumDeclarationContext) ClassModifier(i int) IClassModifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IClassModifierContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IClassModifierContext)
}

func (s *EnumDeclarationContext) Superinterfaces() ISuperinterfacesContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISuperinterfacesContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISuperinterfacesContext)
}

func (s *EnumDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EnumDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EnumDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.EnterEnumDeclaration(s)
	}
}

func (s *EnumDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.ExitEnumDeclaration(s)
	}
}

func (p *Java9Parser) EnumDeclaration() (localctx IEnumDeclarationContext) {
	localctx = NewEnumDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 196, Java9ParserRULE_enumDeclaration)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1336)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == Java9ParserABSTRACT || _la == Java9ParserFINAL || (((_la-37)&-(0x1f+1)) == 0 && ((1<<uint((_la-37)))&((1<<(Java9ParserPRIVATE-37))|(1<<(Java9ParserPROTECTED-37))|(1<<(Java9ParserPUBLIC-37))|(1<<(Java9ParserSTATIC-37))|(1<<(Java9ParserSTRICTFP-37)))) != 0) || _la == Java9ParserAT {
		{
			p.SetState(1333)
			p.ClassModifier()
		}

		p.SetState(1338)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1339)
		p.Match(Java9ParserENUM)
	}
	{
		p.SetState(1340)
		p.Identifier()
	}
	p.SetState(1342)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Java9ParserIMPLEMENTS {
		{
			p.SetState(1341)
			p.Superinterfaces()
		}

	}
	{
		p.SetState(1344)
		p.EnumBody()
	}

	return localctx
}

// IEnumBodyContext is an interface to support dynamic dispatch.
type IEnumBodyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEnumBodyContext differentiates from other interfaces.
	IsEnumBodyContext()
}

type EnumBodyContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEnumBodyContext() *EnumBodyContext {
	var p = new(EnumBodyContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Java9ParserRULE_enumBody
	return p
}

func (*EnumBodyContext) IsEnumBodyContext() {}

func NewEnumBodyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EnumBodyContext {
	var p = new(EnumBodyContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java9ParserRULE_enumBody

	return p
}

func (s *EnumBodyContext) GetParser() antlr.Parser { return s.parser }

func (s *EnumBodyContext) LBRACE() antlr.TerminalNode {
	return s.GetToken(Java9ParserLBRACE, 0)
}

func (s *EnumBodyContext) RBRACE() antlr.TerminalNode {
	return s.GetToken(Java9ParserRBRACE, 0)
}

func (s *EnumBodyContext) EnumConstantList() IEnumConstantListContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEnumConstantListContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEnumConstantListContext)
}

func (s *EnumBodyContext) COMMA() antlr.TerminalNode {
	return s.GetToken(Java9ParserCOMMA, 0)
}

func (s *EnumBodyContext) EnumBodyDeclarations() IEnumBodyDeclarationsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEnumBodyDeclarationsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEnumBodyDeclarationsContext)
}

func (s *EnumBodyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EnumBodyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EnumBodyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.EnterEnumBody(s)
	}
}

func (s *EnumBodyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.ExitEnumBody(s)
	}
}

func (p *Java9Parser) EnumBody() (localctx IEnumBodyContext) {
	localctx = NewEnumBodyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 198, Java9ParserRULE_enumBody)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1346)
		p.Match(Java9ParserLBRACE)
	}
	p.SetState(1348)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if (((_la-17)&-(0x1f+1)) == 0 && ((1<<uint((_la-17)))&((1<<(Java9ParserEXPORTS-17))|(1<<(Java9ParserMODULE-17))|(1<<(Java9ParserOPEN-17))|(1<<(Java9ParserOPERNS-17))|(1<<(Java9ParserPROVIDES-17))|(1<<(Java9ParserREQUIRES-17)))) != 0) || (((_la-52)&-(0x1f+1)) == 0 && ((1<<uint((_la-52)))&((1<<(Java9ParserTO-52))|(1<<(Java9ParserUSES-52))|(1<<(Java9ParserWITH-52))|(1<<(Java9ParserAT-52)))) != 0) || _la == Java9ParserIdentifier {
		{
			p.SetState(1347)
			p.EnumConstantList()
		}

	}
	p.SetState(1351)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Java9ParserCOMMA {
		{
			p.SetState(1350)
			p.Match(Java9ParserCOMMA)
		}

	}
	p.SetState(1354)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Java9ParserSEMI {
		{
			p.SetState(1353)
			p.EnumBodyDeclarations()
		}

	}
	{
		p.SetState(1356)
		p.Match(Java9ParserRBRACE)
	}

	return localctx
}

// IEnumConstantListContext is an interface to support dynamic dispatch.
type IEnumConstantListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEnumConstantListContext differentiates from other interfaces.
	IsEnumConstantListContext()
}

type EnumConstantListContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEnumConstantListContext() *EnumConstantListContext {
	var p = new(EnumConstantListContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Java9ParserRULE_enumConstantList
	return p
}

func (*EnumConstantListContext) IsEnumConstantListContext() {}

func NewEnumConstantListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EnumConstantListContext {
	var p = new(EnumConstantListContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java9ParserRULE_enumConstantList

	return p
}

func (s *EnumConstantListContext) GetParser() antlr.Parser { return s.parser }

func (s *EnumConstantListContext) AllEnumConstant() []IEnumConstantContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IEnumConstantContext)(nil)).Elem())
	var tst = make([]IEnumConstantContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IEnumConstantContext)
		}
	}

	return tst
}

func (s *EnumConstantListContext) EnumConstant(i int) IEnumConstantContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEnumConstantContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IEnumConstantContext)
}

func (s *EnumConstantListContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(Java9ParserCOMMA)
}

func (s *EnumConstantListContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(Java9ParserCOMMA, i)
}

func (s *EnumConstantListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EnumConstantListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EnumConstantListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.EnterEnumConstantList(s)
	}
}

func (s *EnumConstantListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.ExitEnumConstantList(s)
	}
}

func (p *Java9Parser) EnumConstantList() (localctx IEnumConstantListContext) {
	localctx = NewEnumConstantListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 200, Java9ParserRULE_enumConstantList)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1358)
		p.EnumConstant()
	}
	p.SetState(1363)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 130, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1359)
				p.Match(Java9ParserCOMMA)
			}
			{
				p.SetState(1360)
				p.EnumConstant()
			}

		}
		p.SetState(1365)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 130, p.GetParserRuleContext())
	}

	return localctx
}

// IEnumConstantContext is an interface to support dynamic dispatch.
type IEnumConstantContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEnumConstantContext differentiates from other interfaces.
	IsEnumConstantContext()
}

type EnumConstantContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEnumConstantContext() *EnumConstantContext {
	var p = new(EnumConstantContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Java9ParserRULE_enumConstant
	return p
}

func (*EnumConstantContext) IsEnumConstantContext() {}

func NewEnumConstantContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EnumConstantContext {
	var p = new(EnumConstantContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java9ParserRULE_enumConstant

	return p
}

func (s *EnumConstantContext) GetParser() antlr.Parser { return s.parser }

func (s *EnumConstantContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *EnumConstantContext) AllEnumConstantModifier() []IEnumConstantModifierContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IEnumConstantModifierContext)(nil)).Elem())
	var tst = make([]IEnumConstantModifierContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IEnumConstantModifierContext)
		}
	}

	return tst
}

func (s *EnumConstantContext) EnumConstantModifier(i int) IEnumConstantModifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEnumConstantModifierContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IEnumConstantModifierContext)
}

func (s *EnumConstantContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(Java9ParserLPAREN, 0)
}

func (s *EnumConstantContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(Java9ParserRPAREN, 0)
}

func (s *EnumConstantContext) ClassBody() IClassBodyContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IClassBodyContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IClassBodyContext)
}

func (s *EnumConstantContext) ArgumentList() IArgumentListContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IArgumentListContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IArgumentListContext)
}

func (s *EnumConstantContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EnumConstantContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EnumConstantContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.EnterEnumConstant(s)
	}
}

func (s *EnumConstantContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.ExitEnumConstant(s)
	}
}

func (p *Java9Parser) EnumConstant() (localctx IEnumConstantContext) {
	localctx = NewEnumConstantContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 202, Java9ParserRULE_enumConstant)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1369)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == Java9ParserAT {
		{
			p.SetState(1366)
			p.EnumConstantModifier()
		}

		p.SetState(1371)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1372)
		p.Identifier()
	}
	p.SetState(1378)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Java9ParserLPAREN {
		{
			p.SetState(1373)
			p.Match(Java9ParserLPAREN)
		}
		p.SetState(1375)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<Java9ParserBOOLEAN)|(1<<Java9ParserBYTE)|(1<<Java9ParserCHAR)|(1<<Java9ParserDOUBLE)|(1<<Java9ParserEXPORTS)|(1<<Java9ParserFLOAT)|(1<<Java9ParserINT)|(1<<Java9ParserLONG)|(1<<Java9ParserMODULE))) != 0) || (((_la-33)&-(0x1f+1)) == 0 && ((1<<uint((_la-33)))&((1<<(Java9ParserNEW-33))|(1<<(Java9ParserOPEN-33))|(1<<(Java9ParserOPERNS-33))|(1<<(Java9ParserPROVIDES-33))|(1<<(Java9ParserREQUIRES-33))|(1<<(Java9ParserSHORT-33))|(1<<(Java9ParserSUPER-33))|(1<<(Java9ParserTHIS-33))|(1<<(Java9ParserTO-33))|(1<<(Java9ParserUSES-33))|(1<<(Java9ParserVOID-33))|(1<<(Java9ParserWITH-33))|(1<<(Java9ParserIntegerLiteral-33))|(1<<(Java9ParserFloatingPointLiteral-33))|(1<<(Java9ParserBooleanLiteral-33)))) != 0) || (((_la-65)&-(0x1f+1)) == 0 && ((1<<uint((_la-65)))&((1<<(Java9ParserCharacterLiteral-65))|(1<<(Java9ParserStringLiteral-65))|(1<<(Java9ParserNullLiteral-65))|(1<<(Java9ParserLPAREN-65))|(1<<(Java9ParserAT-65))|(1<<(Java9ParserBANG-65))|(1<<(Java9ParserTILDE-65))|(1<<(Java9ParserINC-65))|(1<<(Java9ParserDEC-65))|(1<<(Java9ParserADD-65)))) != 0) || _la == Java9ParserSUB || _la == Java9ParserIdentifier {
			{
				p.SetState(1374)
				p.ArgumentList()
			}

		}
		{
			p.SetState(1377)
			p.Match(Java9ParserRPAREN)
		}

	}
	p.SetState(1381)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Java9ParserLBRACE {
		{
			p.SetState(1380)
			p.ClassBody()
		}

	}

	return localctx
}

// IEnumConstantModifierContext is an interface to support dynamic dispatch.
type IEnumConstantModifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEnumConstantModifierContext differentiates from other interfaces.
	IsEnumConstantModifierContext()
}

type EnumConstantModifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEnumConstantModifierContext() *EnumConstantModifierContext {
	var p = new(EnumConstantModifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Java9ParserRULE_enumConstantModifier
	return p
}

func (*EnumConstantModifierContext) IsEnumConstantModifierContext() {}

func NewEnumConstantModifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EnumConstantModifierContext {
	var p = new(EnumConstantModifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java9ParserRULE_enumConstantModifier

	return p
}

func (s *EnumConstantModifierContext) GetParser() antlr.Parser { return s.parser }

func (s *EnumConstantModifierContext) Annotation() IAnnotationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAnnotationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAnnotationContext)
}

func (s *EnumConstantModifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EnumConstantModifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EnumConstantModifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.EnterEnumConstantModifier(s)
	}
}

func (s *EnumConstantModifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.ExitEnumConstantModifier(s)
	}
}

func (p *Java9Parser) EnumConstantModifier() (localctx IEnumConstantModifierContext) {
	localctx = NewEnumConstantModifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 204, Java9ParserRULE_enumConstantModifier)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1383)
		p.Annotation()
	}

	return localctx
}

// IEnumBodyDeclarationsContext is an interface to support dynamic dispatch.
type IEnumBodyDeclarationsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEnumBodyDeclarationsContext differentiates from other interfaces.
	IsEnumBodyDeclarationsContext()
}

type EnumBodyDeclarationsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEnumBodyDeclarationsContext() *EnumBodyDeclarationsContext {
	var p = new(EnumBodyDeclarationsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Java9ParserRULE_enumBodyDeclarations
	return p
}

func (*EnumBodyDeclarationsContext) IsEnumBodyDeclarationsContext() {}

func NewEnumBodyDeclarationsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EnumBodyDeclarationsContext {
	var p = new(EnumBodyDeclarationsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java9ParserRULE_enumBodyDeclarations

	return p
}

func (s *EnumBodyDeclarationsContext) GetParser() antlr.Parser { return s.parser }

func (s *EnumBodyDeclarationsContext) SEMI() antlr.TerminalNode {
	return s.GetToken(Java9ParserSEMI, 0)
}

func (s *EnumBodyDeclarationsContext) AllClassBodyDeclaration() []IClassBodyDeclarationContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IClassBodyDeclarationContext)(nil)).Elem())
	var tst = make([]IClassBodyDeclarationContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IClassBodyDeclarationContext)
		}
	}

	return tst
}

func (s *EnumBodyDeclarationsContext) ClassBodyDeclaration(i int) IClassBodyDeclarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IClassBodyDeclarationContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IClassBodyDeclarationContext)
}

func (s *EnumBodyDeclarationsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EnumBodyDeclarationsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EnumBodyDeclarationsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.EnterEnumBodyDeclarations(s)
	}
}

func (s *EnumBodyDeclarationsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.ExitEnumBodyDeclarations(s)
	}
}

func (p *Java9Parser) EnumBodyDeclarations() (localctx IEnumBodyDeclarationsContext) {
	localctx = NewEnumBodyDeclarationsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 206, Java9ParserRULE_enumBodyDeclarations)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1385)
		p.Match(Java9ParserSEMI)
	}
	p.SetState(1389)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<Java9ParserABSTRACT)|(1<<Java9ParserBOOLEAN)|(1<<Java9ParserBYTE)|(1<<Java9ParserCHAR)|(1<<Java9ParserCLASS)|(1<<Java9ParserDOUBLE)|(1<<Java9ParserENUM)|(1<<Java9ParserEXPORTS)|(1<<Java9ParserFINAL)|(1<<Java9ParserFLOAT)|(1<<Java9ParserINT)|(1<<Java9ParserINTERFACE)|(1<<Java9ParserLONG)|(1<<Java9ParserMODULE))) != 0) || (((_la-32)&-(0x1f+1)) == 0 && ((1<<uint((_la-32)))&((1<<(Java9ParserNATIVE-32))|(1<<(Java9ParserOPEN-32))|(1<<(Java9ParserOPERNS-32))|(1<<(Java9ParserPRIVATE-32))|(1<<(Java9ParserPROTECTED-32))|(1<<(Java9ParserPROVIDES-32))|(1<<(Java9ParserPUBLIC-32))|(1<<(Java9ParserREQUIRES-32))|(1<<(Java9ParserSHORT-32))|(1<<(Java9ParserSTATIC-32))|(1<<(Java9ParserSTRICTFP-32))|(1<<(Java9ParserSYNCHRONIZED-32))|(1<<(Java9ParserTO-32))|(1<<(Java9ParserTRANSIENT-32))|(1<<(Java9ParserUSES-32))|(1<<(Java9ParserVOID-32))|(1<<(Java9ParserVOLATILE-32))|(1<<(Java9ParserWITH-32)))) != 0) || (((_la-70)&-(0x1f+1)) == 0 && ((1<<uint((_la-70)))&((1<<(Java9ParserLBRACE-70))|(1<<(Java9ParserSEMI-70))|(1<<(Java9ParserAT-70))|(1<<(Java9ParserLT-70)))) != 0) || _la == Java9ParserIdentifier {
		{
			p.SetState(1386)
			p.ClassBodyDeclaration()
		}

		p.SetState(1391)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IInterfaceDeclarationContext is an interface to support dynamic dispatch.
type IInterfaceDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsInterfaceDeclarationContext differentiates from other interfaces.
	IsInterfaceDeclarationContext()
}

type InterfaceDeclarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInterfaceDeclarationContext() *InterfaceDeclarationContext {
	var p = new(InterfaceDeclarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Java9ParserRULE_interfaceDeclaration
	return p
}

func (*InterfaceDeclarationContext) IsInterfaceDeclarationContext() {}

func NewInterfaceDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InterfaceDeclarationContext {
	var p = new(InterfaceDeclarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java9ParserRULE_interfaceDeclaration

	return p
}

func (s *InterfaceDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *InterfaceDeclarationContext) NormalInterfaceDeclaration() INormalInterfaceDeclarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INormalInterfaceDeclarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INormalInterfaceDeclarationContext)
}

func (s *InterfaceDeclarationContext) AnnotationTypeDeclaration() IAnnotationTypeDeclarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAnnotationTypeDeclarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAnnotationTypeDeclarationContext)
}

func (s *InterfaceDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InterfaceDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InterfaceDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.EnterInterfaceDeclaration(s)
	}
}

func (s *InterfaceDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.ExitInterfaceDeclaration(s)
	}
}

func (p *Java9Parser) InterfaceDeclaration() (localctx IInterfaceDeclarationContext) {
	localctx = NewInterfaceDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 208, Java9ParserRULE_interfaceDeclaration)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1394)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 136, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1392)
			p.NormalInterfaceDeclaration()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1393)
			p.AnnotationTypeDeclaration()
		}

	}

	return localctx
}

// INormalInterfaceDeclarationContext is an interface to support dynamic dispatch.
type INormalInterfaceDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsNormalInterfaceDeclarationContext differentiates from other interfaces.
	IsNormalInterfaceDeclarationContext()
}

type NormalInterfaceDeclarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNormalInterfaceDeclarationContext() *NormalInterfaceDeclarationContext {
	var p = new(NormalInterfaceDeclarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Java9ParserRULE_normalInterfaceDeclaration
	return p
}

func (*NormalInterfaceDeclarationContext) IsNormalInterfaceDeclarationContext() {}

func NewNormalInterfaceDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NormalInterfaceDeclarationContext {
	var p = new(NormalInterfaceDeclarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java9ParserRULE_normalInterfaceDeclaration

	return p
}

func (s *NormalInterfaceDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *NormalInterfaceDeclarationContext) INTERFACE() antlr.TerminalNode {
	return s.GetToken(Java9ParserINTERFACE, 0)
}

func (s *NormalInterfaceDeclarationContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *NormalInterfaceDeclarationContext) InterfaceBody() IInterfaceBodyContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInterfaceBodyContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInterfaceBodyContext)
}

func (s *NormalInterfaceDeclarationContext) AllInterfaceModifier() []IInterfaceModifierContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IInterfaceModifierContext)(nil)).Elem())
	var tst = make([]IInterfaceModifierContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IInterfaceModifierContext)
		}
	}

	return tst
}

func (s *NormalInterfaceDeclarationContext) InterfaceModifier(i int) IInterfaceModifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInterfaceModifierContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IInterfaceModifierContext)
}

func (s *NormalInterfaceDeclarationContext) TypeParameters() ITypeParametersContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypeParametersContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITypeParametersContext)
}

func (s *NormalInterfaceDeclarationContext) ExtendsInterfaces() IExtendsInterfacesContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExtendsInterfacesContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExtendsInterfacesContext)
}

func (s *NormalInterfaceDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NormalInterfaceDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NormalInterfaceDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.EnterNormalInterfaceDeclaration(s)
	}
}

func (s *NormalInterfaceDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.ExitNormalInterfaceDeclaration(s)
	}
}

func (p *Java9Parser) NormalInterfaceDeclaration() (localctx INormalInterfaceDeclarationContext) {
	localctx = NewNormalInterfaceDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 210, Java9ParserRULE_normalInterfaceDeclaration)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1399)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == Java9ParserABSTRACT || (((_la-37)&-(0x1f+1)) == 0 && ((1<<uint((_la-37)))&((1<<(Java9ParserPRIVATE-37))|(1<<(Java9ParserPROTECTED-37))|(1<<(Java9ParserPUBLIC-37))|(1<<(Java9ParserSTATIC-37))|(1<<(Java9ParserSTRICTFP-37)))) != 0) || _la == Java9ParserAT {
		{
			p.SetState(1396)
			p.InterfaceModifier()
		}

		p.SetState(1401)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1402)
		p.Match(Java9ParserINTERFACE)
	}
	{
		p.SetState(1403)
		p.Identifier()
	}
	p.SetState(1405)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Java9ParserLT {
		{
			p.SetState(1404)
			p.TypeParameters()
		}

	}
	p.SetState(1408)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Java9ParserEXTENDS {
		{
			p.SetState(1407)
			p.ExtendsInterfaces()
		}

	}
	{
		p.SetState(1410)
		p.InterfaceBody()
	}

	return localctx
}

// IInterfaceModifierContext is an interface to support dynamic dispatch.
type IInterfaceModifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsInterfaceModifierContext differentiates from other interfaces.
	IsInterfaceModifierContext()
}

type InterfaceModifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInterfaceModifierContext() *InterfaceModifierContext {
	var p = new(InterfaceModifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Java9ParserRULE_interfaceModifier
	return p
}

func (*InterfaceModifierContext) IsInterfaceModifierContext() {}

func NewInterfaceModifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InterfaceModifierContext {
	var p = new(InterfaceModifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java9ParserRULE_interfaceModifier

	return p
}

func (s *InterfaceModifierContext) GetParser() antlr.Parser { return s.parser }

func (s *InterfaceModifierContext) Annotation() IAnnotationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAnnotationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAnnotationContext)
}

func (s *InterfaceModifierContext) PUBLIC() antlr.TerminalNode {
	return s.GetToken(Java9ParserPUBLIC, 0)
}

func (s *InterfaceModifierContext) PROTECTED() antlr.TerminalNode {
	return s.GetToken(Java9ParserPROTECTED, 0)
}

func (s *InterfaceModifierContext) PRIVATE() antlr.TerminalNode {
	return s.GetToken(Java9ParserPRIVATE, 0)
}

func (s *InterfaceModifierContext) ABSTRACT() antlr.TerminalNode {
	return s.GetToken(Java9ParserABSTRACT, 0)
}

func (s *InterfaceModifierContext) STATIC() antlr.TerminalNode {
	return s.GetToken(Java9ParserSTATIC, 0)
}

func (s *InterfaceModifierContext) STRICTFP() antlr.TerminalNode {
	return s.GetToken(Java9ParserSTRICTFP, 0)
}

func (s *InterfaceModifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InterfaceModifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InterfaceModifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.EnterInterfaceModifier(s)
	}
}

func (s *InterfaceModifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.ExitInterfaceModifier(s)
	}
}

func (p *Java9Parser) InterfaceModifier() (localctx IInterfaceModifierContext) {
	localctx = NewInterfaceModifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 212, Java9ParserRULE_interfaceModifier)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1419)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case Java9ParserAT:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1412)
			p.Annotation()
		}

	case Java9ParserPUBLIC:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1413)
			p.Match(Java9ParserPUBLIC)
		}

	case Java9ParserPROTECTED:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1414)
			p.Match(Java9ParserPROTECTED)
		}

	case Java9ParserPRIVATE:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1415)
			p.Match(Java9ParserPRIVATE)
		}

	case Java9ParserABSTRACT:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1416)
			p.Match(Java9ParserABSTRACT)
		}

	case Java9ParserSTATIC:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(1417)
			p.Match(Java9ParserSTATIC)
		}

	case Java9ParserSTRICTFP:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(1418)
			p.Match(Java9ParserSTRICTFP)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IExtendsInterfacesContext is an interface to support dynamic dispatch.
type IExtendsInterfacesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExtendsInterfacesContext differentiates from other interfaces.
	IsExtendsInterfacesContext()
}

type ExtendsInterfacesContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExtendsInterfacesContext() *ExtendsInterfacesContext {
	var p = new(ExtendsInterfacesContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Java9ParserRULE_extendsInterfaces
	return p
}

func (*ExtendsInterfacesContext) IsExtendsInterfacesContext() {}

func NewExtendsInterfacesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExtendsInterfacesContext {
	var p = new(ExtendsInterfacesContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java9ParserRULE_extendsInterfaces

	return p
}

func (s *ExtendsInterfacesContext) GetParser() antlr.Parser { return s.parser }

func (s *ExtendsInterfacesContext) EXTENDS() antlr.TerminalNode {
	return s.GetToken(Java9ParserEXTENDS, 0)
}

func (s *ExtendsInterfacesContext) InterfaceTypeList() IInterfaceTypeListContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInterfaceTypeListContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInterfaceTypeListContext)
}

func (s *ExtendsInterfacesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExtendsInterfacesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExtendsInterfacesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.EnterExtendsInterfaces(s)
	}
}

func (s *ExtendsInterfacesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.ExitExtendsInterfaces(s)
	}
}

func (p *Java9Parser) ExtendsInterfaces() (localctx IExtendsInterfacesContext) {
	localctx = NewExtendsInterfacesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 214, Java9ParserRULE_extendsInterfaces)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1421)
		p.Match(Java9ParserEXTENDS)
	}
	{
		p.SetState(1422)
		p.InterfaceTypeList()
	}

	return localctx
}

// IInterfaceBodyContext is an interface to support dynamic dispatch.
type IInterfaceBodyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsInterfaceBodyContext differentiates from other interfaces.
	IsInterfaceBodyContext()
}

type InterfaceBodyContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInterfaceBodyContext() *InterfaceBodyContext {
	var p = new(InterfaceBodyContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Java9ParserRULE_interfaceBody
	return p
}

func (*InterfaceBodyContext) IsInterfaceBodyContext() {}

func NewInterfaceBodyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InterfaceBodyContext {
	var p = new(InterfaceBodyContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java9ParserRULE_interfaceBody

	return p
}

func (s *InterfaceBodyContext) GetParser() antlr.Parser { return s.parser }

func (s *InterfaceBodyContext) LBRACE() antlr.TerminalNode {
	return s.GetToken(Java9ParserLBRACE, 0)
}

func (s *InterfaceBodyContext) RBRACE() antlr.TerminalNode {
	return s.GetToken(Java9ParserRBRACE, 0)
}

func (s *InterfaceBodyContext) AllInterfaceMemberDeclaration() []IInterfaceMemberDeclarationContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IInterfaceMemberDeclarationContext)(nil)).Elem())
	var tst = make([]IInterfaceMemberDeclarationContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IInterfaceMemberDeclarationContext)
		}
	}

	return tst
}

func (s *InterfaceBodyContext) InterfaceMemberDeclaration(i int) IInterfaceMemberDeclarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInterfaceMemberDeclarationContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IInterfaceMemberDeclarationContext)
}

func (s *InterfaceBodyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InterfaceBodyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InterfaceBodyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.EnterInterfaceBody(s)
	}
}

func (s *InterfaceBodyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.ExitInterfaceBody(s)
	}
}

func (p *Java9Parser) InterfaceBody() (localctx IInterfaceBodyContext) {
	localctx = NewInterfaceBodyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 216, Java9ParserRULE_interfaceBody)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1424)
		p.Match(Java9ParserLBRACE)
	}
	p.SetState(1428)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<Java9ParserABSTRACT)|(1<<Java9ParserBOOLEAN)|(1<<Java9ParserBYTE)|(1<<Java9ParserCHAR)|(1<<Java9ParserCLASS)|(1<<Java9ParserDEFAULT)|(1<<Java9ParserDOUBLE)|(1<<Java9ParserENUM)|(1<<Java9ParserEXPORTS)|(1<<Java9ParserFINAL)|(1<<Java9ParserFLOAT)|(1<<Java9ParserINT)|(1<<Java9ParserINTERFACE)|(1<<Java9ParserLONG)|(1<<Java9ParserMODULE))) != 0) || (((_la-34)&-(0x1f+1)) == 0 && ((1<<uint((_la-34)))&((1<<(Java9ParserOPEN-34))|(1<<(Java9ParserOPERNS-34))|(1<<(Java9ParserPRIVATE-34))|(1<<(Java9ParserPROTECTED-34))|(1<<(Java9ParserPROVIDES-34))|(1<<(Java9ParserPUBLIC-34))|(1<<(Java9ParserREQUIRES-34))|(1<<(Java9ParserSHORT-34))|(1<<(Java9ParserSTATIC-34))|(1<<(Java9ParserSTRICTFP-34))|(1<<(Java9ParserTO-34))|(1<<(Java9ParserUSES-34))|(1<<(Java9ParserVOID-34))|(1<<(Java9ParserWITH-34)))) != 0) || (((_la-74)&-(0x1f+1)) == 0 && ((1<<uint((_la-74)))&((1<<(Java9ParserSEMI-74))|(1<<(Java9ParserAT-74))|(1<<(Java9ParserLT-74)))) != 0) || _la == Java9ParserIdentifier {
		{
			p.SetState(1425)
			p.InterfaceMemberDeclaration()
		}

		p.SetState(1430)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1431)
		p.Match(Java9ParserRBRACE)
	}

	return localctx
}

// IInterfaceMemberDeclarationContext is an interface to support dynamic dispatch.
type IInterfaceMemberDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsInterfaceMemberDeclarationContext differentiates from other interfaces.
	IsInterfaceMemberDeclarationContext()
}

type InterfaceMemberDeclarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInterfaceMemberDeclarationContext() *InterfaceMemberDeclarationContext {
	var p = new(InterfaceMemberDeclarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Java9ParserRULE_interfaceMemberDeclaration
	return p
}

func (*InterfaceMemberDeclarationContext) IsInterfaceMemberDeclarationContext() {}

func NewInterfaceMemberDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InterfaceMemberDeclarationContext {
	var p = new(InterfaceMemberDeclarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java9ParserRULE_interfaceMemberDeclaration

	return p
}

func (s *InterfaceMemberDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *InterfaceMemberDeclarationContext) ConstantDeclaration() IConstantDeclarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConstantDeclarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConstantDeclarationContext)
}

func (s *InterfaceMemberDeclarationContext) InterfaceMethodDeclaration() IInterfaceMethodDeclarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInterfaceMethodDeclarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInterfaceMethodDeclarationContext)
}

func (s *InterfaceMemberDeclarationContext) ClassDeclaration() IClassDeclarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IClassDeclarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IClassDeclarationContext)
}

func (s *InterfaceMemberDeclarationContext) InterfaceDeclaration() IInterfaceDeclarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInterfaceDeclarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInterfaceDeclarationContext)
}

func (s *InterfaceMemberDeclarationContext) SEMI() antlr.TerminalNode {
	return s.GetToken(Java9ParserSEMI, 0)
}

func (s *InterfaceMemberDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InterfaceMemberDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InterfaceMemberDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.EnterInterfaceMemberDeclaration(s)
	}
}

func (s *InterfaceMemberDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.ExitInterfaceMemberDeclaration(s)
	}
}

func (p *Java9Parser) InterfaceMemberDeclaration() (localctx IInterfaceMemberDeclarationContext) {
	localctx = NewInterfaceMemberDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 218, Java9ParserRULE_interfaceMemberDeclaration)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1438)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 142, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1433)
			p.ConstantDeclaration()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1434)
			p.InterfaceMethodDeclaration()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1435)
			p.ClassDeclaration()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1436)
			p.InterfaceDeclaration()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1437)
			p.Match(Java9ParserSEMI)
		}

	}

	return localctx
}

// IConstantDeclarationContext is an interface to support dynamic dispatch.
type IConstantDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsConstantDeclarationContext differentiates from other interfaces.
	IsConstantDeclarationContext()
}

type ConstantDeclarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConstantDeclarationContext() *ConstantDeclarationContext {
	var p = new(ConstantDeclarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Java9ParserRULE_constantDeclaration
	return p
}

func (*ConstantDeclarationContext) IsConstantDeclarationContext() {}

func NewConstantDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ConstantDeclarationContext {
	var p = new(ConstantDeclarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java9ParserRULE_constantDeclaration

	return p
}

func (s *ConstantDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *ConstantDeclarationContext) UnannType() IUnannTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUnannTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IUnannTypeContext)
}

func (s *ConstantDeclarationContext) VariableDeclaratorList() IVariableDeclaratorListContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVariableDeclaratorListContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IVariableDeclaratorListContext)
}

func (s *ConstantDeclarationContext) SEMI() antlr.TerminalNode {
	return s.GetToken(Java9ParserSEMI, 0)
}

func (s *ConstantDeclarationContext) AllConstantModifier() []IConstantModifierContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IConstantModifierContext)(nil)).Elem())
	var tst = make([]IConstantModifierContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IConstantModifierContext)
		}
	}

	return tst
}

func (s *ConstantDeclarationContext) ConstantModifier(i int) IConstantModifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConstantModifierContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IConstantModifierContext)
}

func (s *ConstantDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ConstantDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ConstantDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.EnterConstantDeclaration(s)
	}
}

func (s *ConstantDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.ExitConstantDeclaration(s)
	}
}

func (p *Java9Parser) ConstantDeclaration() (localctx IConstantDeclarationContext) {
	localctx = NewConstantDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 220, Java9ParserRULE_constantDeclaration)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1443)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for (((_la-19)&-(0x1f+1)) == 0 && ((1<<uint((_la-19)))&((1<<(Java9ParserFINAL-19))|(1<<(Java9ParserPUBLIC-19))|(1<<(Java9ParserSTATIC-19)))) != 0) || _la == Java9ParserAT {
		{
			p.SetState(1440)
			p.ConstantModifier()
		}

		p.SetState(1445)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1446)
		p.UnannType()
	}
	{
		p.SetState(1447)
		p.VariableDeclaratorList()
	}
	{
		p.SetState(1448)
		p.Match(Java9ParserSEMI)
	}

	return localctx
}

// IConstantModifierContext is an interface to support dynamic dispatch.
type IConstantModifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsConstantModifierContext differentiates from other interfaces.
	IsConstantModifierContext()
}

type ConstantModifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConstantModifierContext() *ConstantModifierContext {
	var p = new(ConstantModifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Java9ParserRULE_constantModifier
	return p
}

func (*ConstantModifierContext) IsConstantModifierContext() {}

func NewConstantModifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ConstantModifierContext {
	var p = new(ConstantModifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java9ParserRULE_constantModifier

	return p
}

func (s *ConstantModifierContext) GetParser() antlr.Parser { return s.parser }

func (s *ConstantModifierContext) Annotation() IAnnotationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAnnotationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAnnotationContext)
}

func (s *ConstantModifierContext) PUBLIC() antlr.TerminalNode {
	return s.GetToken(Java9ParserPUBLIC, 0)
}

func (s *ConstantModifierContext) STATIC() antlr.TerminalNode {
	return s.GetToken(Java9ParserSTATIC, 0)
}

func (s *ConstantModifierContext) FINAL() antlr.TerminalNode {
	return s.GetToken(Java9ParserFINAL, 0)
}

func (s *ConstantModifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ConstantModifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ConstantModifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.EnterConstantModifier(s)
	}
}

func (s *ConstantModifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.ExitConstantModifier(s)
	}
}

func (p *Java9Parser) ConstantModifier() (localctx IConstantModifierContext) {
	localctx = NewConstantModifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 222, Java9ParserRULE_constantModifier)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1454)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case Java9ParserAT:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1450)
			p.Annotation()
		}

	case Java9ParserPUBLIC:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1451)
			p.Match(Java9ParserPUBLIC)
		}

	case Java9ParserSTATIC:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1452)
			p.Match(Java9ParserSTATIC)
		}

	case Java9ParserFINAL:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1453)
			p.Match(Java9ParserFINAL)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IInterfaceMethodDeclarationContext is an interface to support dynamic dispatch.
type IInterfaceMethodDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsInterfaceMethodDeclarationContext differentiates from other interfaces.
	IsInterfaceMethodDeclarationContext()
}

type InterfaceMethodDeclarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInterfaceMethodDeclarationContext() *InterfaceMethodDeclarationContext {
	var p = new(InterfaceMethodDeclarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Java9ParserRULE_interfaceMethodDeclaration
	return p
}

func (*InterfaceMethodDeclarationContext) IsInterfaceMethodDeclarationContext() {}

func NewInterfaceMethodDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InterfaceMethodDeclarationContext {
	var p = new(InterfaceMethodDeclarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java9ParserRULE_interfaceMethodDeclaration

	return p
}

func (s *InterfaceMethodDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *InterfaceMethodDeclarationContext) MethodHeader() IMethodHeaderContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMethodHeaderContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMethodHeaderContext)
}

func (s *InterfaceMethodDeclarationContext) MethodBody() IMethodBodyContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMethodBodyContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMethodBodyContext)
}

func (s *InterfaceMethodDeclarationContext) AllInterfaceMethodModifier() []IInterfaceMethodModifierContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IInterfaceMethodModifierContext)(nil)).Elem())
	var tst = make([]IInterfaceMethodModifierContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IInterfaceMethodModifierContext)
		}
	}

	return tst
}

func (s *InterfaceMethodDeclarationContext) InterfaceMethodModifier(i int) IInterfaceMethodModifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInterfaceMethodModifierContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IInterfaceMethodModifierContext)
}

func (s *InterfaceMethodDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InterfaceMethodDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InterfaceMethodDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.EnterInterfaceMethodDeclaration(s)
	}
}

func (s *InterfaceMethodDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.ExitInterfaceMethodDeclaration(s)
	}
}

func (p *Java9Parser) InterfaceMethodDeclaration() (localctx IInterfaceMethodDeclarationContext) {
	localctx = NewInterfaceMethodDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 224, Java9ParserRULE_interfaceMethodDeclaration)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1459)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == Java9ParserABSTRACT || _la == Java9ParserDEFAULT || (((_la-37)&-(0x1f+1)) == 0 && ((1<<uint((_la-37)))&((1<<(Java9ParserPRIVATE-37))|(1<<(Java9ParserPUBLIC-37))|(1<<(Java9ParserSTATIC-37))|(1<<(Java9ParserSTRICTFP-37)))) != 0) || _la == Java9ParserAT {
		{
			p.SetState(1456)
			p.InterfaceMethodModifier()
		}

		p.SetState(1461)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1462)
		p.MethodHeader()
	}
	{
		p.SetState(1463)
		p.MethodBody()
	}

	return localctx
}

// IInterfaceMethodModifierContext is an interface to support dynamic dispatch.
type IInterfaceMethodModifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsInterfaceMethodModifierContext differentiates from other interfaces.
	IsInterfaceMethodModifierContext()
}

type InterfaceMethodModifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInterfaceMethodModifierContext() *InterfaceMethodModifierContext {
	var p = new(InterfaceMethodModifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Java9ParserRULE_interfaceMethodModifier
	return p
}

func (*InterfaceMethodModifierContext) IsInterfaceMethodModifierContext() {}

func NewInterfaceMethodModifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InterfaceMethodModifierContext {
	var p = new(InterfaceMethodModifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java9ParserRULE_interfaceMethodModifier

	return p
}

func (s *InterfaceMethodModifierContext) GetParser() antlr.Parser { return s.parser }

func (s *InterfaceMethodModifierContext) Annotation() IAnnotationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAnnotationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAnnotationContext)
}

func (s *InterfaceMethodModifierContext) PUBLIC() antlr.TerminalNode {
	return s.GetToken(Java9ParserPUBLIC, 0)
}

func (s *InterfaceMethodModifierContext) PRIVATE() antlr.TerminalNode {
	return s.GetToken(Java9ParserPRIVATE, 0)
}

func (s *InterfaceMethodModifierContext) ABSTRACT() antlr.TerminalNode {
	return s.GetToken(Java9ParserABSTRACT, 0)
}

func (s *InterfaceMethodModifierContext) DEFAULT() antlr.TerminalNode {
	return s.GetToken(Java9ParserDEFAULT, 0)
}

func (s *InterfaceMethodModifierContext) STATIC() antlr.TerminalNode {
	return s.GetToken(Java9ParserSTATIC, 0)
}

func (s *InterfaceMethodModifierContext) STRICTFP() antlr.TerminalNode {
	return s.GetToken(Java9ParserSTRICTFP, 0)
}

func (s *InterfaceMethodModifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InterfaceMethodModifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InterfaceMethodModifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.EnterInterfaceMethodModifier(s)
	}
}

func (s *InterfaceMethodModifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.ExitInterfaceMethodModifier(s)
	}
}

func (p *Java9Parser) InterfaceMethodModifier() (localctx IInterfaceMethodModifierContext) {
	localctx = NewInterfaceMethodModifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 226, Java9ParserRULE_interfaceMethodModifier)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1472)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case Java9ParserAT:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1465)
			p.Annotation()
		}

	case Java9ParserPUBLIC:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1466)
			p.Match(Java9ParserPUBLIC)
		}

	case Java9ParserPRIVATE:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1467)
			p.Match(Java9ParserPRIVATE)
		}

	case Java9ParserABSTRACT:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1468)
			p.Match(Java9ParserABSTRACT)
		}

	case Java9ParserDEFAULT:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1469)
			p.Match(Java9ParserDEFAULT)
		}

	case Java9ParserSTATIC:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(1470)
			p.Match(Java9ParserSTATIC)
		}

	case Java9ParserSTRICTFP:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(1471)
			p.Match(Java9ParserSTRICTFP)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IAnnotationTypeDeclarationContext is an interface to support dynamic dispatch.
type IAnnotationTypeDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAnnotationTypeDeclarationContext differentiates from other interfaces.
	IsAnnotationTypeDeclarationContext()
}

type AnnotationTypeDeclarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAnnotationTypeDeclarationContext() *AnnotationTypeDeclarationContext {
	var p = new(AnnotationTypeDeclarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Java9ParserRULE_annotationTypeDeclaration
	return p
}

func (*AnnotationTypeDeclarationContext) IsAnnotationTypeDeclarationContext() {}

func NewAnnotationTypeDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AnnotationTypeDeclarationContext {
	var p = new(AnnotationTypeDeclarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java9ParserRULE_annotationTypeDeclaration

	return p
}

func (s *AnnotationTypeDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *AnnotationTypeDeclarationContext) AT() antlr.TerminalNode {
	return s.GetToken(Java9ParserAT, 0)
}

func (s *AnnotationTypeDeclarationContext) INTERFACE() antlr.TerminalNode {
	return s.GetToken(Java9ParserINTERFACE, 0)
}

func (s *AnnotationTypeDeclarationContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *AnnotationTypeDeclarationContext) AnnotationTypeBody() IAnnotationTypeBodyContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAnnotationTypeBodyContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAnnotationTypeBodyContext)
}

func (s *AnnotationTypeDeclarationContext) AllInterfaceModifier() []IInterfaceModifierContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IInterfaceModifierContext)(nil)).Elem())
	var tst = make([]IInterfaceModifierContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IInterfaceModifierContext)
		}
	}

	return tst
}

func (s *AnnotationTypeDeclarationContext) InterfaceModifier(i int) IInterfaceModifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInterfaceModifierContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IInterfaceModifierContext)
}

func (s *AnnotationTypeDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AnnotationTypeDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AnnotationTypeDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.EnterAnnotationTypeDeclaration(s)
	}
}

func (s *AnnotationTypeDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.ExitAnnotationTypeDeclaration(s)
	}
}

func (p *Java9Parser) AnnotationTypeDeclaration() (localctx IAnnotationTypeDeclarationContext) {
	localctx = NewAnnotationTypeDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 228, Java9ParserRULE_annotationTypeDeclaration)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1477)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 147, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1474)
				p.InterfaceModifier()
			}

		}
		p.SetState(1479)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 147, p.GetParserRuleContext())
	}
	{
		p.SetState(1480)
		p.Match(Java9ParserAT)
	}
	{
		p.SetState(1481)
		p.Match(Java9ParserINTERFACE)
	}
	{
		p.SetState(1482)
		p.Identifier()
	}
	{
		p.SetState(1483)
		p.AnnotationTypeBody()
	}

	return localctx
}

// IAnnotationTypeBodyContext is an interface to support dynamic dispatch.
type IAnnotationTypeBodyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAnnotationTypeBodyContext differentiates from other interfaces.
	IsAnnotationTypeBodyContext()
}

type AnnotationTypeBodyContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAnnotationTypeBodyContext() *AnnotationTypeBodyContext {
	var p = new(AnnotationTypeBodyContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Java9ParserRULE_annotationTypeBody
	return p
}

func (*AnnotationTypeBodyContext) IsAnnotationTypeBodyContext() {}

func NewAnnotationTypeBodyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AnnotationTypeBodyContext {
	var p = new(AnnotationTypeBodyContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java9ParserRULE_annotationTypeBody

	return p
}

func (s *AnnotationTypeBodyContext) GetParser() antlr.Parser { return s.parser }

func (s *AnnotationTypeBodyContext) LBRACE() antlr.TerminalNode {
	return s.GetToken(Java9ParserLBRACE, 0)
}

func (s *AnnotationTypeBodyContext) RBRACE() antlr.TerminalNode {
	return s.GetToken(Java9ParserRBRACE, 0)
}

func (s *AnnotationTypeBodyContext) AllAnnotationTypeMemberDeclaration() []IAnnotationTypeMemberDeclarationContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAnnotationTypeMemberDeclarationContext)(nil)).Elem())
	var tst = make([]IAnnotationTypeMemberDeclarationContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAnnotationTypeMemberDeclarationContext)
		}
	}

	return tst
}

func (s *AnnotationTypeBodyContext) AnnotationTypeMemberDeclaration(i int) IAnnotationTypeMemberDeclarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAnnotationTypeMemberDeclarationContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAnnotationTypeMemberDeclarationContext)
}

func (s *AnnotationTypeBodyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AnnotationTypeBodyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AnnotationTypeBodyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.EnterAnnotationTypeBody(s)
	}
}

func (s *AnnotationTypeBodyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.ExitAnnotationTypeBody(s)
	}
}

func (p *Java9Parser) AnnotationTypeBody() (localctx IAnnotationTypeBodyContext) {
	localctx = NewAnnotationTypeBodyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 230, Java9ParserRULE_annotationTypeBody)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1485)
		p.Match(Java9ParserLBRACE)
	}
	p.SetState(1489)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<Java9ParserABSTRACT)|(1<<Java9ParserBOOLEAN)|(1<<Java9ParserBYTE)|(1<<Java9ParserCHAR)|(1<<Java9ParserCLASS)|(1<<Java9ParserDOUBLE)|(1<<Java9ParserENUM)|(1<<Java9ParserEXPORTS)|(1<<Java9ParserFINAL)|(1<<Java9ParserFLOAT)|(1<<Java9ParserINT)|(1<<Java9ParserINTERFACE)|(1<<Java9ParserLONG)|(1<<Java9ParserMODULE))) != 0) || (((_la-34)&-(0x1f+1)) == 0 && ((1<<uint((_la-34)))&((1<<(Java9ParserOPEN-34))|(1<<(Java9ParserOPERNS-34))|(1<<(Java9ParserPRIVATE-34))|(1<<(Java9ParserPROTECTED-34))|(1<<(Java9ParserPROVIDES-34))|(1<<(Java9ParserPUBLIC-34))|(1<<(Java9ParserREQUIRES-34))|(1<<(Java9ParserSHORT-34))|(1<<(Java9ParserSTATIC-34))|(1<<(Java9ParserSTRICTFP-34))|(1<<(Java9ParserTO-34))|(1<<(Java9ParserUSES-34))|(1<<(Java9ParserWITH-34)))) != 0) || _la == Java9ParserSEMI || _la == Java9ParserAT || _la == Java9ParserIdentifier {
		{
			p.SetState(1486)
			p.AnnotationTypeMemberDeclaration()
		}

		p.SetState(1491)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1492)
		p.Match(Java9ParserRBRACE)
	}

	return localctx
}

// IAnnotationTypeMemberDeclarationContext is an interface to support dynamic dispatch.
type IAnnotationTypeMemberDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAnnotationTypeMemberDeclarationContext differentiates from other interfaces.
	IsAnnotationTypeMemberDeclarationContext()
}

type AnnotationTypeMemberDeclarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAnnotationTypeMemberDeclarationContext() *AnnotationTypeMemberDeclarationContext {
	var p = new(AnnotationTypeMemberDeclarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Java9ParserRULE_annotationTypeMemberDeclaration
	return p
}

func (*AnnotationTypeMemberDeclarationContext) IsAnnotationTypeMemberDeclarationContext() {}

func NewAnnotationTypeMemberDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AnnotationTypeMemberDeclarationContext {
	var p = new(AnnotationTypeMemberDeclarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java9ParserRULE_annotationTypeMemberDeclaration

	return p
}

func (s *AnnotationTypeMemberDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *AnnotationTypeMemberDeclarationContext) AnnotationTypeElementDeclaration() IAnnotationTypeElementDeclarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAnnotationTypeElementDeclarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAnnotationTypeElementDeclarationContext)
}

func (s *AnnotationTypeMemberDeclarationContext) ConstantDeclaration() IConstantDeclarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConstantDeclarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConstantDeclarationContext)
}

func (s *AnnotationTypeMemberDeclarationContext) ClassDeclaration() IClassDeclarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IClassDeclarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IClassDeclarationContext)
}

func (s *AnnotationTypeMemberDeclarationContext) InterfaceDeclaration() IInterfaceDeclarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInterfaceDeclarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInterfaceDeclarationContext)
}

func (s *AnnotationTypeMemberDeclarationContext) SEMI() antlr.TerminalNode {
	return s.GetToken(Java9ParserSEMI, 0)
}

func (s *AnnotationTypeMemberDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AnnotationTypeMemberDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AnnotationTypeMemberDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.EnterAnnotationTypeMemberDeclaration(s)
	}
}

func (s *AnnotationTypeMemberDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.ExitAnnotationTypeMemberDeclaration(s)
	}
}

func (p *Java9Parser) AnnotationTypeMemberDeclaration() (localctx IAnnotationTypeMemberDeclarationContext) {
	localctx = NewAnnotationTypeMemberDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 232, Java9ParserRULE_annotationTypeMemberDeclaration)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1499)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 149, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1494)
			p.AnnotationTypeElementDeclaration()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1495)
			p.ConstantDeclaration()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1496)
			p.ClassDeclaration()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1497)
			p.InterfaceDeclaration()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1498)
			p.Match(Java9ParserSEMI)
		}

	}

	return localctx
}

// IAnnotationTypeElementDeclarationContext is an interface to support dynamic dispatch.
type IAnnotationTypeElementDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAnnotationTypeElementDeclarationContext differentiates from other interfaces.
	IsAnnotationTypeElementDeclarationContext()
}

type AnnotationTypeElementDeclarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAnnotationTypeElementDeclarationContext() *AnnotationTypeElementDeclarationContext {
	var p = new(AnnotationTypeElementDeclarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Java9ParserRULE_annotationTypeElementDeclaration
	return p
}

func (*AnnotationTypeElementDeclarationContext) IsAnnotationTypeElementDeclarationContext() {}

func NewAnnotationTypeElementDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AnnotationTypeElementDeclarationContext {
	var p = new(AnnotationTypeElementDeclarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java9ParserRULE_annotationTypeElementDeclaration

	return p
}

func (s *AnnotationTypeElementDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *AnnotationTypeElementDeclarationContext) UnannType() IUnannTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUnannTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IUnannTypeContext)
}

func (s *AnnotationTypeElementDeclarationContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *AnnotationTypeElementDeclarationContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(Java9ParserLPAREN, 0)
}

func (s *AnnotationTypeElementDeclarationContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(Java9ParserRPAREN, 0)
}

func (s *AnnotationTypeElementDeclarationContext) SEMI() antlr.TerminalNode {
	return s.GetToken(Java9ParserSEMI, 0)
}

func (s *AnnotationTypeElementDeclarationContext) AllAnnotationTypeElementModifier() []IAnnotationTypeElementModifierContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAnnotationTypeElementModifierContext)(nil)).Elem())
	var tst = make([]IAnnotationTypeElementModifierContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAnnotationTypeElementModifierContext)
		}
	}

	return tst
}

func (s *AnnotationTypeElementDeclarationContext) AnnotationTypeElementModifier(i int) IAnnotationTypeElementModifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAnnotationTypeElementModifierContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAnnotationTypeElementModifierContext)
}

func (s *AnnotationTypeElementDeclarationContext) Dims() IDimsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDimsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDimsContext)
}

func (s *AnnotationTypeElementDeclarationContext) DefaultValue() IDefaultValueContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDefaultValueContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDefaultValueContext)
}

func (s *AnnotationTypeElementDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AnnotationTypeElementDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AnnotationTypeElementDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.EnterAnnotationTypeElementDeclaration(s)
	}
}

func (s *AnnotationTypeElementDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.ExitAnnotationTypeElementDeclaration(s)
	}
}

func (p *Java9Parser) AnnotationTypeElementDeclaration() (localctx IAnnotationTypeElementDeclarationContext) {
	localctx = NewAnnotationTypeElementDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 234, Java9ParserRULE_annotationTypeElementDeclaration)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1504)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == Java9ParserABSTRACT || _la == Java9ParserPUBLIC || _la == Java9ParserAT {
		{
			p.SetState(1501)
			p.AnnotationTypeElementModifier()
		}

		p.SetState(1506)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1507)
		p.UnannType()
	}
	{
		p.SetState(1508)
		p.Identifier()
	}
	{
		p.SetState(1509)
		p.Match(Java9ParserLPAREN)
	}
	{
		p.SetState(1510)
		p.Match(Java9ParserRPAREN)
	}
	p.SetState(1512)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Java9ParserLBRACK || _la == Java9ParserAT {
		{
			p.SetState(1511)
			p.Dims()
		}

	}
	p.SetState(1515)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Java9ParserDEFAULT {
		{
			p.SetState(1514)
			p.DefaultValue()
		}

	}
	{
		p.SetState(1517)
		p.Match(Java9ParserSEMI)
	}

	return localctx
}

// IAnnotationTypeElementModifierContext is an interface to support dynamic dispatch.
type IAnnotationTypeElementModifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAnnotationTypeElementModifierContext differentiates from other interfaces.
	IsAnnotationTypeElementModifierContext()
}

type AnnotationTypeElementModifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAnnotationTypeElementModifierContext() *AnnotationTypeElementModifierContext {
	var p = new(AnnotationTypeElementModifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Java9ParserRULE_annotationTypeElementModifier
	return p
}

func (*AnnotationTypeElementModifierContext) IsAnnotationTypeElementModifierContext() {}

func NewAnnotationTypeElementModifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AnnotationTypeElementModifierContext {
	var p = new(AnnotationTypeElementModifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java9ParserRULE_annotationTypeElementModifier

	return p
}

func (s *AnnotationTypeElementModifierContext) GetParser() antlr.Parser { return s.parser }

func (s *AnnotationTypeElementModifierContext) Annotation() IAnnotationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAnnotationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAnnotationContext)
}

func (s *AnnotationTypeElementModifierContext) PUBLIC() antlr.TerminalNode {
	return s.GetToken(Java9ParserPUBLIC, 0)
}

func (s *AnnotationTypeElementModifierContext) ABSTRACT() antlr.TerminalNode {
	return s.GetToken(Java9ParserABSTRACT, 0)
}

func (s *AnnotationTypeElementModifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AnnotationTypeElementModifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AnnotationTypeElementModifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.EnterAnnotationTypeElementModifier(s)
	}
}

func (s *AnnotationTypeElementModifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.ExitAnnotationTypeElementModifier(s)
	}
}

func (p *Java9Parser) AnnotationTypeElementModifier() (localctx IAnnotationTypeElementModifierContext) {
	localctx = NewAnnotationTypeElementModifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 236, Java9ParserRULE_annotationTypeElementModifier)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1522)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case Java9ParserAT:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1519)
			p.Annotation()
		}

	case Java9ParserPUBLIC:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1520)
			p.Match(Java9ParserPUBLIC)
		}

	case Java9ParserABSTRACT:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1521)
			p.Match(Java9ParserABSTRACT)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IDefaultValueContext is an interface to support dynamic dispatch.
type IDefaultValueContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDefaultValueContext differentiates from other interfaces.
	IsDefaultValueContext()
}

type DefaultValueContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDefaultValueContext() *DefaultValueContext {
	var p = new(DefaultValueContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Java9ParserRULE_defaultValue
	return p
}

func (*DefaultValueContext) IsDefaultValueContext() {}

func NewDefaultValueContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DefaultValueContext {
	var p = new(DefaultValueContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java9ParserRULE_defaultValue

	return p
}

func (s *DefaultValueContext) GetParser() antlr.Parser { return s.parser }

func (s *DefaultValueContext) DEFAULT() antlr.TerminalNode {
	return s.GetToken(Java9ParserDEFAULT, 0)
}

func (s *DefaultValueContext) ElementValue() IElementValueContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IElementValueContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IElementValueContext)
}

func (s *DefaultValueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DefaultValueContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DefaultValueContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.EnterDefaultValue(s)
	}
}

func (s *DefaultValueContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.ExitDefaultValue(s)
	}
}

func (p *Java9Parser) DefaultValue() (localctx IDefaultValueContext) {
	localctx = NewDefaultValueContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 238, Java9ParserRULE_defaultValue)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1524)
		p.Match(Java9ParserDEFAULT)
	}
	{
		p.SetState(1525)
		p.ElementValue()
	}

	return localctx
}

// IAnnotationContext is an interface to support dynamic dispatch.
type IAnnotationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAnnotationContext differentiates from other interfaces.
	IsAnnotationContext()
}

type AnnotationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAnnotationContext() *AnnotationContext {
	var p = new(AnnotationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Java9ParserRULE_annotation
	return p
}

func (*AnnotationContext) IsAnnotationContext() {}

func NewAnnotationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AnnotationContext {
	var p = new(AnnotationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java9ParserRULE_annotation

	return p
}

func (s *AnnotationContext) GetParser() antlr.Parser { return s.parser }

func (s *AnnotationContext) NormalAnnotation() INormalAnnotationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INormalAnnotationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INormalAnnotationContext)
}

func (s *AnnotationContext) MarkerAnnotation() IMarkerAnnotationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMarkerAnnotationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMarkerAnnotationContext)
}

func (s *AnnotationContext) SingleElementAnnotation() ISingleElementAnnotationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISingleElementAnnotationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISingleElementAnnotationContext)
}

func (s *AnnotationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AnnotationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AnnotationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.EnterAnnotation(s)
	}
}

func (s *AnnotationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.ExitAnnotation(s)
	}
}

func (p *Java9Parser) Annotation() (localctx IAnnotationContext) {
	localctx = NewAnnotationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 240, Java9ParserRULE_annotation)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1530)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 154, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1527)
			p.NormalAnnotation()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1528)
			p.MarkerAnnotation()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1529)
			p.SingleElementAnnotation()
		}

	}

	return localctx
}

// INormalAnnotationContext is an interface to support dynamic dispatch.
type INormalAnnotationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsNormalAnnotationContext differentiates from other interfaces.
	IsNormalAnnotationContext()
}

type NormalAnnotationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNormalAnnotationContext() *NormalAnnotationContext {
	var p = new(NormalAnnotationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Java9ParserRULE_normalAnnotation
	return p
}

func (*NormalAnnotationContext) IsNormalAnnotationContext() {}

func NewNormalAnnotationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NormalAnnotationContext {
	var p = new(NormalAnnotationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java9ParserRULE_normalAnnotation

	return p
}

func (s *NormalAnnotationContext) GetParser() antlr.Parser { return s.parser }

func (s *NormalAnnotationContext) AT() antlr.TerminalNode {
	return s.GetToken(Java9ParserAT, 0)
}

func (s *NormalAnnotationContext) TypeName() ITypeNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypeNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITypeNameContext)
}

func (s *NormalAnnotationContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(Java9ParserLPAREN, 0)
}

func (s *NormalAnnotationContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(Java9ParserRPAREN, 0)
}

func (s *NormalAnnotationContext) ElementValuePairList() IElementValuePairListContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IElementValuePairListContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IElementValuePairListContext)
}

func (s *NormalAnnotationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NormalAnnotationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NormalAnnotationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.EnterNormalAnnotation(s)
	}
}

func (s *NormalAnnotationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.ExitNormalAnnotation(s)
	}
}

func (p *Java9Parser) NormalAnnotation() (localctx INormalAnnotationContext) {
	localctx = NewNormalAnnotationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 242, Java9ParserRULE_normalAnnotation)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1532)
		p.Match(Java9ParserAT)
	}
	{
		p.SetState(1533)
		p.TypeName()
	}
	{
		p.SetState(1534)
		p.Match(Java9ParserLPAREN)
	}
	p.SetState(1536)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Java9ParserEXPORTS || _la == Java9ParserMODULE || (((_la-34)&-(0x1f+1)) == 0 && ((1<<uint((_la-34)))&((1<<(Java9ParserOPEN-34))|(1<<(Java9ParserOPERNS-34))|(1<<(Java9ParserPROVIDES-34))|(1<<(Java9ParserREQUIRES-34))|(1<<(Java9ParserTO-34))|(1<<(Java9ParserUSES-34))|(1<<(Java9ParserWITH-34)))) != 0) || _la == Java9ParserIdentifier {
		{
			p.SetState(1535)
			p.ElementValuePairList()
		}

	}
	{
		p.SetState(1538)
		p.Match(Java9ParserRPAREN)
	}

	return localctx
}

// IElementValuePairListContext is an interface to support dynamic dispatch.
type IElementValuePairListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsElementValuePairListContext differentiates from other interfaces.
	IsElementValuePairListContext()
}

type ElementValuePairListContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyElementValuePairListContext() *ElementValuePairListContext {
	var p = new(ElementValuePairListContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Java9ParserRULE_elementValuePairList
	return p
}

func (*ElementValuePairListContext) IsElementValuePairListContext() {}

func NewElementValuePairListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ElementValuePairListContext {
	var p = new(ElementValuePairListContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java9ParserRULE_elementValuePairList

	return p
}

func (s *ElementValuePairListContext) GetParser() antlr.Parser { return s.parser }

func (s *ElementValuePairListContext) AllElementValuePair() []IElementValuePairContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IElementValuePairContext)(nil)).Elem())
	var tst = make([]IElementValuePairContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IElementValuePairContext)
		}
	}

	return tst
}

func (s *ElementValuePairListContext) ElementValuePair(i int) IElementValuePairContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IElementValuePairContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IElementValuePairContext)
}

func (s *ElementValuePairListContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(Java9ParserCOMMA)
}

func (s *ElementValuePairListContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(Java9ParserCOMMA, i)
}

func (s *ElementValuePairListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ElementValuePairListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ElementValuePairListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.EnterElementValuePairList(s)
	}
}

func (s *ElementValuePairListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.ExitElementValuePairList(s)
	}
}

func (p *Java9Parser) ElementValuePairList() (localctx IElementValuePairListContext) {
	localctx = NewElementValuePairListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 244, Java9ParserRULE_elementValuePairList)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1540)
		p.ElementValuePair()
	}
	p.SetState(1545)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == Java9ParserCOMMA {
		{
			p.SetState(1541)
			p.Match(Java9ParserCOMMA)
		}
		{
			p.SetState(1542)
			p.ElementValuePair()
		}

		p.SetState(1547)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IElementValuePairContext is an interface to support dynamic dispatch.
type IElementValuePairContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsElementValuePairContext differentiates from other interfaces.
	IsElementValuePairContext()
}

type ElementValuePairContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyElementValuePairContext() *ElementValuePairContext {
	var p = new(ElementValuePairContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Java9ParserRULE_elementValuePair
	return p
}

func (*ElementValuePairContext) IsElementValuePairContext() {}

func NewElementValuePairContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ElementValuePairContext {
	var p = new(ElementValuePairContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java9ParserRULE_elementValuePair

	return p
}

func (s *ElementValuePairContext) GetParser() antlr.Parser { return s.parser }

func (s *ElementValuePairContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ElementValuePairContext) ASSIGN() antlr.TerminalNode {
	return s.GetToken(Java9ParserASSIGN, 0)
}

func (s *ElementValuePairContext) ElementValue() IElementValueContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IElementValueContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IElementValueContext)
}

func (s *ElementValuePairContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ElementValuePairContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ElementValuePairContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.EnterElementValuePair(s)
	}
}

func (s *ElementValuePairContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.ExitElementValuePair(s)
	}
}

func (p *Java9Parser) ElementValuePair() (localctx IElementValuePairContext) {
	localctx = NewElementValuePairContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 246, Java9ParserRULE_elementValuePair)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1548)
		p.Identifier()
	}
	{
		p.SetState(1549)
		p.Match(Java9ParserASSIGN)
	}
	{
		p.SetState(1550)
		p.ElementValue()
	}

	return localctx
}

// IElementValueContext is an interface to support dynamic dispatch.
type IElementValueContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsElementValueContext differentiates from other interfaces.
	IsElementValueContext()
}

type ElementValueContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyElementValueContext() *ElementValueContext {
	var p = new(ElementValueContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Java9ParserRULE_elementValue
	return p
}

func (*ElementValueContext) IsElementValueContext() {}

func NewElementValueContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ElementValueContext {
	var p = new(ElementValueContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java9ParserRULE_elementValue

	return p
}

func (s *ElementValueContext) GetParser() antlr.Parser { return s.parser }

func (s *ElementValueContext) ConditionalExpression() IConditionalExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConditionalExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConditionalExpressionContext)
}

func (s *ElementValueContext) ElementValueArrayInitializer() IElementValueArrayInitializerContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IElementValueArrayInitializerContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IElementValueArrayInitializerContext)
}

func (s *ElementValueContext) Annotation() IAnnotationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAnnotationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAnnotationContext)
}

func (s *ElementValueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ElementValueContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ElementValueContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.EnterElementValue(s)
	}
}

func (s *ElementValueContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.ExitElementValue(s)
	}
}

func (p *Java9Parser) ElementValue() (localctx IElementValueContext) {
	localctx = NewElementValueContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 248, Java9ParserRULE_elementValue)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1555)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 157, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1552)
			p.ConditionalExpression()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1553)
			p.ElementValueArrayInitializer()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1554)
			p.Annotation()
		}

	}

	return localctx
}

// IElementValueArrayInitializerContext is an interface to support dynamic dispatch.
type IElementValueArrayInitializerContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsElementValueArrayInitializerContext differentiates from other interfaces.
	IsElementValueArrayInitializerContext()
}

type ElementValueArrayInitializerContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyElementValueArrayInitializerContext() *ElementValueArrayInitializerContext {
	var p = new(ElementValueArrayInitializerContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Java9ParserRULE_elementValueArrayInitializer
	return p
}

func (*ElementValueArrayInitializerContext) IsElementValueArrayInitializerContext() {}

func NewElementValueArrayInitializerContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ElementValueArrayInitializerContext {
	var p = new(ElementValueArrayInitializerContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java9ParserRULE_elementValueArrayInitializer

	return p
}

func (s *ElementValueArrayInitializerContext) GetParser() antlr.Parser { return s.parser }

func (s *ElementValueArrayInitializerContext) LBRACE() antlr.TerminalNode {
	return s.GetToken(Java9ParserLBRACE, 0)
}

func (s *ElementValueArrayInitializerContext) RBRACE() antlr.TerminalNode {
	return s.GetToken(Java9ParserRBRACE, 0)
}

func (s *ElementValueArrayInitializerContext) ElementValueList() IElementValueListContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IElementValueListContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IElementValueListContext)
}

func (s *ElementValueArrayInitializerContext) COMMA() antlr.TerminalNode {
	return s.GetToken(Java9ParserCOMMA, 0)
}

func (s *ElementValueArrayInitializerContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ElementValueArrayInitializerContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ElementValueArrayInitializerContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.EnterElementValueArrayInitializer(s)
	}
}

func (s *ElementValueArrayInitializerContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.ExitElementValueArrayInitializer(s)
	}
}

func (p *Java9Parser) ElementValueArrayInitializer() (localctx IElementValueArrayInitializerContext) {
	localctx = NewElementValueArrayInitializerContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 250, Java9ParserRULE_elementValueArrayInitializer)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1557)
		p.Match(Java9ParserLBRACE)
	}
	p.SetState(1559)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<Java9ParserBOOLEAN)|(1<<Java9ParserBYTE)|(1<<Java9ParserCHAR)|(1<<Java9ParserDOUBLE)|(1<<Java9ParserEXPORTS)|(1<<Java9ParserFLOAT)|(1<<Java9ParserINT)|(1<<Java9ParserLONG)|(1<<Java9ParserMODULE))) != 0) || (((_la-33)&-(0x1f+1)) == 0 && ((1<<uint((_la-33)))&((1<<(Java9ParserNEW-33))|(1<<(Java9ParserOPEN-33))|(1<<(Java9ParserOPERNS-33))|(1<<(Java9ParserPROVIDES-33))|(1<<(Java9ParserREQUIRES-33))|(1<<(Java9ParserSHORT-33))|(1<<(Java9ParserSUPER-33))|(1<<(Java9ParserTHIS-33))|(1<<(Java9ParserTO-33))|(1<<(Java9ParserUSES-33))|(1<<(Java9ParserVOID-33))|(1<<(Java9ParserWITH-33))|(1<<(Java9ParserIntegerLiteral-33))|(1<<(Java9ParserFloatingPointLiteral-33))|(1<<(Java9ParserBooleanLiteral-33)))) != 0) || (((_la-65)&-(0x1f+1)) == 0 && ((1<<uint((_la-65)))&((1<<(Java9ParserCharacterLiteral-65))|(1<<(Java9ParserStringLiteral-65))|(1<<(Java9ParserNullLiteral-65))|(1<<(Java9ParserLPAREN-65))|(1<<(Java9ParserLBRACE-65))|(1<<(Java9ParserAT-65))|(1<<(Java9ParserBANG-65))|(1<<(Java9ParserTILDE-65))|(1<<(Java9ParserINC-65))|(1<<(Java9ParserDEC-65))|(1<<(Java9ParserADD-65)))) != 0) || _la == Java9ParserSUB || _la == Java9ParserIdentifier {
		{
			p.SetState(1558)
			p.ElementValueList()
		}

	}
	p.SetState(1562)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Java9ParserCOMMA {
		{
			p.SetState(1561)
			p.Match(Java9ParserCOMMA)
		}

	}
	{
		p.SetState(1564)
		p.Match(Java9ParserRBRACE)
	}

	return localctx
}

// IElementValueListContext is an interface to support dynamic dispatch.
type IElementValueListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsElementValueListContext differentiates from other interfaces.
	IsElementValueListContext()
}

type ElementValueListContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyElementValueListContext() *ElementValueListContext {
	var p = new(ElementValueListContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Java9ParserRULE_elementValueList
	return p
}

func (*ElementValueListContext) IsElementValueListContext() {}

func NewElementValueListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ElementValueListContext {
	var p = new(ElementValueListContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java9ParserRULE_elementValueList

	return p
}

func (s *ElementValueListContext) GetParser() antlr.Parser { return s.parser }

func (s *ElementValueListContext) AllElementValue() []IElementValueContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IElementValueContext)(nil)).Elem())
	var tst = make([]IElementValueContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IElementValueContext)
		}
	}

	return tst
}

func (s *ElementValueListContext) ElementValue(i int) IElementValueContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IElementValueContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IElementValueContext)
}

func (s *ElementValueListContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(Java9ParserCOMMA)
}

func (s *ElementValueListContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(Java9ParserCOMMA, i)
}

func (s *ElementValueListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ElementValueListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ElementValueListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.EnterElementValueList(s)
	}
}

func (s *ElementValueListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.ExitElementValueList(s)
	}
}

func (p *Java9Parser) ElementValueList() (localctx IElementValueListContext) {
	localctx = NewElementValueListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 252, Java9ParserRULE_elementValueList)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1566)
		p.ElementValue()
	}
	p.SetState(1571)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 160, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1567)
				p.Match(Java9ParserCOMMA)
			}
			{
				p.SetState(1568)
				p.ElementValue()
			}

		}
		p.SetState(1573)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 160, p.GetParserRuleContext())
	}

	return localctx
}

// IMarkerAnnotationContext is an interface to support dynamic dispatch.
type IMarkerAnnotationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMarkerAnnotationContext differentiates from other interfaces.
	IsMarkerAnnotationContext()
}

type MarkerAnnotationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMarkerAnnotationContext() *MarkerAnnotationContext {
	var p = new(MarkerAnnotationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Java9ParserRULE_markerAnnotation
	return p
}

func (*MarkerAnnotationContext) IsMarkerAnnotationContext() {}

func NewMarkerAnnotationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MarkerAnnotationContext {
	var p = new(MarkerAnnotationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java9ParserRULE_markerAnnotation

	return p
}

func (s *MarkerAnnotationContext) GetParser() antlr.Parser { return s.parser }

func (s *MarkerAnnotationContext) AT() antlr.TerminalNode {
	return s.GetToken(Java9ParserAT, 0)
}

func (s *MarkerAnnotationContext) TypeName() ITypeNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypeNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITypeNameContext)
}

func (s *MarkerAnnotationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MarkerAnnotationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MarkerAnnotationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.EnterMarkerAnnotation(s)
	}
}

func (s *MarkerAnnotationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.ExitMarkerAnnotation(s)
	}
}

func (p *Java9Parser) MarkerAnnotation() (localctx IMarkerAnnotationContext) {
	localctx = NewMarkerAnnotationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 254, Java9ParserRULE_markerAnnotation)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1574)
		p.Match(Java9ParserAT)
	}
	{
		p.SetState(1575)
		p.TypeName()
	}

	return localctx
}

// ISingleElementAnnotationContext is an interface to support dynamic dispatch.
type ISingleElementAnnotationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSingleElementAnnotationContext differentiates from other interfaces.
	IsSingleElementAnnotationContext()
}

type SingleElementAnnotationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySingleElementAnnotationContext() *SingleElementAnnotationContext {
	var p = new(SingleElementAnnotationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Java9ParserRULE_singleElementAnnotation
	return p
}

func (*SingleElementAnnotationContext) IsSingleElementAnnotationContext() {}

func NewSingleElementAnnotationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SingleElementAnnotationContext {
	var p = new(SingleElementAnnotationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java9ParserRULE_singleElementAnnotation

	return p
}

func (s *SingleElementAnnotationContext) GetParser() antlr.Parser { return s.parser }

func (s *SingleElementAnnotationContext) AT() antlr.TerminalNode {
	return s.GetToken(Java9ParserAT, 0)
}

func (s *SingleElementAnnotationContext) TypeName() ITypeNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypeNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITypeNameContext)
}

func (s *SingleElementAnnotationContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(Java9ParserLPAREN, 0)
}

func (s *SingleElementAnnotationContext) ElementValue() IElementValueContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IElementValueContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IElementValueContext)
}

func (s *SingleElementAnnotationContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(Java9ParserRPAREN, 0)
}

func (s *SingleElementAnnotationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SingleElementAnnotationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SingleElementAnnotationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.EnterSingleElementAnnotation(s)
	}
}

func (s *SingleElementAnnotationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.ExitSingleElementAnnotation(s)
	}
}

func (p *Java9Parser) SingleElementAnnotation() (localctx ISingleElementAnnotationContext) {
	localctx = NewSingleElementAnnotationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 256, Java9ParserRULE_singleElementAnnotation)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1577)
		p.Match(Java9ParserAT)
	}
	{
		p.SetState(1578)
		p.TypeName()
	}
	{
		p.SetState(1579)
		p.Match(Java9ParserLPAREN)
	}
	{
		p.SetState(1580)
		p.ElementValue()
	}
	{
		p.SetState(1581)
		p.Match(Java9ParserRPAREN)
	}

	return localctx
}

// IArrayInitializerContext is an interface to support dynamic dispatch.
type IArrayInitializerContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsArrayInitializerContext differentiates from other interfaces.
	IsArrayInitializerContext()
}

type ArrayInitializerContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyArrayInitializerContext() *ArrayInitializerContext {
	var p = new(ArrayInitializerContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Java9ParserRULE_arrayInitializer
	return p
}

func (*ArrayInitializerContext) IsArrayInitializerContext() {}

func NewArrayInitializerContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ArrayInitializerContext {
	var p = new(ArrayInitializerContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java9ParserRULE_arrayInitializer

	return p
}

func (s *ArrayInitializerContext) GetParser() antlr.Parser { return s.parser }

func (s *ArrayInitializerContext) LBRACE() antlr.TerminalNode {
	return s.GetToken(Java9ParserLBRACE, 0)
}

func (s *ArrayInitializerContext) RBRACE() antlr.TerminalNode {
	return s.GetToken(Java9ParserRBRACE, 0)
}

func (s *ArrayInitializerContext) VariableInitializerList() IVariableInitializerListContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVariableInitializerListContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IVariableInitializerListContext)
}

func (s *ArrayInitializerContext) COMMA() antlr.TerminalNode {
	return s.GetToken(Java9ParserCOMMA, 0)
}

func (s *ArrayInitializerContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArrayInitializerContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ArrayInitializerContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.EnterArrayInitializer(s)
	}
}

func (s *ArrayInitializerContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.ExitArrayInitializer(s)
	}
}

func (p *Java9Parser) ArrayInitializer() (localctx IArrayInitializerContext) {
	localctx = NewArrayInitializerContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 258, Java9ParserRULE_arrayInitializer)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1583)
		p.Match(Java9ParserLBRACE)
	}
	p.SetState(1585)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<Java9ParserBOOLEAN)|(1<<Java9ParserBYTE)|(1<<Java9ParserCHAR)|(1<<Java9ParserDOUBLE)|(1<<Java9ParserEXPORTS)|(1<<Java9ParserFLOAT)|(1<<Java9ParserINT)|(1<<Java9ParserLONG)|(1<<Java9ParserMODULE))) != 0) || (((_la-33)&-(0x1f+1)) == 0 && ((1<<uint((_la-33)))&((1<<(Java9ParserNEW-33))|(1<<(Java9ParserOPEN-33))|(1<<(Java9ParserOPERNS-33))|(1<<(Java9ParserPROVIDES-33))|(1<<(Java9ParserREQUIRES-33))|(1<<(Java9ParserSHORT-33))|(1<<(Java9ParserSUPER-33))|(1<<(Java9ParserTHIS-33))|(1<<(Java9ParserTO-33))|(1<<(Java9ParserUSES-33))|(1<<(Java9ParserVOID-33))|(1<<(Java9ParserWITH-33))|(1<<(Java9ParserIntegerLiteral-33))|(1<<(Java9ParserFloatingPointLiteral-33))|(1<<(Java9ParserBooleanLiteral-33)))) != 0) || (((_la-65)&-(0x1f+1)) == 0 && ((1<<uint((_la-65)))&((1<<(Java9ParserCharacterLiteral-65))|(1<<(Java9ParserStringLiteral-65))|(1<<(Java9ParserNullLiteral-65))|(1<<(Java9ParserLPAREN-65))|(1<<(Java9ParserLBRACE-65))|(1<<(Java9ParserAT-65))|(1<<(Java9ParserBANG-65))|(1<<(Java9ParserTILDE-65))|(1<<(Java9ParserINC-65))|(1<<(Java9ParserDEC-65))|(1<<(Java9ParserADD-65)))) != 0) || _la == Java9ParserSUB || _la == Java9ParserIdentifier {
		{
			p.SetState(1584)
			p.VariableInitializerList()
		}

	}
	p.SetState(1588)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Java9ParserCOMMA {
		{
			p.SetState(1587)
			p.Match(Java9ParserCOMMA)
		}

	}
	{
		p.SetState(1590)
		p.Match(Java9ParserRBRACE)
	}

	return localctx
}

// IVariableInitializerListContext is an interface to support dynamic dispatch.
type IVariableInitializerListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsVariableInitializerListContext differentiates from other interfaces.
	IsVariableInitializerListContext()
}

type VariableInitializerListContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyVariableInitializerListContext() *VariableInitializerListContext {
	var p = new(VariableInitializerListContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Java9ParserRULE_variableInitializerList
	return p
}

func (*VariableInitializerListContext) IsVariableInitializerListContext() {}

func NewVariableInitializerListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *VariableInitializerListContext {
	var p = new(VariableInitializerListContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java9ParserRULE_variableInitializerList

	return p
}

func (s *VariableInitializerListContext) GetParser() antlr.Parser { return s.parser }

func (s *VariableInitializerListContext) AllVariableInitializer() []IVariableInitializerContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IVariableInitializerContext)(nil)).Elem())
	var tst = make([]IVariableInitializerContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IVariableInitializerContext)
		}
	}

	return tst
}

func (s *VariableInitializerListContext) VariableInitializer(i int) IVariableInitializerContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVariableInitializerContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IVariableInitializerContext)
}

func (s *VariableInitializerListContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(Java9ParserCOMMA)
}

func (s *VariableInitializerListContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(Java9ParserCOMMA, i)
}

func (s *VariableInitializerListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VariableInitializerListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *VariableInitializerListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.EnterVariableInitializerList(s)
	}
}

func (s *VariableInitializerListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.ExitVariableInitializerList(s)
	}
}

func (p *Java9Parser) VariableInitializerList() (localctx IVariableInitializerListContext) {
	localctx = NewVariableInitializerListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 260, Java9ParserRULE_variableInitializerList)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1592)
		p.VariableInitializer()
	}
	p.SetState(1597)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 163, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1593)
				p.Match(Java9ParserCOMMA)
			}
			{
				p.SetState(1594)
				p.VariableInitializer()
			}

		}
		p.SetState(1599)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 163, p.GetParserRuleContext())
	}

	return localctx
}

// IBlockContext is an interface to support dynamic dispatch.
type IBlockContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsBlockContext differentiates from other interfaces.
	IsBlockContext()
}

type BlockContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBlockContext() *BlockContext {
	var p = new(BlockContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Java9ParserRULE_block
	return p
}

func (*BlockContext) IsBlockContext() {}

func NewBlockContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BlockContext {
	var p = new(BlockContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java9ParserRULE_block

	return p
}

func (s *BlockContext) GetParser() antlr.Parser { return s.parser }

func (s *BlockContext) LBRACE() antlr.TerminalNode {
	return s.GetToken(Java9ParserLBRACE, 0)
}

func (s *BlockContext) RBRACE() antlr.TerminalNode {
	return s.GetToken(Java9ParserRBRACE, 0)
}

func (s *BlockContext) BlockStatements() IBlockStatementsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBlockStatementsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBlockStatementsContext)
}

func (s *BlockContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BlockContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BlockContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.EnterBlock(s)
	}
}

func (s *BlockContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.ExitBlock(s)
	}
}

func (p *Java9Parser) Block() (localctx IBlockContext) {
	localctx = NewBlockContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 262, Java9ParserRULE_block)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1600)
		p.Match(Java9ParserLBRACE)
	}
	p.SetState(1602)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<Java9ParserABSTRACT)|(1<<Java9ParserASSERT)|(1<<Java9ParserBOOLEAN)|(1<<Java9ParserBREAK)|(1<<Java9ParserBYTE)|(1<<Java9ParserCHAR)|(1<<Java9ParserCLASS)|(1<<Java9ParserCONTINUE)|(1<<Java9ParserDO)|(1<<Java9ParserDOUBLE)|(1<<Java9ParserENUM)|(1<<Java9ParserEXPORTS)|(1<<Java9ParserFINAL)|(1<<Java9ParserFLOAT)|(1<<Java9ParserFOR)|(1<<Java9ParserIF)|(1<<Java9ParserINT)|(1<<Java9ParserLONG)|(1<<Java9ParserMODULE))) != 0) || (((_la-33)&-(0x1f+1)) == 0 && ((1<<uint((_la-33)))&((1<<(Java9ParserNEW-33))|(1<<(Java9ParserOPEN-33))|(1<<(Java9ParserOPERNS-33))|(1<<(Java9ParserPRIVATE-33))|(1<<(Java9ParserPROTECTED-33))|(1<<(Java9ParserPROVIDES-33))|(1<<(Java9ParserPUBLIC-33))|(1<<(Java9ParserREQUIRES-33))|(1<<(Java9ParserRETURN-33))|(1<<(Java9ParserSHORT-33))|(1<<(Java9ParserSTATIC-33))|(1<<(Java9ParserSTRICTFP-33))|(1<<(Java9ParserSUPER-33))|(1<<(Java9ParserSWITCH-33))|(1<<(Java9ParserSYNCHRONIZED-33))|(1<<(Java9ParserTHIS-33))|(1<<(Java9ParserTHROW-33))|(1<<(Java9ParserTO-33))|(1<<(Java9ParserTRY-33))|(1<<(Java9ParserUSES-33))|(1<<(Java9ParserVOID-33))|(1<<(Java9ParserWHILE-33))|(1<<(Java9ParserWITH-33))|(1<<(Java9ParserIntegerLiteral-33))|(1<<(Java9ParserFloatingPointLiteral-33))|(1<<(Java9ParserBooleanLiteral-33)))) != 0) || (((_la-65)&-(0x1f+1)) == 0 && ((1<<uint((_la-65)))&((1<<(Java9ParserCharacterLiteral-65))|(1<<(Java9ParserStringLiteral-65))|(1<<(Java9ParserNullLiteral-65))|(1<<(Java9ParserLPAREN-65))|(1<<(Java9ParserLBRACE-65))|(1<<(Java9ParserSEMI-65))|(1<<(Java9ParserAT-65))|(1<<(Java9ParserINC-65))|(1<<(Java9ParserDEC-65)))) != 0) || _la == Java9ParserIdentifier {
		{
			p.SetState(1601)
			p.BlockStatements()
		}

	}
	{
		p.SetState(1604)
		p.Match(Java9ParserRBRACE)
	}

	return localctx
}

// IBlockStatementsContext is an interface to support dynamic dispatch.
type IBlockStatementsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsBlockStatementsContext differentiates from other interfaces.
	IsBlockStatementsContext()
}

type BlockStatementsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBlockStatementsContext() *BlockStatementsContext {
	var p = new(BlockStatementsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Java9ParserRULE_blockStatements
	return p
}

func (*BlockStatementsContext) IsBlockStatementsContext() {}

func NewBlockStatementsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BlockStatementsContext {
	var p = new(BlockStatementsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java9ParserRULE_blockStatements

	return p
}

func (s *BlockStatementsContext) GetParser() antlr.Parser { return s.parser }

func (s *BlockStatementsContext) AllBlockStatement() []IBlockStatementContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IBlockStatementContext)(nil)).Elem())
	var tst = make([]IBlockStatementContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IBlockStatementContext)
		}
	}

	return tst
}

func (s *BlockStatementsContext) BlockStatement(i int) IBlockStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBlockStatementContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IBlockStatementContext)
}

func (s *BlockStatementsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BlockStatementsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BlockStatementsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.EnterBlockStatements(s)
	}
}

func (s *BlockStatementsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.ExitBlockStatements(s)
	}
}

func (p *Java9Parser) BlockStatements() (localctx IBlockStatementsContext) {
	localctx = NewBlockStatementsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 264, Java9ParserRULE_blockStatements)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1607)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<Java9ParserABSTRACT)|(1<<Java9ParserASSERT)|(1<<Java9ParserBOOLEAN)|(1<<Java9ParserBREAK)|(1<<Java9ParserBYTE)|(1<<Java9ParserCHAR)|(1<<Java9ParserCLASS)|(1<<Java9ParserCONTINUE)|(1<<Java9ParserDO)|(1<<Java9ParserDOUBLE)|(1<<Java9ParserENUM)|(1<<Java9ParserEXPORTS)|(1<<Java9ParserFINAL)|(1<<Java9ParserFLOAT)|(1<<Java9ParserFOR)|(1<<Java9ParserIF)|(1<<Java9ParserINT)|(1<<Java9ParserLONG)|(1<<Java9ParserMODULE))) != 0) || (((_la-33)&-(0x1f+1)) == 0 && ((1<<uint((_la-33)))&((1<<(Java9ParserNEW-33))|(1<<(Java9ParserOPEN-33))|(1<<(Java9ParserOPERNS-33))|(1<<(Java9ParserPRIVATE-33))|(1<<(Java9ParserPROTECTED-33))|(1<<(Java9ParserPROVIDES-33))|(1<<(Java9ParserPUBLIC-33))|(1<<(Java9ParserREQUIRES-33))|(1<<(Java9ParserRETURN-33))|(1<<(Java9ParserSHORT-33))|(1<<(Java9ParserSTATIC-33))|(1<<(Java9ParserSTRICTFP-33))|(1<<(Java9ParserSUPER-33))|(1<<(Java9ParserSWITCH-33))|(1<<(Java9ParserSYNCHRONIZED-33))|(1<<(Java9ParserTHIS-33))|(1<<(Java9ParserTHROW-33))|(1<<(Java9ParserTO-33))|(1<<(Java9ParserTRY-33))|(1<<(Java9ParserUSES-33))|(1<<(Java9ParserVOID-33))|(1<<(Java9ParserWHILE-33))|(1<<(Java9ParserWITH-33))|(1<<(Java9ParserIntegerLiteral-33))|(1<<(Java9ParserFloatingPointLiteral-33))|(1<<(Java9ParserBooleanLiteral-33)))) != 0) || (((_la-65)&-(0x1f+1)) == 0 && ((1<<uint((_la-65)))&((1<<(Java9ParserCharacterLiteral-65))|(1<<(Java9ParserStringLiteral-65))|(1<<(Java9ParserNullLiteral-65))|(1<<(Java9ParserLPAREN-65))|(1<<(Java9ParserLBRACE-65))|(1<<(Java9ParserSEMI-65))|(1<<(Java9ParserAT-65))|(1<<(Java9ParserINC-65))|(1<<(Java9ParserDEC-65)))) != 0) || _la == Java9ParserIdentifier {
		{
			p.SetState(1606)
			p.BlockStatement()
		}

		p.SetState(1609)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IBlockStatementContext is an interface to support dynamic dispatch.
type IBlockStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsBlockStatementContext differentiates from other interfaces.
	IsBlockStatementContext()
}

type BlockStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBlockStatementContext() *BlockStatementContext {
	var p = new(BlockStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Java9ParserRULE_blockStatement
	return p
}

func (*BlockStatementContext) IsBlockStatementContext() {}

func NewBlockStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BlockStatementContext {
	var p = new(BlockStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java9ParserRULE_blockStatement

	return p
}

func (s *BlockStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *BlockStatementContext) LocalVariableDeclarationStatement() ILocalVariableDeclarationStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILocalVariableDeclarationStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILocalVariableDeclarationStatementContext)
}

func (s *BlockStatementContext) ClassDeclaration() IClassDeclarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IClassDeclarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IClassDeclarationContext)
}

func (s *BlockStatementContext) Statement() IStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *BlockStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BlockStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BlockStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.EnterBlockStatement(s)
	}
}

func (s *BlockStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.ExitBlockStatement(s)
	}
}

func (p *Java9Parser) BlockStatement() (localctx IBlockStatementContext) {
	localctx = NewBlockStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 266, Java9ParserRULE_blockStatement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1614)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 166, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1611)
			p.LocalVariableDeclarationStatement()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1612)
			p.ClassDeclaration()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1613)
			p.Statement()
		}

	}

	return localctx
}

// ILocalVariableDeclarationStatementContext is an interface to support dynamic dispatch.
type ILocalVariableDeclarationStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLocalVariableDeclarationStatementContext differentiates from other interfaces.
	IsLocalVariableDeclarationStatementContext()
}

type LocalVariableDeclarationStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLocalVariableDeclarationStatementContext() *LocalVariableDeclarationStatementContext {
	var p = new(LocalVariableDeclarationStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Java9ParserRULE_localVariableDeclarationStatement
	return p
}

func (*LocalVariableDeclarationStatementContext) IsLocalVariableDeclarationStatementContext() {}

func NewLocalVariableDeclarationStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LocalVariableDeclarationStatementContext {
	var p = new(LocalVariableDeclarationStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java9ParserRULE_localVariableDeclarationStatement

	return p
}

func (s *LocalVariableDeclarationStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *LocalVariableDeclarationStatementContext) LocalVariableDeclaration() ILocalVariableDeclarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILocalVariableDeclarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILocalVariableDeclarationContext)
}

func (s *LocalVariableDeclarationStatementContext) SEMI() antlr.TerminalNode {
	return s.GetToken(Java9ParserSEMI, 0)
}

func (s *LocalVariableDeclarationStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LocalVariableDeclarationStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LocalVariableDeclarationStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.EnterLocalVariableDeclarationStatement(s)
	}
}

func (s *LocalVariableDeclarationStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.ExitLocalVariableDeclarationStatement(s)
	}
}

func (p *Java9Parser) LocalVariableDeclarationStatement() (localctx ILocalVariableDeclarationStatementContext) {
	localctx = NewLocalVariableDeclarationStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 268, Java9ParserRULE_localVariableDeclarationStatement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1616)
		p.LocalVariableDeclaration()
	}
	{
		p.SetState(1617)
		p.Match(Java9ParserSEMI)
	}

	return localctx
}

// ILocalVariableDeclarationContext is an interface to support dynamic dispatch.
type ILocalVariableDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLocalVariableDeclarationContext differentiates from other interfaces.
	IsLocalVariableDeclarationContext()
}

type LocalVariableDeclarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLocalVariableDeclarationContext() *LocalVariableDeclarationContext {
	var p = new(LocalVariableDeclarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Java9ParserRULE_localVariableDeclaration
	return p
}

func (*LocalVariableDeclarationContext) IsLocalVariableDeclarationContext() {}

func NewLocalVariableDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LocalVariableDeclarationContext {
	var p = new(LocalVariableDeclarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java9ParserRULE_localVariableDeclaration

	return p
}

func (s *LocalVariableDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *LocalVariableDeclarationContext) UnannType() IUnannTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUnannTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IUnannTypeContext)
}

func (s *LocalVariableDeclarationContext) VariableDeclaratorList() IVariableDeclaratorListContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVariableDeclaratorListContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IVariableDeclaratorListContext)
}

func (s *LocalVariableDeclarationContext) AllVariableModifier() []IVariableModifierContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IVariableModifierContext)(nil)).Elem())
	var tst = make([]IVariableModifierContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IVariableModifierContext)
		}
	}

	return tst
}

func (s *LocalVariableDeclarationContext) VariableModifier(i int) IVariableModifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVariableModifierContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IVariableModifierContext)
}

func (s *LocalVariableDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LocalVariableDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LocalVariableDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.EnterLocalVariableDeclaration(s)
	}
}

func (s *LocalVariableDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.ExitLocalVariableDeclaration(s)
	}
}

func (p *Java9Parser) LocalVariableDeclaration() (localctx ILocalVariableDeclarationContext) {
	localctx = NewLocalVariableDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 270, Java9ParserRULE_localVariableDeclaration)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1622)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == Java9ParserFINAL || _la == Java9ParserAT {
		{
			p.SetState(1619)
			p.VariableModifier()
		}

		p.SetState(1624)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1625)
		p.UnannType()
	}
	{
		p.SetState(1626)
		p.VariableDeclaratorList()
	}

	return localctx
}

// IStatementContext is an interface to support dynamic dispatch.
type IStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsStatementContext differentiates from other interfaces.
	IsStatementContext()
}

type StatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStatementContext() *StatementContext {
	var p = new(StatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Java9ParserRULE_statement
	return p
}

func (*StatementContext) IsStatementContext() {}

func NewStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StatementContext {
	var p = new(StatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java9ParserRULE_statement

	return p
}

func (s *StatementContext) GetParser() antlr.Parser { return s.parser }

func (s *StatementContext) StatementWithoutTrailingSubstatement() IStatementWithoutTrailingSubstatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStatementWithoutTrailingSubstatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IStatementWithoutTrailingSubstatementContext)
}

func (s *StatementContext) LabeledStatement() ILabeledStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILabeledStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILabeledStatementContext)
}

func (s *StatementContext) IfThenStatement() IIfThenStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIfThenStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIfThenStatementContext)
}

func (s *StatementContext) IfThenElseStatement() IIfThenElseStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIfThenElseStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIfThenElseStatementContext)
}

func (s *StatementContext) WhileStatement() IWhileStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IWhileStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IWhileStatementContext)
}

func (s *StatementContext) ForStatement() IForStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IForStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IForStatementContext)
}

func (s *StatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.EnterStatement(s)
	}
}

func (s *StatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.ExitStatement(s)
	}
}

func (p *Java9Parser) Statement() (localctx IStatementContext) {
	localctx = NewStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 272, Java9ParserRULE_statement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1634)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 168, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1628)
			p.StatementWithoutTrailingSubstatement()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1629)
			p.LabeledStatement()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1630)
			p.IfThenStatement()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1631)
			p.IfThenElseStatement()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1632)
			p.WhileStatement()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(1633)
			p.ForStatement()
		}

	}

	return localctx
}

// IStatementNoShortIfContext is an interface to support dynamic dispatch.
type IStatementNoShortIfContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsStatementNoShortIfContext differentiates from other interfaces.
	IsStatementNoShortIfContext()
}

type StatementNoShortIfContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStatementNoShortIfContext() *StatementNoShortIfContext {
	var p = new(StatementNoShortIfContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Java9ParserRULE_statementNoShortIf
	return p
}

func (*StatementNoShortIfContext) IsStatementNoShortIfContext() {}

func NewStatementNoShortIfContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StatementNoShortIfContext {
	var p = new(StatementNoShortIfContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java9ParserRULE_statementNoShortIf

	return p
}

func (s *StatementNoShortIfContext) GetParser() antlr.Parser { return s.parser }

func (s *StatementNoShortIfContext) StatementWithoutTrailingSubstatement() IStatementWithoutTrailingSubstatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStatementWithoutTrailingSubstatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IStatementWithoutTrailingSubstatementContext)
}

func (s *StatementNoShortIfContext) LabeledStatementNoShortIf() ILabeledStatementNoShortIfContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILabeledStatementNoShortIfContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILabeledStatementNoShortIfContext)
}

func (s *StatementNoShortIfContext) IfThenElseStatementNoShortIf() IIfThenElseStatementNoShortIfContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIfThenElseStatementNoShortIfContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIfThenElseStatementNoShortIfContext)
}

func (s *StatementNoShortIfContext) WhileStatementNoShortIf() IWhileStatementNoShortIfContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IWhileStatementNoShortIfContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IWhileStatementNoShortIfContext)
}

func (s *StatementNoShortIfContext) ForStatementNoShortIf() IForStatementNoShortIfContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IForStatementNoShortIfContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IForStatementNoShortIfContext)
}

func (s *StatementNoShortIfContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StatementNoShortIfContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StatementNoShortIfContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.EnterStatementNoShortIf(s)
	}
}

func (s *StatementNoShortIfContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.ExitStatementNoShortIf(s)
	}
}

func (p *Java9Parser) StatementNoShortIf() (localctx IStatementNoShortIfContext) {
	localctx = NewStatementNoShortIfContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 274, Java9ParserRULE_statementNoShortIf)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1641)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 169, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1636)
			p.StatementWithoutTrailingSubstatement()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1637)
			p.LabeledStatementNoShortIf()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1638)
			p.IfThenElseStatementNoShortIf()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1639)
			p.WhileStatementNoShortIf()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1640)
			p.ForStatementNoShortIf()
		}

	}

	return localctx
}

// IStatementWithoutTrailingSubstatementContext is an interface to support dynamic dispatch.
type IStatementWithoutTrailingSubstatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsStatementWithoutTrailingSubstatementContext differentiates from other interfaces.
	IsStatementWithoutTrailingSubstatementContext()
}

type StatementWithoutTrailingSubstatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStatementWithoutTrailingSubstatementContext() *StatementWithoutTrailingSubstatementContext {
	var p = new(StatementWithoutTrailingSubstatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Java9ParserRULE_statementWithoutTrailingSubstatement
	return p
}

func (*StatementWithoutTrailingSubstatementContext) IsStatementWithoutTrailingSubstatementContext() {}

func NewStatementWithoutTrailingSubstatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StatementWithoutTrailingSubstatementContext {
	var p = new(StatementWithoutTrailingSubstatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java9ParserRULE_statementWithoutTrailingSubstatement

	return p
}

func (s *StatementWithoutTrailingSubstatementContext) GetParser() antlr.Parser { return s.parser }

func (s *StatementWithoutTrailingSubstatementContext) Block() IBlockContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBlockContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBlockContext)
}

func (s *StatementWithoutTrailingSubstatementContext) EmptyStatement_() IEmptyStatement_Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEmptyStatement_Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEmptyStatement_Context)
}

func (s *StatementWithoutTrailingSubstatementContext) ExpressionStatement() IExpressionStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionStatementContext)
}

func (s *StatementWithoutTrailingSubstatementContext) AssertStatement() IAssertStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAssertStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAssertStatementContext)
}

func (s *StatementWithoutTrailingSubstatementContext) SwitchStatement() ISwitchStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISwitchStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISwitchStatementContext)
}

func (s *StatementWithoutTrailingSubstatementContext) DoStatement() IDoStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDoStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDoStatementContext)
}

func (s *StatementWithoutTrailingSubstatementContext) BreakStatement() IBreakStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBreakStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBreakStatementContext)
}

func (s *StatementWithoutTrailingSubstatementContext) ContinueStatement() IContinueStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IContinueStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IContinueStatementContext)
}

func (s *StatementWithoutTrailingSubstatementContext) ReturnStatement() IReturnStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IReturnStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IReturnStatementContext)
}

func (s *StatementWithoutTrailingSubstatementContext) SynchronizedStatement() ISynchronizedStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISynchronizedStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISynchronizedStatementContext)
}

func (s *StatementWithoutTrailingSubstatementContext) ThrowStatement() IThrowStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IThrowStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IThrowStatementContext)
}

func (s *StatementWithoutTrailingSubstatementContext) TryStatement() ITryStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITryStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITryStatementContext)
}

func (s *StatementWithoutTrailingSubstatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StatementWithoutTrailingSubstatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StatementWithoutTrailingSubstatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.EnterStatementWithoutTrailingSubstatement(s)
	}
}

func (s *StatementWithoutTrailingSubstatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.ExitStatementWithoutTrailingSubstatement(s)
	}
}

func (p *Java9Parser) StatementWithoutTrailingSubstatement() (localctx IStatementWithoutTrailingSubstatementContext) {
	localctx = NewStatementWithoutTrailingSubstatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 276, Java9ParserRULE_statementWithoutTrailingSubstatement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1655)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case Java9ParserLBRACE:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1643)
			p.Block()
		}

	case Java9ParserSEMI:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1644)
			p.EmptyStatement_()
		}

	case Java9ParserBOOLEAN, Java9ParserBYTE, Java9ParserCHAR, Java9ParserDOUBLE, Java9ParserEXPORTS, Java9ParserFLOAT, Java9ParserINT, Java9ParserLONG, Java9ParserMODULE, Java9ParserNEW, Java9ParserOPEN, Java9ParserOPERNS, Java9ParserPROVIDES, Java9ParserREQUIRES, Java9ParserSHORT, Java9ParserSUPER, Java9ParserTHIS, Java9ParserTO, Java9ParserUSES, Java9ParserVOID, Java9ParserWITH, Java9ParserIntegerLiteral, Java9ParserFloatingPointLiteral, Java9ParserBooleanLiteral, Java9ParserCharacterLiteral, Java9ParserStringLiteral, Java9ParserNullLiteral, Java9ParserLPAREN, Java9ParserAT, Java9ParserINC, Java9ParserDEC, Java9ParserIdentifier:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1645)
			p.ExpressionStatement()
		}

	case Java9ParserASSERT:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1646)
			p.AssertStatement()
		}

	case Java9ParserSWITCH:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1647)
			p.SwitchStatement()
		}

	case Java9ParserDO:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(1648)
			p.DoStatement()
		}

	case Java9ParserBREAK:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(1649)
			p.BreakStatement()
		}

	case Java9ParserCONTINUE:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(1650)
			p.ContinueStatement()
		}

	case Java9ParserRETURN:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(1651)
			p.ReturnStatement()
		}

	case Java9ParserSYNCHRONIZED:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(1652)
			p.SynchronizedStatement()
		}

	case Java9ParserTHROW:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(1653)
			p.ThrowStatement()
		}

	case Java9ParserTRY:
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(1654)
			p.TryStatement()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IEmptyStatement_Context is an interface to support dynamic dispatch.
type IEmptyStatement_Context interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEmptyStatement_Context differentiates from other interfaces.
	IsEmptyStatement_Context()
}

type EmptyStatement_Context struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEmptyStatement_Context() *EmptyStatement_Context {
	var p = new(EmptyStatement_Context)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Java9ParserRULE_emptyStatement_
	return p
}

func (*EmptyStatement_Context) IsEmptyStatement_Context() {}

func NewEmptyStatement_Context(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EmptyStatement_Context {
	var p = new(EmptyStatement_Context)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java9ParserRULE_emptyStatement_

	return p
}

func (s *EmptyStatement_Context) GetParser() antlr.Parser { return s.parser }

func (s *EmptyStatement_Context) SEMI() antlr.TerminalNode {
	return s.GetToken(Java9ParserSEMI, 0)
}

func (s *EmptyStatement_Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EmptyStatement_Context) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EmptyStatement_Context) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.EnterEmptyStatement_(s)
	}
}

func (s *EmptyStatement_Context) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.ExitEmptyStatement_(s)
	}
}

func (p *Java9Parser) EmptyStatement_() (localctx IEmptyStatement_Context) {
	localctx = NewEmptyStatement_Context(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 278, Java9ParserRULE_emptyStatement_)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1657)
		p.Match(Java9ParserSEMI)
	}

	return localctx
}

// ILabeledStatementContext is an interface to support dynamic dispatch.
type ILabeledStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLabeledStatementContext differentiates from other interfaces.
	IsLabeledStatementContext()
}

type LabeledStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLabeledStatementContext() *LabeledStatementContext {
	var p = new(LabeledStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Java9ParserRULE_labeledStatement
	return p
}

func (*LabeledStatementContext) IsLabeledStatementContext() {}

func NewLabeledStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LabeledStatementContext {
	var p = new(LabeledStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java9ParserRULE_labeledStatement

	return p
}

func (s *LabeledStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *LabeledStatementContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *LabeledStatementContext) COLON() antlr.TerminalNode {
	return s.GetToken(Java9ParserCOLON, 0)
}

func (s *LabeledStatementContext) Statement() IStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *LabeledStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LabeledStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LabeledStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.EnterLabeledStatement(s)
	}
}

func (s *LabeledStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.ExitLabeledStatement(s)
	}
}

func (p *Java9Parser) LabeledStatement() (localctx ILabeledStatementContext) {
	localctx = NewLabeledStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 280, Java9ParserRULE_labeledStatement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1659)
		p.Identifier()
	}
	{
		p.SetState(1660)
		p.Match(Java9ParserCOLON)
	}
	{
		p.SetState(1661)
		p.Statement()
	}

	return localctx
}

// ILabeledStatementNoShortIfContext is an interface to support dynamic dispatch.
type ILabeledStatementNoShortIfContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLabeledStatementNoShortIfContext differentiates from other interfaces.
	IsLabeledStatementNoShortIfContext()
}

type LabeledStatementNoShortIfContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLabeledStatementNoShortIfContext() *LabeledStatementNoShortIfContext {
	var p = new(LabeledStatementNoShortIfContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Java9ParserRULE_labeledStatementNoShortIf
	return p
}

func (*LabeledStatementNoShortIfContext) IsLabeledStatementNoShortIfContext() {}

func NewLabeledStatementNoShortIfContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LabeledStatementNoShortIfContext {
	var p = new(LabeledStatementNoShortIfContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java9ParserRULE_labeledStatementNoShortIf

	return p
}

func (s *LabeledStatementNoShortIfContext) GetParser() antlr.Parser { return s.parser }

func (s *LabeledStatementNoShortIfContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *LabeledStatementNoShortIfContext) COLON() antlr.TerminalNode {
	return s.GetToken(Java9ParserCOLON, 0)
}

func (s *LabeledStatementNoShortIfContext) StatementNoShortIf() IStatementNoShortIfContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStatementNoShortIfContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IStatementNoShortIfContext)
}

func (s *LabeledStatementNoShortIfContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LabeledStatementNoShortIfContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LabeledStatementNoShortIfContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.EnterLabeledStatementNoShortIf(s)
	}
}

func (s *LabeledStatementNoShortIfContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.ExitLabeledStatementNoShortIf(s)
	}
}

func (p *Java9Parser) LabeledStatementNoShortIf() (localctx ILabeledStatementNoShortIfContext) {
	localctx = NewLabeledStatementNoShortIfContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 282, Java9ParserRULE_labeledStatementNoShortIf)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1663)
		p.Identifier()
	}
	{
		p.SetState(1664)
		p.Match(Java9ParserCOLON)
	}
	{
		p.SetState(1665)
		p.StatementNoShortIf()
	}

	return localctx
}

// IExpressionStatementContext is an interface to support dynamic dispatch.
type IExpressionStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExpressionStatementContext differentiates from other interfaces.
	IsExpressionStatementContext()
}

type ExpressionStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpressionStatementContext() *ExpressionStatementContext {
	var p = new(ExpressionStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Java9ParserRULE_expressionStatement
	return p
}

func (*ExpressionStatementContext) IsExpressionStatementContext() {}

func NewExpressionStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExpressionStatementContext {
	var p = new(ExpressionStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java9ParserRULE_expressionStatement

	return p
}

func (s *ExpressionStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ExpressionStatementContext) StatementExpression() IStatementExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStatementExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IStatementExpressionContext)
}

func (s *ExpressionStatementContext) SEMI() antlr.TerminalNode {
	return s.GetToken(Java9ParserSEMI, 0)
}

func (s *ExpressionStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExpressionStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExpressionStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.EnterExpressionStatement(s)
	}
}

func (s *ExpressionStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.ExitExpressionStatement(s)
	}
}

func (p *Java9Parser) ExpressionStatement() (localctx IExpressionStatementContext) {
	localctx = NewExpressionStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 284, Java9ParserRULE_expressionStatement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1667)
		p.StatementExpression()
	}
	{
		p.SetState(1668)
		p.Match(Java9ParserSEMI)
	}

	return localctx
}

// IStatementExpressionContext is an interface to support dynamic dispatch.
type IStatementExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsStatementExpressionContext differentiates from other interfaces.
	IsStatementExpressionContext()
}

type StatementExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStatementExpressionContext() *StatementExpressionContext {
	var p = new(StatementExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Java9ParserRULE_statementExpression
	return p
}

func (*StatementExpressionContext) IsStatementExpressionContext() {}

func NewStatementExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StatementExpressionContext {
	var p = new(StatementExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java9ParserRULE_statementExpression

	return p
}

func (s *StatementExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *StatementExpressionContext) Assignment() IAssignmentContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAssignmentContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAssignmentContext)
}

func (s *StatementExpressionContext) PreIncrementExpression() IPreIncrementExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPreIncrementExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPreIncrementExpressionContext)
}

func (s *StatementExpressionContext) PreDecrementExpression() IPreDecrementExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPreDecrementExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPreDecrementExpressionContext)
}

func (s *StatementExpressionContext) PostIncrementExpression() IPostIncrementExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPostIncrementExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPostIncrementExpressionContext)
}

func (s *StatementExpressionContext) PostDecrementExpression() IPostDecrementExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPostDecrementExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPostDecrementExpressionContext)
}

func (s *StatementExpressionContext) MethodInvocation() IMethodInvocationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMethodInvocationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMethodInvocationContext)
}

func (s *StatementExpressionContext) ClassInstanceCreationExpression() IClassInstanceCreationExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IClassInstanceCreationExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IClassInstanceCreationExpressionContext)
}

func (s *StatementExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StatementExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StatementExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.EnterStatementExpression(s)
	}
}

func (s *StatementExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.ExitStatementExpression(s)
	}
}

func (p *Java9Parser) StatementExpression() (localctx IStatementExpressionContext) {
	localctx = NewStatementExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 286, Java9ParserRULE_statementExpression)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1677)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 171, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1670)
			p.Assignment()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1671)
			p.PreIncrementExpression()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1672)
			p.PreDecrementExpression()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1673)
			p.PostIncrementExpression()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1674)
			p.PostDecrementExpression()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(1675)
			p.MethodInvocation()
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(1676)
			p.ClassInstanceCreationExpression()
		}

	}

	return localctx
}

// IIfThenStatementContext is an interface to support dynamic dispatch.
type IIfThenStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsIfThenStatementContext differentiates from other interfaces.
	IsIfThenStatementContext()
}

type IfThenStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIfThenStatementContext() *IfThenStatementContext {
	var p = new(IfThenStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Java9ParserRULE_ifThenStatement
	return p
}

func (*IfThenStatementContext) IsIfThenStatementContext() {}

func NewIfThenStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IfThenStatementContext {
	var p = new(IfThenStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java9ParserRULE_ifThenStatement

	return p
}

func (s *IfThenStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *IfThenStatementContext) IF() antlr.TerminalNode {
	return s.GetToken(Java9ParserIF, 0)
}

func (s *IfThenStatementContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(Java9ParserLPAREN, 0)
}

func (s *IfThenStatementContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *IfThenStatementContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(Java9ParserRPAREN, 0)
}

func (s *IfThenStatementContext) Statement() IStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *IfThenStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IfThenStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IfThenStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.EnterIfThenStatement(s)
	}
}

func (s *IfThenStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.ExitIfThenStatement(s)
	}
}

func (p *Java9Parser) IfThenStatement() (localctx IIfThenStatementContext) {
	localctx = NewIfThenStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 288, Java9ParserRULE_ifThenStatement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1679)
		p.Match(Java9ParserIF)
	}
	{
		p.SetState(1680)
		p.Match(Java9ParserLPAREN)
	}
	{
		p.SetState(1681)
		p.Expression()
	}
	{
		p.SetState(1682)
		p.Match(Java9ParserRPAREN)
	}
	{
		p.SetState(1683)
		p.Statement()
	}

	return localctx
}

// IIfThenElseStatementContext is an interface to support dynamic dispatch.
type IIfThenElseStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsIfThenElseStatementContext differentiates from other interfaces.
	IsIfThenElseStatementContext()
}

type IfThenElseStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIfThenElseStatementContext() *IfThenElseStatementContext {
	var p = new(IfThenElseStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Java9ParserRULE_ifThenElseStatement
	return p
}

func (*IfThenElseStatementContext) IsIfThenElseStatementContext() {}

func NewIfThenElseStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IfThenElseStatementContext {
	var p = new(IfThenElseStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java9ParserRULE_ifThenElseStatement

	return p
}

func (s *IfThenElseStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *IfThenElseStatementContext) IF() antlr.TerminalNode {
	return s.GetToken(Java9ParserIF, 0)
}

func (s *IfThenElseStatementContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(Java9ParserLPAREN, 0)
}

func (s *IfThenElseStatementContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *IfThenElseStatementContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(Java9ParserRPAREN, 0)
}

func (s *IfThenElseStatementContext) StatementNoShortIf() IStatementNoShortIfContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStatementNoShortIfContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IStatementNoShortIfContext)
}

func (s *IfThenElseStatementContext) ELSE() antlr.TerminalNode {
	return s.GetToken(Java9ParserELSE, 0)
}

func (s *IfThenElseStatementContext) Statement() IStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *IfThenElseStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IfThenElseStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IfThenElseStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.EnterIfThenElseStatement(s)
	}
}

func (s *IfThenElseStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.ExitIfThenElseStatement(s)
	}
}

func (p *Java9Parser) IfThenElseStatement() (localctx IIfThenElseStatementContext) {
	localctx = NewIfThenElseStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 290, Java9ParserRULE_ifThenElseStatement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1685)
		p.Match(Java9ParserIF)
	}
	{
		p.SetState(1686)
		p.Match(Java9ParserLPAREN)
	}
	{
		p.SetState(1687)
		p.Expression()
	}
	{
		p.SetState(1688)
		p.Match(Java9ParserRPAREN)
	}
	{
		p.SetState(1689)
		p.StatementNoShortIf()
	}
	{
		p.SetState(1690)
		p.Match(Java9ParserELSE)
	}
	{
		p.SetState(1691)
		p.Statement()
	}

	return localctx
}

// IIfThenElseStatementNoShortIfContext is an interface to support dynamic dispatch.
type IIfThenElseStatementNoShortIfContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsIfThenElseStatementNoShortIfContext differentiates from other interfaces.
	IsIfThenElseStatementNoShortIfContext()
}

type IfThenElseStatementNoShortIfContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIfThenElseStatementNoShortIfContext() *IfThenElseStatementNoShortIfContext {
	var p = new(IfThenElseStatementNoShortIfContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Java9ParserRULE_ifThenElseStatementNoShortIf
	return p
}

func (*IfThenElseStatementNoShortIfContext) IsIfThenElseStatementNoShortIfContext() {}

func NewIfThenElseStatementNoShortIfContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IfThenElseStatementNoShortIfContext {
	var p = new(IfThenElseStatementNoShortIfContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java9ParserRULE_ifThenElseStatementNoShortIf

	return p
}

func (s *IfThenElseStatementNoShortIfContext) GetParser() antlr.Parser { return s.parser }

func (s *IfThenElseStatementNoShortIfContext) IF() antlr.TerminalNode {
	return s.GetToken(Java9ParserIF, 0)
}

func (s *IfThenElseStatementNoShortIfContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(Java9ParserLPAREN, 0)
}

func (s *IfThenElseStatementNoShortIfContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *IfThenElseStatementNoShortIfContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(Java9ParserRPAREN, 0)
}

func (s *IfThenElseStatementNoShortIfContext) AllStatementNoShortIf() []IStatementNoShortIfContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IStatementNoShortIfContext)(nil)).Elem())
	var tst = make([]IStatementNoShortIfContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IStatementNoShortIfContext)
		}
	}

	return tst
}

func (s *IfThenElseStatementNoShortIfContext) StatementNoShortIf(i int) IStatementNoShortIfContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStatementNoShortIfContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IStatementNoShortIfContext)
}

func (s *IfThenElseStatementNoShortIfContext) ELSE() antlr.TerminalNode {
	return s.GetToken(Java9ParserELSE, 0)
}

func (s *IfThenElseStatementNoShortIfContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IfThenElseStatementNoShortIfContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IfThenElseStatementNoShortIfContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.EnterIfThenElseStatementNoShortIf(s)
	}
}

func (s *IfThenElseStatementNoShortIfContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.ExitIfThenElseStatementNoShortIf(s)
	}
}

func (p *Java9Parser) IfThenElseStatementNoShortIf() (localctx IIfThenElseStatementNoShortIfContext) {
	localctx = NewIfThenElseStatementNoShortIfContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 292, Java9ParserRULE_ifThenElseStatementNoShortIf)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1693)
		p.Match(Java9ParserIF)
	}
	{
		p.SetState(1694)
		p.Match(Java9ParserLPAREN)
	}
	{
		p.SetState(1695)
		p.Expression()
	}
	{
		p.SetState(1696)
		p.Match(Java9ParserRPAREN)
	}
	{
		p.SetState(1697)
		p.StatementNoShortIf()
	}
	{
		p.SetState(1698)
		p.Match(Java9ParserELSE)
	}
	{
		p.SetState(1699)
		p.StatementNoShortIf()
	}

	return localctx
}

// IAssertStatementContext is an interface to support dynamic dispatch.
type IAssertStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAssertStatementContext differentiates from other interfaces.
	IsAssertStatementContext()
}

type AssertStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAssertStatementContext() *AssertStatementContext {
	var p = new(AssertStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Java9ParserRULE_assertStatement
	return p
}

func (*AssertStatementContext) IsAssertStatementContext() {}

func NewAssertStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AssertStatementContext {
	var p = new(AssertStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java9ParserRULE_assertStatement

	return p
}

func (s *AssertStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *AssertStatementContext) ASSERT() antlr.TerminalNode {
	return s.GetToken(Java9ParserASSERT, 0)
}

func (s *AssertStatementContext) AllExpression() []IExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExpressionContext)(nil)).Elem())
	var tst = make([]IExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExpressionContext)
		}
	}

	return tst
}

func (s *AssertStatementContext) Expression(i int) IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *AssertStatementContext) SEMI() antlr.TerminalNode {
	return s.GetToken(Java9ParserSEMI, 0)
}

func (s *AssertStatementContext) COLON() antlr.TerminalNode {
	return s.GetToken(Java9ParserCOLON, 0)
}

func (s *AssertStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AssertStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AssertStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.EnterAssertStatement(s)
	}
}

func (s *AssertStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.ExitAssertStatement(s)
	}
}

func (p *Java9Parser) AssertStatement() (localctx IAssertStatementContext) {
	localctx = NewAssertStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 294, Java9ParserRULE_assertStatement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1711)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 172, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1701)
			p.Match(Java9ParserASSERT)
		}
		{
			p.SetState(1702)
			p.Expression()
		}
		{
			p.SetState(1703)
			p.Match(Java9ParserSEMI)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1705)
			p.Match(Java9ParserASSERT)
		}
		{
			p.SetState(1706)
			p.Expression()
		}
		{
			p.SetState(1707)
			p.Match(Java9ParserCOLON)
		}
		{
			p.SetState(1708)
			p.Expression()
		}
		{
			p.SetState(1709)
			p.Match(Java9ParserSEMI)
		}

	}

	return localctx
}

// ISwitchStatementContext is an interface to support dynamic dispatch.
type ISwitchStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSwitchStatementContext differentiates from other interfaces.
	IsSwitchStatementContext()
}

type SwitchStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySwitchStatementContext() *SwitchStatementContext {
	var p = new(SwitchStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Java9ParserRULE_switchStatement
	return p
}

func (*SwitchStatementContext) IsSwitchStatementContext() {}

func NewSwitchStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SwitchStatementContext {
	var p = new(SwitchStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java9ParserRULE_switchStatement

	return p
}

func (s *SwitchStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *SwitchStatementContext) SWITCH() antlr.TerminalNode {
	return s.GetToken(Java9ParserSWITCH, 0)
}

func (s *SwitchStatementContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(Java9ParserLPAREN, 0)
}

func (s *SwitchStatementContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *SwitchStatementContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(Java9ParserRPAREN, 0)
}

func (s *SwitchStatementContext) SwitchBlock() ISwitchBlockContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISwitchBlockContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISwitchBlockContext)
}

func (s *SwitchStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SwitchStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SwitchStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.EnterSwitchStatement(s)
	}
}

func (s *SwitchStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.ExitSwitchStatement(s)
	}
}

func (p *Java9Parser) SwitchStatement() (localctx ISwitchStatementContext) {
	localctx = NewSwitchStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 296, Java9ParserRULE_switchStatement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1713)
		p.Match(Java9ParserSWITCH)
	}
	{
		p.SetState(1714)
		p.Match(Java9ParserLPAREN)
	}
	{
		p.SetState(1715)
		p.Expression()
	}
	{
		p.SetState(1716)
		p.Match(Java9ParserRPAREN)
	}
	{
		p.SetState(1717)
		p.SwitchBlock()
	}

	return localctx
}

// ISwitchBlockContext is an interface to support dynamic dispatch.
type ISwitchBlockContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSwitchBlockContext differentiates from other interfaces.
	IsSwitchBlockContext()
}

type SwitchBlockContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySwitchBlockContext() *SwitchBlockContext {
	var p = new(SwitchBlockContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Java9ParserRULE_switchBlock
	return p
}

func (*SwitchBlockContext) IsSwitchBlockContext() {}

func NewSwitchBlockContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SwitchBlockContext {
	var p = new(SwitchBlockContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java9ParserRULE_switchBlock

	return p
}

func (s *SwitchBlockContext) GetParser() antlr.Parser { return s.parser }

func (s *SwitchBlockContext) LBRACE() antlr.TerminalNode {
	return s.GetToken(Java9ParserLBRACE, 0)
}

func (s *SwitchBlockContext) RBRACE() antlr.TerminalNode {
	return s.GetToken(Java9ParserRBRACE, 0)
}

func (s *SwitchBlockContext) AllSwitchBlockStatementGroup() []ISwitchBlockStatementGroupContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ISwitchBlockStatementGroupContext)(nil)).Elem())
	var tst = make([]ISwitchBlockStatementGroupContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ISwitchBlockStatementGroupContext)
		}
	}

	return tst
}

func (s *SwitchBlockContext) SwitchBlockStatementGroup(i int) ISwitchBlockStatementGroupContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISwitchBlockStatementGroupContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ISwitchBlockStatementGroupContext)
}

func (s *SwitchBlockContext) AllSwitchLabel() []ISwitchLabelContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ISwitchLabelContext)(nil)).Elem())
	var tst = make([]ISwitchLabelContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ISwitchLabelContext)
		}
	}

	return tst
}

func (s *SwitchBlockContext) SwitchLabel(i int) ISwitchLabelContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISwitchLabelContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ISwitchLabelContext)
}

func (s *SwitchBlockContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SwitchBlockContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SwitchBlockContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.EnterSwitchBlock(s)
	}
}

func (s *SwitchBlockContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.ExitSwitchBlock(s)
	}
}

func (p *Java9Parser) SwitchBlock() (localctx ISwitchBlockContext) {
	localctx = NewSwitchBlockContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 298, Java9ParserRULE_switchBlock)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1719)
		p.Match(Java9ParserLBRACE)
	}
	p.SetState(1723)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 173, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1720)
				p.SwitchBlockStatementGroup()
			}

		}
		p.SetState(1725)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 173, p.GetParserRuleContext())
	}
	p.SetState(1729)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == Java9ParserCASE || _la == Java9ParserDEFAULT {
		{
			p.SetState(1726)
			p.SwitchLabel()
		}

		p.SetState(1731)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1732)
		p.Match(Java9ParserRBRACE)
	}

	return localctx
}

// ISwitchBlockStatementGroupContext is an interface to support dynamic dispatch.
type ISwitchBlockStatementGroupContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSwitchBlockStatementGroupContext differentiates from other interfaces.
	IsSwitchBlockStatementGroupContext()
}

type SwitchBlockStatementGroupContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySwitchBlockStatementGroupContext() *SwitchBlockStatementGroupContext {
	var p = new(SwitchBlockStatementGroupContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Java9ParserRULE_switchBlockStatementGroup
	return p
}

func (*SwitchBlockStatementGroupContext) IsSwitchBlockStatementGroupContext() {}

func NewSwitchBlockStatementGroupContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SwitchBlockStatementGroupContext {
	var p = new(SwitchBlockStatementGroupContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java9ParserRULE_switchBlockStatementGroup

	return p
}

func (s *SwitchBlockStatementGroupContext) GetParser() antlr.Parser { return s.parser }

func (s *SwitchBlockStatementGroupContext) SwitchLabels() ISwitchLabelsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISwitchLabelsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISwitchLabelsContext)
}

func (s *SwitchBlockStatementGroupContext) BlockStatements() IBlockStatementsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBlockStatementsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBlockStatementsContext)
}

func (s *SwitchBlockStatementGroupContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SwitchBlockStatementGroupContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SwitchBlockStatementGroupContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.EnterSwitchBlockStatementGroup(s)
	}
}

func (s *SwitchBlockStatementGroupContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.ExitSwitchBlockStatementGroup(s)
	}
}

func (p *Java9Parser) SwitchBlockStatementGroup() (localctx ISwitchBlockStatementGroupContext) {
	localctx = NewSwitchBlockStatementGroupContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 300, Java9ParserRULE_switchBlockStatementGroup)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1734)
		p.SwitchLabels()
	}
	{
		p.SetState(1735)
		p.BlockStatements()
	}

	return localctx
}

// ISwitchLabelsContext is an interface to support dynamic dispatch.
type ISwitchLabelsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSwitchLabelsContext differentiates from other interfaces.
	IsSwitchLabelsContext()
}

type SwitchLabelsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySwitchLabelsContext() *SwitchLabelsContext {
	var p = new(SwitchLabelsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Java9ParserRULE_switchLabels
	return p
}

func (*SwitchLabelsContext) IsSwitchLabelsContext() {}

func NewSwitchLabelsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SwitchLabelsContext {
	var p = new(SwitchLabelsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java9ParserRULE_switchLabels

	return p
}

func (s *SwitchLabelsContext) GetParser() antlr.Parser { return s.parser }

func (s *SwitchLabelsContext) AllSwitchLabel() []ISwitchLabelContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ISwitchLabelContext)(nil)).Elem())
	var tst = make([]ISwitchLabelContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ISwitchLabelContext)
		}
	}

	return tst
}

func (s *SwitchLabelsContext) SwitchLabel(i int) ISwitchLabelContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISwitchLabelContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ISwitchLabelContext)
}

func (s *SwitchLabelsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SwitchLabelsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SwitchLabelsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.EnterSwitchLabels(s)
	}
}

func (s *SwitchLabelsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.ExitSwitchLabels(s)
	}
}

func (p *Java9Parser) SwitchLabels() (localctx ISwitchLabelsContext) {
	localctx = NewSwitchLabelsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 302, Java9ParserRULE_switchLabels)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1738)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = _la == Java9ParserCASE || _la == Java9ParserDEFAULT {
		{
			p.SetState(1737)
			p.SwitchLabel()
		}

		p.SetState(1740)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// ISwitchLabelContext is an interface to support dynamic dispatch.
type ISwitchLabelContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSwitchLabelContext differentiates from other interfaces.
	IsSwitchLabelContext()
}

type SwitchLabelContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySwitchLabelContext() *SwitchLabelContext {
	var p = new(SwitchLabelContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Java9ParserRULE_switchLabel
	return p
}

func (*SwitchLabelContext) IsSwitchLabelContext() {}

func NewSwitchLabelContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SwitchLabelContext {
	var p = new(SwitchLabelContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java9ParserRULE_switchLabel

	return p
}

func (s *SwitchLabelContext) GetParser() antlr.Parser { return s.parser }

func (s *SwitchLabelContext) CASE() antlr.TerminalNode {
	return s.GetToken(Java9ParserCASE, 0)
}

func (s *SwitchLabelContext) ConstantExpression() IConstantExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConstantExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConstantExpressionContext)
}

func (s *SwitchLabelContext) COLON() antlr.TerminalNode {
	return s.GetToken(Java9ParserCOLON, 0)
}

func (s *SwitchLabelContext) EnumConstantName() IEnumConstantNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEnumConstantNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEnumConstantNameContext)
}

func (s *SwitchLabelContext) DEFAULT() antlr.TerminalNode {
	return s.GetToken(Java9ParserDEFAULT, 0)
}

func (s *SwitchLabelContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SwitchLabelContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SwitchLabelContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.EnterSwitchLabel(s)
	}
}

func (s *SwitchLabelContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.ExitSwitchLabel(s)
	}
}

func (p *Java9Parser) SwitchLabel() (localctx ISwitchLabelContext) {
	localctx = NewSwitchLabelContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 304, Java9ParserRULE_switchLabel)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1752)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 176, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1742)
			p.Match(Java9ParserCASE)
		}
		{
			p.SetState(1743)
			p.ConstantExpression()
		}
		{
			p.SetState(1744)
			p.Match(Java9ParserCOLON)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1746)
			p.Match(Java9ParserCASE)
		}
		{
			p.SetState(1747)
			p.EnumConstantName()
		}
		{
			p.SetState(1748)
			p.Match(Java9ParserCOLON)
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1750)
			p.Match(Java9ParserDEFAULT)
		}
		{
			p.SetState(1751)
			p.Match(Java9ParserCOLON)
		}

	}

	return localctx
}

// IEnumConstantNameContext is an interface to support dynamic dispatch.
type IEnumConstantNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEnumConstantNameContext differentiates from other interfaces.
	IsEnumConstantNameContext()
}

type EnumConstantNameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEnumConstantNameContext() *EnumConstantNameContext {
	var p = new(EnumConstantNameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Java9ParserRULE_enumConstantName
	return p
}

func (*EnumConstantNameContext) IsEnumConstantNameContext() {}

func NewEnumConstantNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EnumConstantNameContext {
	var p = new(EnumConstantNameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java9ParserRULE_enumConstantName

	return p
}

func (s *EnumConstantNameContext) GetParser() antlr.Parser { return s.parser }

func (s *EnumConstantNameContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *EnumConstantNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EnumConstantNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EnumConstantNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.EnterEnumConstantName(s)
	}
}

func (s *EnumConstantNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.ExitEnumConstantName(s)
	}
}

func (p *Java9Parser) EnumConstantName() (localctx IEnumConstantNameContext) {
	localctx = NewEnumConstantNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 306, Java9ParserRULE_enumConstantName)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1754)
		p.Identifier()
	}

	return localctx
}

// IWhileStatementContext is an interface to support dynamic dispatch.
type IWhileStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsWhileStatementContext differentiates from other interfaces.
	IsWhileStatementContext()
}

type WhileStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWhileStatementContext() *WhileStatementContext {
	var p = new(WhileStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Java9ParserRULE_whileStatement
	return p
}

func (*WhileStatementContext) IsWhileStatementContext() {}

func NewWhileStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WhileStatementContext {
	var p = new(WhileStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java9ParserRULE_whileStatement

	return p
}

func (s *WhileStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *WhileStatementContext) WHILE() antlr.TerminalNode {
	return s.GetToken(Java9ParserWHILE, 0)
}

func (s *WhileStatementContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(Java9ParserLPAREN, 0)
}

func (s *WhileStatementContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *WhileStatementContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(Java9ParserRPAREN, 0)
}

func (s *WhileStatementContext) Statement() IStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *WhileStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WhileStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WhileStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.EnterWhileStatement(s)
	}
}

func (s *WhileStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.ExitWhileStatement(s)
	}
}

func (p *Java9Parser) WhileStatement() (localctx IWhileStatementContext) {
	localctx = NewWhileStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 308, Java9ParserRULE_whileStatement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1756)
		p.Match(Java9ParserWHILE)
	}
	{
		p.SetState(1757)
		p.Match(Java9ParserLPAREN)
	}
	{
		p.SetState(1758)
		p.Expression()
	}
	{
		p.SetState(1759)
		p.Match(Java9ParserRPAREN)
	}
	{
		p.SetState(1760)
		p.Statement()
	}

	return localctx
}

// IWhileStatementNoShortIfContext is an interface to support dynamic dispatch.
type IWhileStatementNoShortIfContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsWhileStatementNoShortIfContext differentiates from other interfaces.
	IsWhileStatementNoShortIfContext()
}

type WhileStatementNoShortIfContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWhileStatementNoShortIfContext() *WhileStatementNoShortIfContext {
	var p = new(WhileStatementNoShortIfContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Java9ParserRULE_whileStatementNoShortIf
	return p
}

func (*WhileStatementNoShortIfContext) IsWhileStatementNoShortIfContext() {}

func NewWhileStatementNoShortIfContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WhileStatementNoShortIfContext {
	var p = new(WhileStatementNoShortIfContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java9ParserRULE_whileStatementNoShortIf

	return p
}

func (s *WhileStatementNoShortIfContext) GetParser() antlr.Parser { return s.parser }

func (s *WhileStatementNoShortIfContext) WHILE() antlr.TerminalNode {
	return s.GetToken(Java9ParserWHILE, 0)
}

func (s *WhileStatementNoShortIfContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(Java9ParserLPAREN, 0)
}

func (s *WhileStatementNoShortIfContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *WhileStatementNoShortIfContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(Java9ParserRPAREN, 0)
}

func (s *WhileStatementNoShortIfContext) StatementNoShortIf() IStatementNoShortIfContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStatementNoShortIfContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IStatementNoShortIfContext)
}

func (s *WhileStatementNoShortIfContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WhileStatementNoShortIfContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WhileStatementNoShortIfContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.EnterWhileStatementNoShortIf(s)
	}
}

func (s *WhileStatementNoShortIfContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.ExitWhileStatementNoShortIf(s)
	}
}

func (p *Java9Parser) WhileStatementNoShortIf() (localctx IWhileStatementNoShortIfContext) {
	localctx = NewWhileStatementNoShortIfContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 310, Java9ParserRULE_whileStatementNoShortIf)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1762)
		p.Match(Java9ParserWHILE)
	}
	{
		p.SetState(1763)
		p.Match(Java9ParserLPAREN)
	}
	{
		p.SetState(1764)
		p.Expression()
	}
	{
		p.SetState(1765)
		p.Match(Java9ParserRPAREN)
	}
	{
		p.SetState(1766)
		p.StatementNoShortIf()
	}

	return localctx
}

// IDoStatementContext is an interface to support dynamic dispatch.
type IDoStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDoStatementContext differentiates from other interfaces.
	IsDoStatementContext()
}

type DoStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDoStatementContext() *DoStatementContext {
	var p = new(DoStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Java9ParserRULE_doStatement
	return p
}

func (*DoStatementContext) IsDoStatementContext() {}

func NewDoStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DoStatementContext {
	var p = new(DoStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java9ParserRULE_doStatement

	return p
}

func (s *DoStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *DoStatementContext) DO() antlr.TerminalNode {
	return s.GetToken(Java9ParserDO, 0)
}

func (s *DoStatementContext) Statement() IStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *DoStatementContext) WHILE() antlr.TerminalNode {
	return s.GetToken(Java9ParserWHILE, 0)
}

func (s *DoStatementContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(Java9ParserLPAREN, 0)
}

func (s *DoStatementContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *DoStatementContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(Java9ParserRPAREN, 0)
}

func (s *DoStatementContext) SEMI() antlr.TerminalNode {
	return s.GetToken(Java9ParserSEMI, 0)
}

func (s *DoStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DoStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DoStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.EnterDoStatement(s)
	}
}

func (s *DoStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.ExitDoStatement(s)
	}
}

func (p *Java9Parser) DoStatement() (localctx IDoStatementContext) {
	localctx = NewDoStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 312, Java9ParserRULE_doStatement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1768)
		p.Match(Java9ParserDO)
	}
	{
		p.SetState(1769)
		p.Statement()
	}
	{
		p.SetState(1770)
		p.Match(Java9ParserWHILE)
	}
	{
		p.SetState(1771)
		p.Match(Java9ParserLPAREN)
	}
	{
		p.SetState(1772)
		p.Expression()
	}
	{
		p.SetState(1773)
		p.Match(Java9ParserRPAREN)
	}
	{
		p.SetState(1774)
		p.Match(Java9ParserSEMI)
	}

	return localctx
}

// IForStatementContext is an interface to support dynamic dispatch.
type IForStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsForStatementContext differentiates from other interfaces.
	IsForStatementContext()
}

type ForStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyForStatementContext() *ForStatementContext {
	var p = new(ForStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Java9ParserRULE_forStatement
	return p
}

func (*ForStatementContext) IsForStatementContext() {}

func NewForStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ForStatementContext {
	var p = new(ForStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java9ParserRULE_forStatement

	return p
}

func (s *ForStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ForStatementContext) BasicForStatement() IBasicForStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBasicForStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBasicForStatementContext)
}

func (s *ForStatementContext) EnhancedForStatement() IEnhancedForStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEnhancedForStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEnhancedForStatementContext)
}

func (s *ForStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ForStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ForStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.EnterForStatement(s)
	}
}

func (s *ForStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.ExitForStatement(s)
	}
}

func (p *Java9Parser) ForStatement() (localctx IForStatementContext) {
	localctx = NewForStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 314, Java9ParserRULE_forStatement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1778)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 177, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1776)
			p.BasicForStatement()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1777)
			p.EnhancedForStatement()
		}

	}

	return localctx
}

// IForStatementNoShortIfContext is an interface to support dynamic dispatch.
type IForStatementNoShortIfContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsForStatementNoShortIfContext differentiates from other interfaces.
	IsForStatementNoShortIfContext()
}

type ForStatementNoShortIfContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyForStatementNoShortIfContext() *ForStatementNoShortIfContext {
	var p = new(ForStatementNoShortIfContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Java9ParserRULE_forStatementNoShortIf
	return p
}

func (*ForStatementNoShortIfContext) IsForStatementNoShortIfContext() {}

func NewForStatementNoShortIfContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ForStatementNoShortIfContext {
	var p = new(ForStatementNoShortIfContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java9ParserRULE_forStatementNoShortIf

	return p
}

func (s *ForStatementNoShortIfContext) GetParser() antlr.Parser { return s.parser }

func (s *ForStatementNoShortIfContext) BasicForStatementNoShortIf() IBasicForStatementNoShortIfContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBasicForStatementNoShortIfContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBasicForStatementNoShortIfContext)
}

func (s *ForStatementNoShortIfContext) EnhancedForStatementNoShortIf() IEnhancedForStatementNoShortIfContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEnhancedForStatementNoShortIfContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEnhancedForStatementNoShortIfContext)
}

func (s *ForStatementNoShortIfContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ForStatementNoShortIfContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ForStatementNoShortIfContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.EnterForStatementNoShortIf(s)
	}
}

func (s *ForStatementNoShortIfContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.ExitForStatementNoShortIf(s)
	}
}

func (p *Java9Parser) ForStatementNoShortIf() (localctx IForStatementNoShortIfContext) {
	localctx = NewForStatementNoShortIfContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 316, Java9ParserRULE_forStatementNoShortIf)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1782)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 178, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1780)
			p.BasicForStatementNoShortIf()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1781)
			p.EnhancedForStatementNoShortIf()
		}

	}

	return localctx
}

// IBasicForStatementContext is an interface to support dynamic dispatch.
type IBasicForStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsBasicForStatementContext differentiates from other interfaces.
	IsBasicForStatementContext()
}

type BasicForStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBasicForStatementContext() *BasicForStatementContext {
	var p = new(BasicForStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Java9ParserRULE_basicForStatement
	return p
}

func (*BasicForStatementContext) IsBasicForStatementContext() {}

func NewBasicForStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BasicForStatementContext {
	var p = new(BasicForStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java9ParserRULE_basicForStatement

	return p
}

func (s *BasicForStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *BasicForStatementContext) FOR() antlr.TerminalNode {
	return s.GetToken(Java9ParserFOR, 0)
}

func (s *BasicForStatementContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(Java9ParserLPAREN, 0)
}

func (s *BasicForStatementContext) AllSEMI() []antlr.TerminalNode {
	return s.GetTokens(Java9ParserSEMI)
}

func (s *BasicForStatementContext) SEMI(i int) antlr.TerminalNode {
	return s.GetToken(Java9ParserSEMI, i)
}

func (s *BasicForStatementContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(Java9ParserRPAREN, 0)
}

func (s *BasicForStatementContext) Statement() IStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *BasicForStatementContext) ForInit() IForInitContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IForInitContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IForInitContext)
}

func (s *BasicForStatementContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *BasicForStatementContext) ForUpdate() IForUpdateContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IForUpdateContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IForUpdateContext)
}

func (s *BasicForStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BasicForStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BasicForStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.EnterBasicForStatement(s)
	}
}

func (s *BasicForStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.ExitBasicForStatement(s)
	}
}

func (p *Java9Parser) BasicForStatement() (localctx IBasicForStatementContext) {
	localctx = NewBasicForStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 318, Java9ParserRULE_basicForStatement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1784)
		p.Match(Java9ParserFOR)
	}
	{
		p.SetState(1785)
		p.Match(Java9ParserLPAREN)
	}
	p.SetState(1787)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<Java9ParserBOOLEAN)|(1<<Java9ParserBYTE)|(1<<Java9ParserCHAR)|(1<<Java9ParserDOUBLE)|(1<<Java9ParserEXPORTS)|(1<<Java9ParserFINAL)|(1<<Java9ParserFLOAT)|(1<<Java9ParserINT)|(1<<Java9ParserLONG)|(1<<Java9ParserMODULE))) != 0) || (((_la-33)&-(0x1f+1)) == 0 && ((1<<uint((_la-33)))&((1<<(Java9ParserNEW-33))|(1<<(Java9ParserOPEN-33))|(1<<(Java9ParserOPERNS-33))|(1<<(Java9ParserPROVIDES-33))|(1<<(Java9ParserREQUIRES-33))|(1<<(Java9ParserSHORT-33))|(1<<(Java9ParserSUPER-33))|(1<<(Java9ParserTHIS-33))|(1<<(Java9ParserTO-33))|(1<<(Java9ParserUSES-33))|(1<<(Java9ParserVOID-33))|(1<<(Java9ParserWITH-33))|(1<<(Java9ParserIntegerLiteral-33))|(1<<(Java9ParserFloatingPointLiteral-33))|(1<<(Java9ParserBooleanLiteral-33)))) != 0) || (((_la-65)&-(0x1f+1)) == 0 && ((1<<uint((_la-65)))&((1<<(Java9ParserCharacterLiteral-65))|(1<<(Java9ParserStringLiteral-65))|(1<<(Java9ParserNullLiteral-65))|(1<<(Java9ParserLPAREN-65))|(1<<(Java9ParserAT-65))|(1<<(Java9ParserINC-65))|(1<<(Java9ParserDEC-65)))) != 0) || _la == Java9ParserIdentifier {
		{
			p.SetState(1786)
			p.ForInit()
		}

	}
	{
		p.SetState(1789)
		p.Match(Java9ParserSEMI)
	}
	p.SetState(1791)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<Java9ParserBOOLEAN)|(1<<Java9ParserBYTE)|(1<<Java9ParserCHAR)|(1<<Java9ParserDOUBLE)|(1<<Java9ParserEXPORTS)|(1<<Java9ParserFLOAT)|(1<<Java9ParserINT)|(1<<Java9ParserLONG)|(1<<Java9ParserMODULE))) != 0) || (((_la-33)&-(0x1f+1)) == 0 && ((1<<uint((_la-33)))&((1<<(Java9ParserNEW-33))|(1<<(Java9ParserOPEN-33))|(1<<(Java9ParserOPERNS-33))|(1<<(Java9ParserPROVIDES-33))|(1<<(Java9ParserREQUIRES-33))|(1<<(Java9ParserSHORT-33))|(1<<(Java9ParserSUPER-33))|(1<<(Java9ParserTHIS-33))|(1<<(Java9ParserTO-33))|(1<<(Java9ParserUSES-33))|(1<<(Java9ParserVOID-33))|(1<<(Java9ParserWITH-33))|(1<<(Java9ParserIntegerLiteral-33))|(1<<(Java9ParserFloatingPointLiteral-33))|(1<<(Java9ParserBooleanLiteral-33)))) != 0) || (((_la-65)&-(0x1f+1)) == 0 && ((1<<uint((_la-65)))&((1<<(Java9ParserCharacterLiteral-65))|(1<<(Java9ParserStringLiteral-65))|(1<<(Java9ParserNullLiteral-65))|(1<<(Java9ParserLPAREN-65))|(1<<(Java9ParserAT-65))|(1<<(Java9ParserBANG-65))|(1<<(Java9ParserTILDE-65))|(1<<(Java9ParserINC-65))|(1<<(Java9ParserDEC-65))|(1<<(Java9ParserADD-65)))) != 0) || _la == Java9ParserSUB || _la == Java9ParserIdentifier {
		{
			p.SetState(1790)
			p.Expression()
		}

	}
	{
		p.SetState(1793)
		p.Match(Java9ParserSEMI)
	}
	p.SetState(1795)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<Java9ParserBOOLEAN)|(1<<Java9ParserBYTE)|(1<<Java9ParserCHAR)|(1<<Java9ParserDOUBLE)|(1<<Java9ParserEXPORTS)|(1<<Java9ParserFLOAT)|(1<<Java9ParserINT)|(1<<Java9ParserLONG)|(1<<Java9ParserMODULE))) != 0) || (((_la-33)&-(0x1f+1)) == 0 && ((1<<uint((_la-33)))&((1<<(Java9ParserNEW-33))|(1<<(Java9ParserOPEN-33))|(1<<(Java9ParserOPERNS-33))|(1<<(Java9ParserPROVIDES-33))|(1<<(Java9ParserREQUIRES-33))|(1<<(Java9ParserSHORT-33))|(1<<(Java9ParserSUPER-33))|(1<<(Java9ParserTHIS-33))|(1<<(Java9ParserTO-33))|(1<<(Java9ParserUSES-33))|(1<<(Java9ParserVOID-33))|(1<<(Java9ParserWITH-33))|(1<<(Java9ParserIntegerLiteral-33))|(1<<(Java9ParserFloatingPointLiteral-33))|(1<<(Java9ParserBooleanLiteral-33)))) != 0) || (((_la-65)&-(0x1f+1)) == 0 && ((1<<uint((_la-65)))&((1<<(Java9ParserCharacterLiteral-65))|(1<<(Java9ParserStringLiteral-65))|(1<<(Java9ParserNullLiteral-65))|(1<<(Java9ParserLPAREN-65))|(1<<(Java9ParserAT-65))|(1<<(Java9ParserINC-65))|(1<<(Java9ParserDEC-65)))) != 0) || _la == Java9ParserIdentifier {
		{
			p.SetState(1794)
			p.ForUpdate()
		}

	}
	{
		p.SetState(1797)
		p.Match(Java9ParserRPAREN)
	}
	{
		p.SetState(1798)
		p.Statement()
	}

	return localctx
}

// IBasicForStatementNoShortIfContext is an interface to support dynamic dispatch.
type IBasicForStatementNoShortIfContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsBasicForStatementNoShortIfContext differentiates from other interfaces.
	IsBasicForStatementNoShortIfContext()
}

type BasicForStatementNoShortIfContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBasicForStatementNoShortIfContext() *BasicForStatementNoShortIfContext {
	var p = new(BasicForStatementNoShortIfContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Java9ParserRULE_basicForStatementNoShortIf
	return p
}

func (*BasicForStatementNoShortIfContext) IsBasicForStatementNoShortIfContext() {}

func NewBasicForStatementNoShortIfContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BasicForStatementNoShortIfContext {
	var p = new(BasicForStatementNoShortIfContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java9ParserRULE_basicForStatementNoShortIf

	return p
}

func (s *BasicForStatementNoShortIfContext) GetParser() antlr.Parser { return s.parser }

func (s *BasicForStatementNoShortIfContext) FOR() antlr.TerminalNode {
	return s.GetToken(Java9ParserFOR, 0)
}

func (s *BasicForStatementNoShortIfContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(Java9ParserLPAREN, 0)
}

func (s *BasicForStatementNoShortIfContext) AllSEMI() []antlr.TerminalNode {
	return s.GetTokens(Java9ParserSEMI)
}

func (s *BasicForStatementNoShortIfContext) SEMI(i int) antlr.TerminalNode {
	return s.GetToken(Java9ParserSEMI, i)
}

func (s *BasicForStatementNoShortIfContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(Java9ParserRPAREN, 0)
}

func (s *BasicForStatementNoShortIfContext) StatementNoShortIf() IStatementNoShortIfContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStatementNoShortIfContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IStatementNoShortIfContext)
}

func (s *BasicForStatementNoShortIfContext) ForInit() IForInitContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IForInitContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IForInitContext)
}

func (s *BasicForStatementNoShortIfContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *BasicForStatementNoShortIfContext) ForUpdate() IForUpdateContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IForUpdateContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IForUpdateContext)
}

func (s *BasicForStatementNoShortIfContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BasicForStatementNoShortIfContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BasicForStatementNoShortIfContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.EnterBasicForStatementNoShortIf(s)
	}
}

func (s *BasicForStatementNoShortIfContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.ExitBasicForStatementNoShortIf(s)
	}
}

func (p *Java9Parser) BasicForStatementNoShortIf() (localctx IBasicForStatementNoShortIfContext) {
	localctx = NewBasicForStatementNoShortIfContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 320, Java9ParserRULE_basicForStatementNoShortIf)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1800)
		p.Match(Java9ParserFOR)
	}
	{
		p.SetState(1801)
		p.Match(Java9ParserLPAREN)
	}
	p.SetState(1803)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<Java9ParserBOOLEAN)|(1<<Java9ParserBYTE)|(1<<Java9ParserCHAR)|(1<<Java9ParserDOUBLE)|(1<<Java9ParserEXPORTS)|(1<<Java9ParserFINAL)|(1<<Java9ParserFLOAT)|(1<<Java9ParserINT)|(1<<Java9ParserLONG)|(1<<Java9ParserMODULE))) != 0) || (((_la-33)&-(0x1f+1)) == 0 && ((1<<uint((_la-33)))&((1<<(Java9ParserNEW-33))|(1<<(Java9ParserOPEN-33))|(1<<(Java9ParserOPERNS-33))|(1<<(Java9ParserPROVIDES-33))|(1<<(Java9ParserREQUIRES-33))|(1<<(Java9ParserSHORT-33))|(1<<(Java9ParserSUPER-33))|(1<<(Java9ParserTHIS-33))|(1<<(Java9ParserTO-33))|(1<<(Java9ParserUSES-33))|(1<<(Java9ParserVOID-33))|(1<<(Java9ParserWITH-33))|(1<<(Java9ParserIntegerLiteral-33))|(1<<(Java9ParserFloatingPointLiteral-33))|(1<<(Java9ParserBooleanLiteral-33)))) != 0) || (((_la-65)&-(0x1f+1)) == 0 && ((1<<uint((_la-65)))&((1<<(Java9ParserCharacterLiteral-65))|(1<<(Java9ParserStringLiteral-65))|(1<<(Java9ParserNullLiteral-65))|(1<<(Java9ParserLPAREN-65))|(1<<(Java9ParserAT-65))|(1<<(Java9ParserINC-65))|(1<<(Java9ParserDEC-65)))) != 0) || _la == Java9ParserIdentifier {
		{
			p.SetState(1802)
			p.ForInit()
		}

	}
	{
		p.SetState(1805)
		p.Match(Java9ParserSEMI)
	}
	p.SetState(1807)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<Java9ParserBOOLEAN)|(1<<Java9ParserBYTE)|(1<<Java9ParserCHAR)|(1<<Java9ParserDOUBLE)|(1<<Java9ParserEXPORTS)|(1<<Java9ParserFLOAT)|(1<<Java9ParserINT)|(1<<Java9ParserLONG)|(1<<Java9ParserMODULE))) != 0) || (((_la-33)&-(0x1f+1)) == 0 && ((1<<uint((_la-33)))&((1<<(Java9ParserNEW-33))|(1<<(Java9ParserOPEN-33))|(1<<(Java9ParserOPERNS-33))|(1<<(Java9ParserPROVIDES-33))|(1<<(Java9ParserREQUIRES-33))|(1<<(Java9ParserSHORT-33))|(1<<(Java9ParserSUPER-33))|(1<<(Java9ParserTHIS-33))|(1<<(Java9ParserTO-33))|(1<<(Java9ParserUSES-33))|(1<<(Java9ParserVOID-33))|(1<<(Java9ParserWITH-33))|(1<<(Java9ParserIntegerLiteral-33))|(1<<(Java9ParserFloatingPointLiteral-33))|(1<<(Java9ParserBooleanLiteral-33)))) != 0) || (((_la-65)&-(0x1f+1)) == 0 && ((1<<uint((_la-65)))&((1<<(Java9ParserCharacterLiteral-65))|(1<<(Java9ParserStringLiteral-65))|(1<<(Java9ParserNullLiteral-65))|(1<<(Java9ParserLPAREN-65))|(1<<(Java9ParserAT-65))|(1<<(Java9ParserBANG-65))|(1<<(Java9ParserTILDE-65))|(1<<(Java9ParserINC-65))|(1<<(Java9ParserDEC-65))|(1<<(Java9ParserADD-65)))) != 0) || _la == Java9ParserSUB || _la == Java9ParserIdentifier {
		{
			p.SetState(1806)
			p.Expression()
		}

	}
	{
		p.SetState(1809)
		p.Match(Java9ParserSEMI)
	}
	p.SetState(1811)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<Java9ParserBOOLEAN)|(1<<Java9ParserBYTE)|(1<<Java9ParserCHAR)|(1<<Java9ParserDOUBLE)|(1<<Java9ParserEXPORTS)|(1<<Java9ParserFLOAT)|(1<<Java9ParserINT)|(1<<Java9ParserLONG)|(1<<Java9ParserMODULE))) != 0) || (((_la-33)&-(0x1f+1)) == 0 && ((1<<uint((_la-33)))&((1<<(Java9ParserNEW-33))|(1<<(Java9ParserOPEN-33))|(1<<(Java9ParserOPERNS-33))|(1<<(Java9ParserPROVIDES-33))|(1<<(Java9ParserREQUIRES-33))|(1<<(Java9ParserSHORT-33))|(1<<(Java9ParserSUPER-33))|(1<<(Java9ParserTHIS-33))|(1<<(Java9ParserTO-33))|(1<<(Java9ParserUSES-33))|(1<<(Java9ParserVOID-33))|(1<<(Java9ParserWITH-33))|(1<<(Java9ParserIntegerLiteral-33))|(1<<(Java9ParserFloatingPointLiteral-33))|(1<<(Java9ParserBooleanLiteral-33)))) != 0) || (((_la-65)&-(0x1f+1)) == 0 && ((1<<uint((_la-65)))&((1<<(Java9ParserCharacterLiteral-65))|(1<<(Java9ParserStringLiteral-65))|(1<<(Java9ParserNullLiteral-65))|(1<<(Java9ParserLPAREN-65))|(1<<(Java9ParserAT-65))|(1<<(Java9ParserINC-65))|(1<<(Java9ParserDEC-65)))) != 0) || _la == Java9ParserIdentifier {
		{
			p.SetState(1810)
			p.ForUpdate()
		}

	}
	{
		p.SetState(1813)
		p.Match(Java9ParserRPAREN)
	}
	{
		p.SetState(1814)
		p.StatementNoShortIf()
	}

	return localctx
}

// IForInitContext is an interface to support dynamic dispatch.
type IForInitContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsForInitContext differentiates from other interfaces.
	IsForInitContext()
}

type ForInitContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyForInitContext() *ForInitContext {
	var p = new(ForInitContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Java9ParserRULE_forInit
	return p
}

func (*ForInitContext) IsForInitContext() {}

func NewForInitContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ForInitContext {
	var p = new(ForInitContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java9ParserRULE_forInit

	return p
}

func (s *ForInitContext) GetParser() antlr.Parser { return s.parser }

func (s *ForInitContext) StatementExpressionList() IStatementExpressionListContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStatementExpressionListContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IStatementExpressionListContext)
}

func (s *ForInitContext) LocalVariableDeclaration() ILocalVariableDeclarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILocalVariableDeclarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILocalVariableDeclarationContext)
}

func (s *ForInitContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ForInitContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ForInitContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.EnterForInit(s)
	}
}

func (s *ForInitContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.ExitForInit(s)
	}
}

func (p *Java9Parser) ForInit() (localctx IForInitContext) {
	localctx = NewForInitContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 322, Java9ParserRULE_forInit)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1818)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 185, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1816)
			p.StatementExpressionList()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1817)
			p.LocalVariableDeclaration()
		}

	}

	return localctx
}

// IForUpdateContext is an interface to support dynamic dispatch.
type IForUpdateContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsForUpdateContext differentiates from other interfaces.
	IsForUpdateContext()
}

type ForUpdateContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyForUpdateContext() *ForUpdateContext {
	var p = new(ForUpdateContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Java9ParserRULE_forUpdate
	return p
}

func (*ForUpdateContext) IsForUpdateContext() {}

func NewForUpdateContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ForUpdateContext {
	var p = new(ForUpdateContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java9ParserRULE_forUpdate

	return p
}

func (s *ForUpdateContext) GetParser() antlr.Parser { return s.parser }

func (s *ForUpdateContext) StatementExpressionList() IStatementExpressionListContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStatementExpressionListContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IStatementExpressionListContext)
}

func (s *ForUpdateContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ForUpdateContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ForUpdateContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.EnterForUpdate(s)
	}
}

func (s *ForUpdateContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.ExitForUpdate(s)
	}
}

func (p *Java9Parser) ForUpdate() (localctx IForUpdateContext) {
	localctx = NewForUpdateContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 324, Java9ParserRULE_forUpdate)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1820)
		p.StatementExpressionList()
	}

	return localctx
}

// IStatementExpressionListContext is an interface to support dynamic dispatch.
type IStatementExpressionListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsStatementExpressionListContext differentiates from other interfaces.
	IsStatementExpressionListContext()
}

type StatementExpressionListContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStatementExpressionListContext() *StatementExpressionListContext {
	var p = new(StatementExpressionListContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Java9ParserRULE_statementExpressionList
	return p
}

func (*StatementExpressionListContext) IsStatementExpressionListContext() {}

func NewStatementExpressionListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StatementExpressionListContext {
	var p = new(StatementExpressionListContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java9ParserRULE_statementExpressionList

	return p
}

func (s *StatementExpressionListContext) GetParser() antlr.Parser { return s.parser }

func (s *StatementExpressionListContext) AllStatementExpression() []IStatementExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IStatementExpressionContext)(nil)).Elem())
	var tst = make([]IStatementExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IStatementExpressionContext)
		}
	}

	return tst
}

func (s *StatementExpressionListContext) StatementExpression(i int) IStatementExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStatementExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IStatementExpressionContext)
}

func (s *StatementExpressionListContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(Java9ParserCOMMA)
}

func (s *StatementExpressionListContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(Java9ParserCOMMA, i)
}

func (s *StatementExpressionListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StatementExpressionListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StatementExpressionListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.EnterStatementExpressionList(s)
	}
}

func (s *StatementExpressionListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.ExitStatementExpressionList(s)
	}
}

func (p *Java9Parser) StatementExpressionList() (localctx IStatementExpressionListContext) {
	localctx = NewStatementExpressionListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 326, Java9ParserRULE_statementExpressionList)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1822)
		p.StatementExpression()
	}
	p.SetState(1827)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == Java9ParserCOMMA {
		{
			p.SetState(1823)
			p.Match(Java9ParserCOMMA)
		}
		{
			p.SetState(1824)
			p.StatementExpression()
		}

		p.SetState(1829)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IEnhancedForStatementContext is an interface to support dynamic dispatch.
type IEnhancedForStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEnhancedForStatementContext differentiates from other interfaces.
	IsEnhancedForStatementContext()
}

type EnhancedForStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEnhancedForStatementContext() *EnhancedForStatementContext {
	var p = new(EnhancedForStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Java9ParserRULE_enhancedForStatement
	return p
}

func (*EnhancedForStatementContext) IsEnhancedForStatementContext() {}

func NewEnhancedForStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EnhancedForStatementContext {
	var p = new(EnhancedForStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java9ParserRULE_enhancedForStatement

	return p
}

func (s *EnhancedForStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *EnhancedForStatementContext) FOR() antlr.TerminalNode {
	return s.GetToken(Java9ParserFOR, 0)
}

func (s *EnhancedForStatementContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(Java9ParserLPAREN, 0)
}

func (s *EnhancedForStatementContext) UnannType() IUnannTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUnannTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IUnannTypeContext)
}

func (s *EnhancedForStatementContext) VariableDeclaratorId() IVariableDeclaratorIdContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVariableDeclaratorIdContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IVariableDeclaratorIdContext)
}

func (s *EnhancedForStatementContext) COLON() antlr.TerminalNode {
	return s.GetToken(Java9ParserCOLON, 0)
}

func (s *EnhancedForStatementContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *EnhancedForStatementContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(Java9ParserRPAREN, 0)
}

func (s *EnhancedForStatementContext) Statement() IStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *EnhancedForStatementContext) AllVariableModifier() []IVariableModifierContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IVariableModifierContext)(nil)).Elem())
	var tst = make([]IVariableModifierContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IVariableModifierContext)
		}
	}

	return tst
}

func (s *EnhancedForStatementContext) VariableModifier(i int) IVariableModifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVariableModifierContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IVariableModifierContext)
}

func (s *EnhancedForStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EnhancedForStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EnhancedForStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.EnterEnhancedForStatement(s)
	}
}

func (s *EnhancedForStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.ExitEnhancedForStatement(s)
	}
}

func (p *Java9Parser) EnhancedForStatement() (localctx IEnhancedForStatementContext) {
	localctx = NewEnhancedForStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 328, Java9ParserRULE_enhancedForStatement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1830)
		p.Match(Java9ParserFOR)
	}
	{
		p.SetState(1831)
		p.Match(Java9ParserLPAREN)
	}
	p.SetState(1835)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == Java9ParserFINAL || _la == Java9ParserAT {
		{
			p.SetState(1832)
			p.VariableModifier()
		}

		p.SetState(1837)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1838)
		p.UnannType()
	}
	{
		p.SetState(1839)
		p.VariableDeclaratorId()
	}
	{
		p.SetState(1840)
		p.Match(Java9ParserCOLON)
	}
	{
		p.SetState(1841)
		p.Expression()
	}
	{
		p.SetState(1842)
		p.Match(Java9ParserRPAREN)
	}
	{
		p.SetState(1843)
		p.Statement()
	}

	return localctx
}

// IEnhancedForStatementNoShortIfContext is an interface to support dynamic dispatch.
type IEnhancedForStatementNoShortIfContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEnhancedForStatementNoShortIfContext differentiates from other interfaces.
	IsEnhancedForStatementNoShortIfContext()
}

type EnhancedForStatementNoShortIfContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEnhancedForStatementNoShortIfContext() *EnhancedForStatementNoShortIfContext {
	var p = new(EnhancedForStatementNoShortIfContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Java9ParserRULE_enhancedForStatementNoShortIf
	return p
}

func (*EnhancedForStatementNoShortIfContext) IsEnhancedForStatementNoShortIfContext() {}

func NewEnhancedForStatementNoShortIfContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EnhancedForStatementNoShortIfContext {
	var p = new(EnhancedForStatementNoShortIfContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java9ParserRULE_enhancedForStatementNoShortIf

	return p
}

func (s *EnhancedForStatementNoShortIfContext) GetParser() antlr.Parser { return s.parser }

func (s *EnhancedForStatementNoShortIfContext) FOR() antlr.TerminalNode {
	return s.GetToken(Java9ParserFOR, 0)
}

func (s *EnhancedForStatementNoShortIfContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(Java9ParserLPAREN, 0)
}

func (s *EnhancedForStatementNoShortIfContext) UnannType() IUnannTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUnannTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IUnannTypeContext)
}

func (s *EnhancedForStatementNoShortIfContext) VariableDeclaratorId() IVariableDeclaratorIdContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVariableDeclaratorIdContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IVariableDeclaratorIdContext)
}

func (s *EnhancedForStatementNoShortIfContext) COLON() antlr.TerminalNode {
	return s.GetToken(Java9ParserCOLON, 0)
}

func (s *EnhancedForStatementNoShortIfContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *EnhancedForStatementNoShortIfContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(Java9ParserRPAREN, 0)
}

func (s *EnhancedForStatementNoShortIfContext) StatementNoShortIf() IStatementNoShortIfContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStatementNoShortIfContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IStatementNoShortIfContext)
}

func (s *EnhancedForStatementNoShortIfContext) AllVariableModifier() []IVariableModifierContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IVariableModifierContext)(nil)).Elem())
	var tst = make([]IVariableModifierContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IVariableModifierContext)
		}
	}

	return tst
}

func (s *EnhancedForStatementNoShortIfContext) VariableModifier(i int) IVariableModifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVariableModifierContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IVariableModifierContext)
}

func (s *EnhancedForStatementNoShortIfContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EnhancedForStatementNoShortIfContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EnhancedForStatementNoShortIfContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.EnterEnhancedForStatementNoShortIf(s)
	}
}

func (s *EnhancedForStatementNoShortIfContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.ExitEnhancedForStatementNoShortIf(s)
	}
}

func (p *Java9Parser) EnhancedForStatementNoShortIf() (localctx IEnhancedForStatementNoShortIfContext) {
	localctx = NewEnhancedForStatementNoShortIfContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 330, Java9ParserRULE_enhancedForStatementNoShortIf)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1845)
		p.Match(Java9ParserFOR)
	}
	{
		p.SetState(1846)
		p.Match(Java9ParserLPAREN)
	}
	p.SetState(1850)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == Java9ParserFINAL || _la == Java9ParserAT {
		{
			p.SetState(1847)
			p.VariableModifier()
		}

		p.SetState(1852)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1853)
		p.UnannType()
	}
	{
		p.SetState(1854)
		p.VariableDeclaratorId()
	}
	{
		p.SetState(1855)
		p.Match(Java9ParserCOLON)
	}
	{
		p.SetState(1856)
		p.Expression()
	}
	{
		p.SetState(1857)
		p.Match(Java9ParserRPAREN)
	}
	{
		p.SetState(1858)
		p.StatementNoShortIf()
	}

	return localctx
}

// IBreakStatementContext is an interface to support dynamic dispatch.
type IBreakStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsBreakStatementContext differentiates from other interfaces.
	IsBreakStatementContext()
}

type BreakStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBreakStatementContext() *BreakStatementContext {
	var p = new(BreakStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Java9ParserRULE_breakStatement
	return p
}

func (*BreakStatementContext) IsBreakStatementContext() {}

func NewBreakStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BreakStatementContext {
	var p = new(BreakStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java9ParserRULE_breakStatement

	return p
}

func (s *BreakStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *BreakStatementContext) BREAK() antlr.TerminalNode {
	return s.GetToken(Java9ParserBREAK, 0)
}

func (s *BreakStatementContext) SEMI() antlr.TerminalNode {
	return s.GetToken(Java9ParserSEMI, 0)
}

func (s *BreakStatementContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *BreakStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BreakStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BreakStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.EnterBreakStatement(s)
	}
}

func (s *BreakStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.ExitBreakStatement(s)
	}
}

func (p *Java9Parser) BreakStatement() (localctx IBreakStatementContext) {
	localctx = NewBreakStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 332, Java9ParserRULE_breakStatement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1860)
		p.Match(Java9ParserBREAK)
	}
	p.SetState(1862)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Java9ParserEXPORTS || _la == Java9ParserMODULE || (((_la-34)&-(0x1f+1)) == 0 && ((1<<uint((_la-34)))&((1<<(Java9ParserOPEN-34))|(1<<(Java9ParserOPERNS-34))|(1<<(Java9ParserPROVIDES-34))|(1<<(Java9ParserREQUIRES-34))|(1<<(Java9ParserTO-34))|(1<<(Java9ParserUSES-34))|(1<<(Java9ParserWITH-34)))) != 0) || _la == Java9ParserIdentifier {
		{
			p.SetState(1861)
			p.Identifier()
		}

	}
	{
		p.SetState(1864)
		p.Match(Java9ParserSEMI)
	}

	return localctx
}

// IContinueStatementContext is an interface to support dynamic dispatch.
type IContinueStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsContinueStatementContext differentiates from other interfaces.
	IsContinueStatementContext()
}

type ContinueStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyContinueStatementContext() *ContinueStatementContext {
	var p = new(ContinueStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Java9ParserRULE_continueStatement
	return p
}

func (*ContinueStatementContext) IsContinueStatementContext() {}

func NewContinueStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ContinueStatementContext {
	var p = new(ContinueStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java9ParserRULE_continueStatement

	return p
}

func (s *ContinueStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ContinueStatementContext) CONTINUE() antlr.TerminalNode {
	return s.GetToken(Java9ParserCONTINUE, 0)
}

func (s *ContinueStatementContext) SEMI() antlr.TerminalNode {
	return s.GetToken(Java9ParserSEMI, 0)
}

func (s *ContinueStatementContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ContinueStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ContinueStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ContinueStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.EnterContinueStatement(s)
	}
}

func (s *ContinueStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.ExitContinueStatement(s)
	}
}

func (p *Java9Parser) ContinueStatement() (localctx IContinueStatementContext) {
	localctx = NewContinueStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 334, Java9ParserRULE_continueStatement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1866)
		p.Match(Java9ParserCONTINUE)
	}
	p.SetState(1868)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Java9ParserEXPORTS || _la == Java9ParserMODULE || (((_la-34)&-(0x1f+1)) == 0 && ((1<<uint((_la-34)))&((1<<(Java9ParserOPEN-34))|(1<<(Java9ParserOPERNS-34))|(1<<(Java9ParserPROVIDES-34))|(1<<(Java9ParserREQUIRES-34))|(1<<(Java9ParserTO-34))|(1<<(Java9ParserUSES-34))|(1<<(Java9ParserWITH-34)))) != 0) || _la == Java9ParserIdentifier {
		{
			p.SetState(1867)
			p.Identifier()
		}

	}
	{
		p.SetState(1870)
		p.Match(Java9ParserSEMI)
	}

	return localctx
}

// IReturnStatementContext is an interface to support dynamic dispatch.
type IReturnStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsReturnStatementContext differentiates from other interfaces.
	IsReturnStatementContext()
}

type ReturnStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReturnStatementContext() *ReturnStatementContext {
	var p = new(ReturnStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Java9ParserRULE_returnStatement
	return p
}

func (*ReturnStatementContext) IsReturnStatementContext() {}

func NewReturnStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReturnStatementContext {
	var p = new(ReturnStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java9ParserRULE_returnStatement

	return p
}

func (s *ReturnStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ReturnStatementContext) RETURN() antlr.TerminalNode {
	return s.GetToken(Java9ParserRETURN, 0)
}

func (s *ReturnStatementContext) SEMI() antlr.TerminalNode {
	return s.GetToken(Java9ParserSEMI, 0)
}

func (s *ReturnStatementContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ReturnStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReturnStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReturnStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.EnterReturnStatement(s)
	}
}

func (s *ReturnStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.ExitReturnStatement(s)
	}
}

func (p *Java9Parser) ReturnStatement() (localctx IReturnStatementContext) {
	localctx = NewReturnStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 336, Java9ParserRULE_returnStatement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1872)
		p.Match(Java9ParserRETURN)
	}
	p.SetState(1874)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<Java9ParserBOOLEAN)|(1<<Java9ParserBYTE)|(1<<Java9ParserCHAR)|(1<<Java9ParserDOUBLE)|(1<<Java9ParserEXPORTS)|(1<<Java9ParserFLOAT)|(1<<Java9ParserINT)|(1<<Java9ParserLONG)|(1<<Java9ParserMODULE))) != 0) || (((_la-33)&-(0x1f+1)) == 0 && ((1<<uint((_la-33)))&((1<<(Java9ParserNEW-33))|(1<<(Java9ParserOPEN-33))|(1<<(Java9ParserOPERNS-33))|(1<<(Java9ParserPROVIDES-33))|(1<<(Java9ParserREQUIRES-33))|(1<<(Java9ParserSHORT-33))|(1<<(Java9ParserSUPER-33))|(1<<(Java9ParserTHIS-33))|(1<<(Java9ParserTO-33))|(1<<(Java9ParserUSES-33))|(1<<(Java9ParserVOID-33))|(1<<(Java9ParserWITH-33))|(1<<(Java9ParserIntegerLiteral-33))|(1<<(Java9ParserFloatingPointLiteral-33))|(1<<(Java9ParserBooleanLiteral-33)))) != 0) || (((_la-65)&-(0x1f+1)) == 0 && ((1<<uint((_la-65)))&((1<<(Java9ParserCharacterLiteral-65))|(1<<(Java9ParserStringLiteral-65))|(1<<(Java9ParserNullLiteral-65))|(1<<(Java9ParserLPAREN-65))|(1<<(Java9ParserAT-65))|(1<<(Java9ParserBANG-65))|(1<<(Java9ParserTILDE-65))|(1<<(Java9ParserINC-65))|(1<<(Java9ParserDEC-65))|(1<<(Java9ParserADD-65)))) != 0) || _la == Java9ParserSUB || _la == Java9ParserIdentifier {
		{
			p.SetState(1873)
			p.Expression()
		}

	}
	{
		p.SetState(1876)
		p.Match(Java9ParserSEMI)
	}

	return localctx
}

// IThrowStatementContext is an interface to support dynamic dispatch.
type IThrowStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsThrowStatementContext differentiates from other interfaces.
	IsThrowStatementContext()
}

type ThrowStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyThrowStatementContext() *ThrowStatementContext {
	var p = new(ThrowStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Java9ParserRULE_throwStatement
	return p
}

func (*ThrowStatementContext) IsThrowStatementContext() {}

func NewThrowStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ThrowStatementContext {
	var p = new(ThrowStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java9ParserRULE_throwStatement

	return p
}

func (s *ThrowStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ThrowStatementContext) THROW() antlr.TerminalNode {
	return s.GetToken(Java9ParserTHROW, 0)
}

func (s *ThrowStatementContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ThrowStatementContext) SEMI() antlr.TerminalNode {
	return s.GetToken(Java9ParserSEMI, 0)
}

func (s *ThrowStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ThrowStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ThrowStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.EnterThrowStatement(s)
	}
}

func (s *ThrowStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.ExitThrowStatement(s)
	}
}

func (p *Java9Parser) ThrowStatement() (localctx IThrowStatementContext) {
	localctx = NewThrowStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 338, Java9ParserRULE_throwStatement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1878)
		p.Match(Java9ParserTHROW)
	}
	{
		p.SetState(1879)
		p.Expression()
	}
	{
		p.SetState(1880)
		p.Match(Java9ParserSEMI)
	}

	return localctx
}

// ISynchronizedStatementContext is an interface to support dynamic dispatch.
type ISynchronizedStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSynchronizedStatementContext differentiates from other interfaces.
	IsSynchronizedStatementContext()
}

type SynchronizedStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySynchronizedStatementContext() *SynchronizedStatementContext {
	var p = new(SynchronizedStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Java9ParserRULE_synchronizedStatement
	return p
}

func (*SynchronizedStatementContext) IsSynchronizedStatementContext() {}

func NewSynchronizedStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SynchronizedStatementContext {
	var p = new(SynchronizedStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java9ParserRULE_synchronizedStatement

	return p
}

func (s *SynchronizedStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *SynchronizedStatementContext) SYNCHRONIZED() antlr.TerminalNode {
	return s.GetToken(Java9ParserSYNCHRONIZED, 0)
}

func (s *SynchronizedStatementContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(Java9ParserLPAREN, 0)
}

func (s *SynchronizedStatementContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *SynchronizedStatementContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(Java9ParserRPAREN, 0)
}

func (s *SynchronizedStatementContext) Block() IBlockContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBlockContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBlockContext)
}

func (s *SynchronizedStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SynchronizedStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SynchronizedStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.EnterSynchronizedStatement(s)
	}
}

func (s *SynchronizedStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.ExitSynchronizedStatement(s)
	}
}

func (p *Java9Parser) SynchronizedStatement() (localctx ISynchronizedStatementContext) {
	localctx = NewSynchronizedStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 340, Java9ParserRULE_synchronizedStatement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1882)
		p.Match(Java9ParserSYNCHRONIZED)
	}
	{
		p.SetState(1883)
		p.Match(Java9ParserLPAREN)
	}
	{
		p.SetState(1884)
		p.Expression()
	}
	{
		p.SetState(1885)
		p.Match(Java9ParserRPAREN)
	}
	{
		p.SetState(1886)
		p.Block()
	}

	return localctx
}

// ITryStatementContext is an interface to support dynamic dispatch.
type ITryStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTryStatementContext differentiates from other interfaces.
	IsTryStatementContext()
}

type TryStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTryStatementContext() *TryStatementContext {
	var p = new(TryStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Java9ParserRULE_tryStatement
	return p
}

func (*TryStatementContext) IsTryStatementContext() {}

func NewTryStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TryStatementContext {
	var p = new(TryStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java9ParserRULE_tryStatement

	return p
}

func (s *TryStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *TryStatementContext) TRY() antlr.TerminalNode {
	return s.GetToken(Java9ParserTRY, 0)
}

func (s *TryStatementContext) Block() IBlockContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBlockContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBlockContext)
}

func (s *TryStatementContext) Catches() ICatchesContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICatchesContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICatchesContext)
}

func (s *TryStatementContext) Finally_() IFinally_Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFinally_Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFinally_Context)
}

func (s *TryStatementContext) TryWithResourcesStatement() ITryWithResourcesStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITryWithResourcesStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITryWithResourcesStatementContext)
}

func (s *TryStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TryStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TryStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.EnterTryStatement(s)
	}
}

func (s *TryStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.ExitTryStatement(s)
	}
}

func (p *Java9Parser) TryStatement() (localctx ITryStatementContext) {
	localctx = NewTryStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 342, Java9ParserRULE_tryStatement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1900)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 193, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1888)
			p.Match(Java9ParserTRY)
		}
		{
			p.SetState(1889)
			p.Block()
		}
		{
			p.SetState(1890)
			p.Catches()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1892)
			p.Match(Java9ParserTRY)
		}
		{
			p.SetState(1893)
			p.Block()
		}
		p.SetState(1895)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == Java9ParserCATCH {
			{
				p.SetState(1894)
				p.Catches()
			}

		}
		{
			p.SetState(1897)
			p.Finally_()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1899)
			p.TryWithResourcesStatement()
		}

	}

	return localctx
}

// ICatchesContext is an interface to support dynamic dispatch.
type ICatchesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCatchesContext differentiates from other interfaces.
	IsCatchesContext()
}

type CatchesContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCatchesContext() *CatchesContext {
	var p = new(CatchesContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Java9ParserRULE_catches
	return p
}

func (*CatchesContext) IsCatchesContext() {}

func NewCatchesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CatchesContext {
	var p = new(CatchesContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java9ParserRULE_catches

	return p
}

func (s *CatchesContext) GetParser() antlr.Parser { return s.parser }

func (s *CatchesContext) AllCatchClause() []ICatchClauseContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ICatchClauseContext)(nil)).Elem())
	var tst = make([]ICatchClauseContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ICatchClauseContext)
		}
	}

	return tst
}

func (s *CatchesContext) CatchClause(i int) ICatchClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICatchClauseContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ICatchClauseContext)
}

func (s *CatchesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CatchesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CatchesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.EnterCatches(s)
	}
}

func (s *CatchesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.ExitCatches(s)
	}
}

func (p *Java9Parser) Catches() (localctx ICatchesContext) {
	localctx = NewCatchesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 344, Java9ParserRULE_catches)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1903)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = _la == Java9ParserCATCH {
		{
			p.SetState(1902)
			p.CatchClause()
		}

		p.SetState(1905)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// ICatchClauseContext is an interface to support dynamic dispatch.
type ICatchClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCatchClauseContext differentiates from other interfaces.
	IsCatchClauseContext()
}

type CatchClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCatchClauseContext() *CatchClauseContext {
	var p = new(CatchClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Java9ParserRULE_catchClause
	return p
}

func (*CatchClauseContext) IsCatchClauseContext() {}

func NewCatchClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CatchClauseContext {
	var p = new(CatchClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java9ParserRULE_catchClause

	return p
}

func (s *CatchClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *CatchClauseContext) CATCH() antlr.TerminalNode {
	return s.GetToken(Java9ParserCATCH, 0)
}

func (s *CatchClauseContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(Java9ParserLPAREN, 0)
}

func (s *CatchClauseContext) CatchFormalParameter() ICatchFormalParameterContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICatchFormalParameterContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICatchFormalParameterContext)
}

func (s *CatchClauseContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(Java9ParserRPAREN, 0)
}

func (s *CatchClauseContext) Block() IBlockContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBlockContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBlockContext)
}

func (s *CatchClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CatchClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CatchClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.EnterCatchClause(s)
	}
}

func (s *CatchClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.ExitCatchClause(s)
	}
}

func (p *Java9Parser) CatchClause() (localctx ICatchClauseContext) {
	localctx = NewCatchClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 346, Java9ParserRULE_catchClause)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1907)
		p.Match(Java9ParserCATCH)
	}
	{
		p.SetState(1908)
		p.Match(Java9ParserLPAREN)
	}
	{
		p.SetState(1909)
		p.CatchFormalParameter()
	}
	{
		p.SetState(1910)
		p.Match(Java9ParserRPAREN)
	}
	{
		p.SetState(1911)
		p.Block()
	}

	return localctx
}

// ICatchFormalParameterContext is an interface to support dynamic dispatch.
type ICatchFormalParameterContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCatchFormalParameterContext differentiates from other interfaces.
	IsCatchFormalParameterContext()
}

type CatchFormalParameterContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCatchFormalParameterContext() *CatchFormalParameterContext {
	var p = new(CatchFormalParameterContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Java9ParserRULE_catchFormalParameter
	return p
}

func (*CatchFormalParameterContext) IsCatchFormalParameterContext() {}

func NewCatchFormalParameterContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CatchFormalParameterContext {
	var p = new(CatchFormalParameterContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java9ParserRULE_catchFormalParameter

	return p
}

func (s *CatchFormalParameterContext) GetParser() antlr.Parser { return s.parser }

func (s *CatchFormalParameterContext) CatchType() ICatchTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICatchTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICatchTypeContext)
}

func (s *CatchFormalParameterContext) VariableDeclaratorId() IVariableDeclaratorIdContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVariableDeclaratorIdContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IVariableDeclaratorIdContext)
}

func (s *CatchFormalParameterContext) AllVariableModifier() []IVariableModifierContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IVariableModifierContext)(nil)).Elem())
	var tst = make([]IVariableModifierContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IVariableModifierContext)
		}
	}

	return tst
}

func (s *CatchFormalParameterContext) VariableModifier(i int) IVariableModifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVariableModifierContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IVariableModifierContext)
}

func (s *CatchFormalParameterContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CatchFormalParameterContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CatchFormalParameterContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.EnterCatchFormalParameter(s)
	}
}

func (s *CatchFormalParameterContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.ExitCatchFormalParameter(s)
	}
}

func (p *Java9Parser) CatchFormalParameter() (localctx ICatchFormalParameterContext) {
	localctx = NewCatchFormalParameterContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 348, Java9ParserRULE_catchFormalParameter)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1916)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == Java9ParserFINAL || _la == Java9ParserAT {
		{
			p.SetState(1913)
			p.VariableModifier()
		}

		p.SetState(1918)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1919)
		p.CatchType()
	}
	{
		p.SetState(1920)
		p.VariableDeclaratorId()
	}

	return localctx
}

// ICatchTypeContext is an interface to support dynamic dispatch.
type ICatchTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCatchTypeContext differentiates from other interfaces.
	IsCatchTypeContext()
}

type CatchTypeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCatchTypeContext() *CatchTypeContext {
	var p = new(CatchTypeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Java9ParserRULE_catchType
	return p
}

func (*CatchTypeContext) IsCatchTypeContext() {}

func NewCatchTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CatchTypeContext {
	var p = new(CatchTypeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java9ParserRULE_catchType

	return p
}

func (s *CatchTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *CatchTypeContext) UnannClassType() IUnannClassTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUnannClassTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IUnannClassTypeContext)
}

func (s *CatchTypeContext) AllBITOR() []antlr.TerminalNode {
	return s.GetTokens(Java9ParserBITOR)
}

func (s *CatchTypeContext) BITOR(i int) antlr.TerminalNode {
	return s.GetToken(Java9ParserBITOR, i)
}

func (s *CatchTypeContext) AllClassType() []IClassTypeContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IClassTypeContext)(nil)).Elem())
	var tst = make([]IClassTypeContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IClassTypeContext)
		}
	}

	return tst
}

func (s *CatchTypeContext) ClassType(i int) IClassTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IClassTypeContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IClassTypeContext)
}

func (s *CatchTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CatchTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CatchTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.EnterCatchType(s)
	}
}

func (s *CatchTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.ExitCatchType(s)
	}
}

func (p *Java9Parser) CatchType() (localctx ICatchTypeContext) {
	localctx = NewCatchTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 350, Java9ParserRULE_catchType)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1922)
		p.UnannClassType()
	}
	p.SetState(1927)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == Java9ParserBITOR {
		{
			p.SetState(1923)
			p.Match(Java9ParserBITOR)
		}
		{
			p.SetState(1924)
			p.ClassType()
		}

		p.SetState(1929)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IFinally_Context is an interface to support dynamic dispatch.
type IFinally_Context interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFinally_Context differentiates from other interfaces.
	IsFinally_Context()
}

type Finally_Context struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFinally_Context() *Finally_Context {
	var p = new(Finally_Context)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Java9ParserRULE_finally_
	return p
}

func (*Finally_Context) IsFinally_Context() {}

func NewFinally_Context(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Finally_Context {
	var p = new(Finally_Context)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java9ParserRULE_finally_

	return p
}

func (s *Finally_Context) GetParser() antlr.Parser { return s.parser }

func (s *Finally_Context) FINALLY() antlr.TerminalNode {
	return s.GetToken(Java9ParserFINALLY, 0)
}

func (s *Finally_Context) Block() IBlockContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBlockContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBlockContext)
}

func (s *Finally_Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Finally_Context) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Finally_Context) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.EnterFinally_(s)
	}
}

func (s *Finally_Context) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.ExitFinally_(s)
	}
}

func (p *Java9Parser) Finally_() (localctx IFinally_Context) {
	localctx = NewFinally_Context(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 352, Java9ParserRULE_finally_)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1930)
		p.Match(Java9ParserFINALLY)
	}
	{
		p.SetState(1931)
		p.Block()
	}

	return localctx
}

// ITryWithResourcesStatementContext is an interface to support dynamic dispatch.
type ITryWithResourcesStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTryWithResourcesStatementContext differentiates from other interfaces.
	IsTryWithResourcesStatementContext()
}

type TryWithResourcesStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTryWithResourcesStatementContext() *TryWithResourcesStatementContext {
	var p = new(TryWithResourcesStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Java9ParserRULE_tryWithResourcesStatement
	return p
}

func (*TryWithResourcesStatementContext) IsTryWithResourcesStatementContext() {}

func NewTryWithResourcesStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TryWithResourcesStatementContext {
	var p = new(TryWithResourcesStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java9ParserRULE_tryWithResourcesStatement

	return p
}

func (s *TryWithResourcesStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *TryWithResourcesStatementContext) TRY() antlr.TerminalNode {
	return s.GetToken(Java9ParserTRY, 0)
}

func (s *TryWithResourcesStatementContext) ResourceSpecification() IResourceSpecificationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IResourceSpecificationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IResourceSpecificationContext)
}

func (s *TryWithResourcesStatementContext) Block() IBlockContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBlockContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBlockContext)
}

func (s *TryWithResourcesStatementContext) Catches() ICatchesContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICatchesContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICatchesContext)
}

func (s *TryWithResourcesStatementContext) Finally_() IFinally_Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFinally_Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFinally_Context)
}

func (s *TryWithResourcesStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TryWithResourcesStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TryWithResourcesStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.EnterTryWithResourcesStatement(s)
	}
}

func (s *TryWithResourcesStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.ExitTryWithResourcesStatement(s)
	}
}

func (p *Java9Parser) TryWithResourcesStatement() (localctx ITryWithResourcesStatementContext) {
	localctx = NewTryWithResourcesStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 354, Java9ParserRULE_tryWithResourcesStatement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1933)
		p.Match(Java9ParserTRY)
	}
	{
		p.SetState(1934)
		p.ResourceSpecification()
	}
	{
		p.SetState(1935)
		p.Block()
	}
	p.SetState(1937)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Java9ParserCATCH {
		{
			p.SetState(1936)
			p.Catches()
		}

	}
	p.SetState(1940)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Java9ParserFINALLY {
		{
			p.SetState(1939)
			p.Finally_()
		}

	}

	return localctx
}

// IResourceSpecificationContext is an interface to support dynamic dispatch.
type IResourceSpecificationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsResourceSpecificationContext differentiates from other interfaces.
	IsResourceSpecificationContext()
}

type ResourceSpecificationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyResourceSpecificationContext() *ResourceSpecificationContext {
	var p = new(ResourceSpecificationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Java9ParserRULE_resourceSpecification
	return p
}

func (*ResourceSpecificationContext) IsResourceSpecificationContext() {}

func NewResourceSpecificationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ResourceSpecificationContext {
	var p = new(ResourceSpecificationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java9ParserRULE_resourceSpecification

	return p
}

func (s *ResourceSpecificationContext) GetParser() antlr.Parser { return s.parser }

func (s *ResourceSpecificationContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(Java9ParserLPAREN, 0)
}

func (s *ResourceSpecificationContext) ResourceList() IResourceListContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IResourceListContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IResourceListContext)
}

func (s *ResourceSpecificationContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(Java9ParserRPAREN, 0)
}

func (s *ResourceSpecificationContext) SEMI() antlr.TerminalNode {
	return s.GetToken(Java9ParserSEMI, 0)
}

func (s *ResourceSpecificationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ResourceSpecificationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ResourceSpecificationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.EnterResourceSpecification(s)
	}
}

func (s *ResourceSpecificationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.ExitResourceSpecification(s)
	}
}

func (p *Java9Parser) ResourceSpecification() (localctx IResourceSpecificationContext) {
	localctx = NewResourceSpecificationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 356, Java9ParserRULE_resourceSpecification)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1942)
		p.Match(Java9ParserLPAREN)
	}
	{
		p.SetState(1943)
		p.ResourceList()
	}
	p.SetState(1945)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Java9ParserSEMI {
		{
			p.SetState(1944)
			p.Match(Java9ParserSEMI)
		}

	}
	{
		p.SetState(1947)
		p.Match(Java9ParserRPAREN)
	}

	return localctx
}

// IResourceListContext is an interface to support dynamic dispatch.
type IResourceListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsResourceListContext differentiates from other interfaces.
	IsResourceListContext()
}

type ResourceListContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyResourceListContext() *ResourceListContext {
	var p = new(ResourceListContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Java9ParserRULE_resourceList
	return p
}

func (*ResourceListContext) IsResourceListContext() {}

func NewResourceListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ResourceListContext {
	var p = new(ResourceListContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java9ParserRULE_resourceList

	return p
}

func (s *ResourceListContext) GetParser() antlr.Parser { return s.parser }

func (s *ResourceListContext) AllResource() []IResourceContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IResourceContext)(nil)).Elem())
	var tst = make([]IResourceContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IResourceContext)
		}
	}

	return tst
}

func (s *ResourceListContext) Resource(i int) IResourceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IResourceContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IResourceContext)
}

func (s *ResourceListContext) AllSEMI() []antlr.TerminalNode {
	return s.GetTokens(Java9ParserSEMI)
}

func (s *ResourceListContext) SEMI(i int) antlr.TerminalNode {
	return s.GetToken(Java9ParserSEMI, i)
}

func (s *ResourceListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ResourceListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ResourceListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.EnterResourceList(s)
	}
}

func (s *ResourceListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.ExitResourceList(s)
	}
}

func (p *Java9Parser) ResourceList() (localctx IResourceListContext) {
	localctx = NewResourceListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 358, Java9ParserRULE_resourceList)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1949)
		p.Resource()
	}
	p.SetState(1954)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 200, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1950)
				p.Match(Java9ParserSEMI)
			}
			{
				p.SetState(1951)
				p.Resource()
			}

		}
		p.SetState(1956)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 200, p.GetParserRuleContext())
	}

	return localctx
}

// IResourceContext is an interface to support dynamic dispatch.
type IResourceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsResourceContext differentiates from other interfaces.
	IsResourceContext()
}

type ResourceContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyResourceContext() *ResourceContext {
	var p = new(ResourceContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Java9ParserRULE_resource
	return p
}

func (*ResourceContext) IsResourceContext() {}

func NewResourceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ResourceContext {
	var p = new(ResourceContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java9ParserRULE_resource

	return p
}

func (s *ResourceContext) GetParser() antlr.Parser { return s.parser }

func (s *ResourceContext) UnannType() IUnannTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUnannTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IUnannTypeContext)
}

func (s *ResourceContext) VariableDeclaratorId() IVariableDeclaratorIdContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVariableDeclaratorIdContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IVariableDeclaratorIdContext)
}

func (s *ResourceContext) ASSIGN() antlr.TerminalNode {
	return s.GetToken(Java9ParserASSIGN, 0)
}

func (s *ResourceContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ResourceContext) AllVariableModifier() []IVariableModifierContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IVariableModifierContext)(nil)).Elem())
	var tst = make([]IVariableModifierContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IVariableModifierContext)
		}
	}

	return tst
}

func (s *ResourceContext) VariableModifier(i int) IVariableModifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVariableModifierContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IVariableModifierContext)
}

func (s *ResourceContext) VariableAccess() IVariableAccessContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVariableAccessContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IVariableAccessContext)
}

func (s *ResourceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ResourceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ResourceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.EnterResource(s)
	}
}

func (s *ResourceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.ExitResource(s)
	}
}

func (p *Java9Parser) Resource() (localctx IResourceContext) {
	localctx = NewResourceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 360, Java9ParserRULE_resource)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1969)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 202, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(1960)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == Java9ParserFINAL || _la == Java9ParserAT {
			{
				p.SetState(1957)
				p.VariableModifier()
			}

			p.SetState(1962)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1963)
			p.UnannType()
		}
		{
			p.SetState(1964)
			p.VariableDeclaratorId()
		}
		{
			p.SetState(1965)
			p.Match(Java9ParserASSIGN)
		}
		{
			p.SetState(1966)
			p.Expression()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1968)
			p.VariableAccess()
		}

	}

	return localctx
}

// IVariableAccessContext is an interface to support dynamic dispatch.
type IVariableAccessContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsVariableAccessContext differentiates from other interfaces.
	IsVariableAccessContext()
}

type VariableAccessContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyVariableAccessContext() *VariableAccessContext {
	var p = new(VariableAccessContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Java9ParserRULE_variableAccess
	return p
}

func (*VariableAccessContext) IsVariableAccessContext() {}

func NewVariableAccessContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *VariableAccessContext {
	var p = new(VariableAccessContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java9ParserRULE_variableAccess

	return p
}

func (s *VariableAccessContext) GetParser() antlr.Parser { return s.parser }

func (s *VariableAccessContext) ExpressionName() IExpressionNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionNameContext)
}

func (s *VariableAccessContext) FieldAccess() IFieldAccessContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFieldAccessContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFieldAccessContext)
}

func (s *VariableAccessContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VariableAccessContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *VariableAccessContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.EnterVariableAccess(s)
	}
}

func (s *VariableAccessContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.ExitVariableAccess(s)
	}
}

func (p *Java9Parser) VariableAccess() (localctx IVariableAccessContext) {
	localctx = NewVariableAccessContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 362, Java9ParserRULE_variableAccess)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1973)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 203, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1971)
			p.ExpressionName()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1972)
			p.FieldAccess()
		}

	}

	return localctx
}

// IPrimaryContext is an interface to support dynamic dispatch.
type IPrimaryContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPrimaryContext differentiates from other interfaces.
	IsPrimaryContext()
}

type PrimaryContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPrimaryContext() *PrimaryContext {
	var p = new(PrimaryContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Java9ParserRULE_primary
	return p
}

func (*PrimaryContext) IsPrimaryContext() {}

func NewPrimaryContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PrimaryContext {
	var p = new(PrimaryContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java9ParserRULE_primary

	return p
}

func (s *PrimaryContext) GetParser() antlr.Parser { return s.parser }

func (s *PrimaryContext) PrimaryNoNewArray_lfno_primary() IPrimaryNoNewArray_lfno_primaryContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPrimaryNoNewArray_lfno_primaryContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPrimaryNoNewArray_lfno_primaryContext)
}

func (s *PrimaryContext) ArrayCreationExpression() IArrayCreationExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IArrayCreationExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IArrayCreationExpressionContext)
}

func (s *PrimaryContext) AllPrimaryNoNewArray_lf_primary() []IPrimaryNoNewArray_lf_primaryContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IPrimaryNoNewArray_lf_primaryContext)(nil)).Elem())
	var tst = make([]IPrimaryNoNewArray_lf_primaryContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IPrimaryNoNewArray_lf_primaryContext)
		}
	}

	return tst
}

func (s *PrimaryContext) PrimaryNoNewArray_lf_primary(i int) IPrimaryNoNewArray_lf_primaryContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPrimaryNoNewArray_lf_primaryContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IPrimaryNoNewArray_lf_primaryContext)
}

func (s *PrimaryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PrimaryContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PrimaryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.EnterPrimary(s)
	}
}

func (s *PrimaryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.ExitPrimary(s)
	}
}

func (p *Java9Parser) Primary() (localctx IPrimaryContext) {
	localctx = NewPrimaryContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 364, Java9ParserRULE_primary)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1977)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 204, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(1975)
			p.PrimaryNoNewArray_lfno_primary()
		}

	case 2:
		{
			p.SetState(1976)
			p.ArrayCreationExpression()
		}

	}
	p.SetState(1982)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 205, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1979)
				p.PrimaryNoNewArray_lf_primary()
			}

		}
		p.SetState(1984)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 205, p.GetParserRuleContext())
	}

	return localctx
}

// IPrimaryNoNewArrayContext is an interface to support dynamic dispatch.
type IPrimaryNoNewArrayContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPrimaryNoNewArrayContext differentiates from other interfaces.
	IsPrimaryNoNewArrayContext()
}

type PrimaryNoNewArrayContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPrimaryNoNewArrayContext() *PrimaryNoNewArrayContext {
	var p = new(PrimaryNoNewArrayContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Java9ParserRULE_primaryNoNewArray
	return p
}

func (*PrimaryNoNewArrayContext) IsPrimaryNoNewArrayContext() {}

func NewPrimaryNoNewArrayContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PrimaryNoNewArrayContext {
	var p = new(PrimaryNoNewArrayContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java9ParserRULE_primaryNoNewArray

	return p
}

func (s *PrimaryNoNewArrayContext) GetParser() antlr.Parser { return s.parser }

func (s *PrimaryNoNewArrayContext) Literal() ILiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILiteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILiteralContext)
}

func (s *PrimaryNoNewArrayContext) ClassLiteral() IClassLiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IClassLiteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IClassLiteralContext)
}

func (s *PrimaryNoNewArrayContext) THIS() antlr.TerminalNode {
	return s.GetToken(Java9ParserTHIS, 0)
}

func (s *PrimaryNoNewArrayContext) TypeName() ITypeNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypeNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITypeNameContext)
}

func (s *PrimaryNoNewArrayContext) DOT() antlr.TerminalNode {
	return s.GetToken(Java9ParserDOT, 0)
}

func (s *PrimaryNoNewArrayContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(Java9ParserLPAREN, 0)
}

func (s *PrimaryNoNewArrayContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *PrimaryNoNewArrayContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(Java9ParserRPAREN, 0)
}

func (s *PrimaryNoNewArrayContext) ClassInstanceCreationExpression() IClassInstanceCreationExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IClassInstanceCreationExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IClassInstanceCreationExpressionContext)
}

func (s *PrimaryNoNewArrayContext) FieldAccess() IFieldAccessContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFieldAccessContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFieldAccessContext)
}

func (s *PrimaryNoNewArrayContext) ArrayAccess() IArrayAccessContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IArrayAccessContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IArrayAccessContext)
}

func (s *PrimaryNoNewArrayContext) MethodInvocation() IMethodInvocationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMethodInvocationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMethodInvocationContext)
}

func (s *PrimaryNoNewArrayContext) MethodReference() IMethodReferenceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMethodReferenceContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMethodReferenceContext)
}

func (s *PrimaryNoNewArrayContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PrimaryNoNewArrayContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PrimaryNoNewArrayContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.EnterPrimaryNoNewArray(s)
	}
}

func (s *PrimaryNoNewArrayContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.ExitPrimaryNoNewArray(s)
	}
}

func (p *Java9Parser) PrimaryNoNewArray() (localctx IPrimaryNoNewArrayContext) {
	localctx = NewPrimaryNoNewArrayContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 366, Java9ParserRULE_primaryNoNewArray)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(2001)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 206, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1985)
			p.Literal()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1986)
			p.ClassLiteral()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1987)
			p.Match(Java9ParserTHIS)
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1988)
			p.TypeName()
		}
		{
			p.SetState(1989)
			p.Match(Java9ParserDOT)
		}
		{
			p.SetState(1990)
			p.Match(Java9ParserTHIS)
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1992)
			p.Match(Java9ParserLPAREN)
		}
		{
			p.SetState(1993)
			p.Expression()
		}
		{
			p.SetState(1994)
			p.Match(Java9ParserRPAREN)
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(1996)
			p.ClassInstanceCreationExpression()
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(1997)
			p.FieldAccess()
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(1998)
			p.ArrayAccess()
		}

	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(1999)
			p.MethodInvocation()
		}

	case 10:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(2000)
			p.MethodReference()
		}

	}

	return localctx
}

// IPrimaryNoNewArray_lf_arrayAccessContext is an interface to support dynamic dispatch.
type IPrimaryNoNewArray_lf_arrayAccessContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPrimaryNoNewArray_lf_arrayAccessContext differentiates from other interfaces.
	IsPrimaryNoNewArray_lf_arrayAccessContext()
}

type PrimaryNoNewArray_lf_arrayAccessContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPrimaryNoNewArray_lf_arrayAccessContext() *PrimaryNoNewArray_lf_arrayAccessContext {
	var p = new(PrimaryNoNewArray_lf_arrayAccessContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Java9ParserRULE_primaryNoNewArray_lf_arrayAccess
	return p
}

func (*PrimaryNoNewArray_lf_arrayAccessContext) IsPrimaryNoNewArray_lf_arrayAccessContext() {}

func NewPrimaryNoNewArray_lf_arrayAccessContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PrimaryNoNewArray_lf_arrayAccessContext {
	var p = new(PrimaryNoNewArray_lf_arrayAccessContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java9ParserRULE_primaryNoNewArray_lf_arrayAccess

	return p
}

func (s *PrimaryNoNewArray_lf_arrayAccessContext) GetParser() antlr.Parser { return s.parser }
func (s *PrimaryNoNewArray_lf_arrayAccessContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PrimaryNoNewArray_lf_arrayAccessContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PrimaryNoNewArray_lf_arrayAccessContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.EnterPrimaryNoNewArray_lf_arrayAccess(s)
	}
}

func (s *PrimaryNoNewArray_lf_arrayAccessContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.ExitPrimaryNoNewArray_lf_arrayAccess(s)
	}
}

func (p *Java9Parser) PrimaryNoNewArray_lf_arrayAccess() (localctx IPrimaryNoNewArray_lf_arrayAccessContext) {
	localctx = NewPrimaryNoNewArray_lf_arrayAccessContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 368, Java9ParserRULE_primaryNoNewArray_lf_arrayAccess)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)

	return localctx
}

// IPrimaryNoNewArray_lfno_arrayAccessContext is an interface to support dynamic dispatch.
type IPrimaryNoNewArray_lfno_arrayAccessContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPrimaryNoNewArray_lfno_arrayAccessContext differentiates from other interfaces.
	IsPrimaryNoNewArray_lfno_arrayAccessContext()
}

type PrimaryNoNewArray_lfno_arrayAccessContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPrimaryNoNewArray_lfno_arrayAccessContext() *PrimaryNoNewArray_lfno_arrayAccessContext {
	var p = new(PrimaryNoNewArray_lfno_arrayAccessContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Java9ParserRULE_primaryNoNewArray_lfno_arrayAccess
	return p
}

func (*PrimaryNoNewArray_lfno_arrayAccessContext) IsPrimaryNoNewArray_lfno_arrayAccessContext() {}

func NewPrimaryNoNewArray_lfno_arrayAccessContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PrimaryNoNewArray_lfno_arrayAccessContext {
	var p = new(PrimaryNoNewArray_lfno_arrayAccessContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java9ParserRULE_primaryNoNewArray_lfno_arrayAccess

	return p
}

func (s *PrimaryNoNewArray_lfno_arrayAccessContext) GetParser() antlr.Parser { return s.parser }

func (s *PrimaryNoNewArray_lfno_arrayAccessContext) Literal() ILiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILiteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILiteralContext)
}

func (s *PrimaryNoNewArray_lfno_arrayAccessContext) TypeName() ITypeNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypeNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITypeNameContext)
}

func (s *PrimaryNoNewArray_lfno_arrayAccessContext) DOT() antlr.TerminalNode {
	return s.GetToken(Java9ParserDOT, 0)
}

func (s *PrimaryNoNewArray_lfno_arrayAccessContext) CLASS() antlr.TerminalNode {
	return s.GetToken(Java9ParserCLASS, 0)
}

func (s *PrimaryNoNewArray_lfno_arrayAccessContext) AllLBRACK() []antlr.TerminalNode {
	return s.GetTokens(Java9ParserLBRACK)
}

func (s *PrimaryNoNewArray_lfno_arrayAccessContext) LBRACK(i int) antlr.TerminalNode {
	return s.GetToken(Java9ParserLBRACK, i)
}

func (s *PrimaryNoNewArray_lfno_arrayAccessContext) AllRBRACK() []antlr.TerminalNode {
	return s.GetTokens(Java9ParserRBRACK)
}

func (s *PrimaryNoNewArray_lfno_arrayAccessContext) RBRACK(i int) antlr.TerminalNode {
	return s.GetToken(Java9ParserRBRACK, i)
}

func (s *PrimaryNoNewArray_lfno_arrayAccessContext) VOID() antlr.TerminalNode {
	return s.GetToken(Java9ParserVOID, 0)
}

func (s *PrimaryNoNewArray_lfno_arrayAccessContext) THIS() antlr.TerminalNode {
	return s.GetToken(Java9ParserTHIS, 0)
}

func (s *PrimaryNoNewArray_lfno_arrayAccessContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(Java9ParserLPAREN, 0)
}

func (s *PrimaryNoNewArray_lfno_arrayAccessContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *PrimaryNoNewArray_lfno_arrayAccessContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(Java9ParserRPAREN, 0)
}

func (s *PrimaryNoNewArray_lfno_arrayAccessContext) ClassInstanceCreationExpression() IClassInstanceCreationExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IClassInstanceCreationExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IClassInstanceCreationExpressionContext)
}

func (s *PrimaryNoNewArray_lfno_arrayAccessContext) FieldAccess() IFieldAccessContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFieldAccessContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFieldAccessContext)
}

func (s *PrimaryNoNewArray_lfno_arrayAccessContext) MethodInvocation() IMethodInvocationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMethodInvocationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMethodInvocationContext)
}

func (s *PrimaryNoNewArray_lfno_arrayAccessContext) MethodReference() IMethodReferenceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMethodReferenceContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMethodReferenceContext)
}

func (s *PrimaryNoNewArray_lfno_arrayAccessContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PrimaryNoNewArray_lfno_arrayAccessContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PrimaryNoNewArray_lfno_arrayAccessContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.EnterPrimaryNoNewArray_lfno_arrayAccess(s)
	}
}

func (s *PrimaryNoNewArray_lfno_arrayAccessContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.ExitPrimaryNoNewArray_lfno_arrayAccess(s)
	}
}

func (p *Java9Parser) PrimaryNoNewArray_lfno_arrayAccess() (localctx IPrimaryNoNewArray_lfno_arrayAccessContext) {
	localctx = NewPrimaryNoNewArray_lfno_arrayAccessContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 370, Java9ParserRULE_primaryNoNewArray_lfno_arrayAccess)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(2033)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 208, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2005)
			p.Literal()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2006)
			p.TypeName()
		}
		p.SetState(2011)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == Java9ParserLBRACK {
			{
				p.SetState(2007)
				p.Match(Java9ParserLBRACK)
			}
			{
				p.SetState(2008)
				p.Match(Java9ParserRBRACK)
			}

			p.SetState(2013)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(2014)
			p.Match(Java9ParserDOT)
		}
		{
			p.SetState(2015)
			p.Match(Java9ParserCLASS)
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2017)
			p.Match(Java9ParserVOID)
		}
		{
			p.SetState(2018)
			p.Match(Java9ParserDOT)
		}
		{
			p.SetState(2019)
			p.Match(Java9ParserCLASS)
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(2020)
			p.Match(Java9ParserTHIS)
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(2021)
			p.TypeName()
		}
		{
			p.SetState(2022)
			p.Match(Java9ParserDOT)
		}
		{
			p.SetState(2023)
			p.Match(Java9ParserTHIS)
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(2025)
			p.Match(Java9ParserLPAREN)
		}
		{
			p.SetState(2026)
			p.Expression()
		}
		{
			p.SetState(2027)
			p.Match(Java9ParserRPAREN)
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(2029)
			p.ClassInstanceCreationExpression()
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(2030)
			p.FieldAccess()
		}

	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(2031)
			p.MethodInvocation()
		}

	case 10:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(2032)
			p.MethodReference()
		}

	}

	return localctx
}

// IPrimaryNoNewArray_lf_primaryContext is an interface to support dynamic dispatch.
type IPrimaryNoNewArray_lf_primaryContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPrimaryNoNewArray_lf_primaryContext differentiates from other interfaces.
	IsPrimaryNoNewArray_lf_primaryContext()
}

type PrimaryNoNewArray_lf_primaryContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPrimaryNoNewArray_lf_primaryContext() *PrimaryNoNewArray_lf_primaryContext {
	var p = new(PrimaryNoNewArray_lf_primaryContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Java9ParserRULE_primaryNoNewArray_lf_primary
	return p
}

func (*PrimaryNoNewArray_lf_primaryContext) IsPrimaryNoNewArray_lf_primaryContext() {}

func NewPrimaryNoNewArray_lf_primaryContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PrimaryNoNewArray_lf_primaryContext {
	var p = new(PrimaryNoNewArray_lf_primaryContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java9ParserRULE_primaryNoNewArray_lf_primary

	return p
}

func (s *PrimaryNoNewArray_lf_primaryContext) GetParser() antlr.Parser { return s.parser }

func (s *PrimaryNoNewArray_lf_primaryContext) ClassInstanceCreationExpression_lf_primary() IClassInstanceCreationExpression_lf_primaryContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IClassInstanceCreationExpression_lf_primaryContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IClassInstanceCreationExpression_lf_primaryContext)
}

func (s *PrimaryNoNewArray_lf_primaryContext) FieldAccess_lf_primary() IFieldAccess_lf_primaryContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFieldAccess_lf_primaryContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFieldAccess_lf_primaryContext)
}

func (s *PrimaryNoNewArray_lf_primaryContext) ArrayAccess_lf_primary() IArrayAccess_lf_primaryContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IArrayAccess_lf_primaryContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IArrayAccess_lf_primaryContext)
}

func (s *PrimaryNoNewArray_lf_primaryContext) MethodInvocation_lf_primary() IMethodInvocation_lf_primaryContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMethodInvocation_lf_primaryContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMethodInvocation_lf_primaryContext)
}

func (s *PrimaryNoNewArray_lf_primaryContext) MethodReference_lf_primary() IMethodReference_lf_primaryContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMethodReference_lf_primaryContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMethodReference_lf_primaryContext)
}

func (s *PrimaryNoNewArray_lf_primaryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PrimaryNoNewArray_lf_primaryContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PrimaryNoNewArray_lf_primaryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.EnterPrimaryNoNewArray_lf_primary(s)
	}
}

func (s *PrimaryNoNewArray_lf_primaryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.ExitPrimaryNoNewArray_lf_primary(s)
	}
}

func (p *Java9Parser) PrimaryNoNewArray_lf_primary() (localctx IPrimaryNoNewArray_lf_primaryContext) {
	localctx = NewPrimaryNoNewArray_lf_primaryContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 372, Java9ParserRULE_primaryNoNewArray_lf_primary)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(2040)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 209, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2035)
			p.ClassInstanceCreationExpression_lf_primary()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2036)
			p.FieldAccess_lf_primary()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2037)
			p.ArrayAccess_lf_primary()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(2038)
			p.MethodInvocation_lf_primary()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(2039)
			p.MethodReference_lf_primary()
		}

	}

	return localctx
}

// IPrimaryNoNewArray_lf_primary_lf_arrayAccess_lf_primaryContext is an interface to support dynamic dispatch.
type IPrimaryNoNewArray_lf_primary_lf_arrayAccess_lf_primaryContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPrimaryNoNewArray_lf_primary_lf_arrayAccess_lf_primaryContext differentiates from other interfaces.
	IsPrimaryNoNewArray_lf_primary_lf_arrayAccess_lf_primaryContext()
}

type PrimaryNoNewArray_lf_primary_lf_arrayAccess_lf_primaryContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPrimaryNoNewArray_lf_primary_lf_arrayAccess_lf_primaryContext() *PrimaryNoNewArray_lf_primary_lf_arrayAccess_lf_primaryContext {
	var p = new(PrimaryNoNewArray_lf_primary_lf_arrayAccess_lf_primaryContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Java9ParserRULE_primaryNoNewArray_lf_primary_lf_arrayAccess_lf_primary
	return p
}

func (*PrimaryNoNewArray_lf_primary_lf_arrayAccess_lf_primaryContext) IsPrimaryNoNewArray_lf_primary_lf_arrayAccess_lf_primaryContext() {
}

func NewPrimaryNoNewArray_lf_primary_lf_arrayAccess_lf_primaryContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PrimaryNoNewArray_lf_primary_lf_arrayAccess_lf_primaryContext {
	var p = new(PrimaryNoNewArray_lf_primary_lf_arrayAccess_lf_primaryContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java9ParserRULE_primaryNoNewArray_lf_primary_lf_arrayAccess_lf_primary

	return p
}

func (s *PrimaryNoNewArray_lf_primary_lf_arrayAccess_lf_primaryContext) GetParser() antlr.Parser {
	return s.parser
}
func (s *PrimaryNoNewArray_lf_primary_lf_arrayAccess_lf_primaryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PrimaryNoNewArray_lf_primary_lf_arrayAccess_lf_primaryContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PrimaryNoNewArray_lf_primary_lf_arrayAccess_lf_primaryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.EnterPrimaryNoNewArray_lf_primary_lf_arrayAccess_lf_primary(s)
	}
}

func (s *PrimaryNoNewArray_lf_primary_lf_arrayAccess_lf_primaryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.ExitPrimaryNoNewArray_lf_primary_lf_arrayAccess_lf_primary(s)
	}
}

func (p *Java9Parser) PrimaryNoNewArray_lf_primary_lf_arrayAccess_lf_primary() (localctx IPrimaryNoNewArray_lf_primary_lf_arrayAccess_lf_primaryContext) {
	localctx = NewPrimaryNoNewArray_lf_primary_lf_arrayAccess_lf_primaryContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 374, Java9ParserRULE_primaryNoNewArray_lf_primary_lf_arrayAccess_lf_primary)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)

	return localctx
}

// IPrimaryNoNewArray_lf_primary_lfno_arrayAccess_lf_primaryContext is an interface to support dynamic dispatch.
type IPrimaryNoNewArray_lf_primary_lfno_arrayAccess_lf_primaryContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPrimaryNoNewArray_lf_primary_lfno_arrayAccess_lf_primaryContext differentiates from other interfaces.
	IsPrimaryNoNewArray_lf_primary_lfno_arrayAccess_lf_primaryContext()
}

type PrimaryNoNewArray_lf_primary_lfno_arrayAccess_lf_primaryContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPrimaryNoNewArray_lf_primary_lfno_arrayAccess_lf_primaryContext() *PrimaryNoNewArray_lf_primary_lfno_arrayAccess_lf_primaryContext {
	var p = new(PrimaryNoNewArray_lf_primary_lfno_arrayAccess_lf_primaryContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Java9ParserRULE_primaryNoNewArray_lf_primary_lfno_arrayAccess_lf_primary
	return p
}

func (*PrimaryNoNewArray_lf_primary_lfno_arrayAccess_lf_primaryContext) IsPrimaryNoNewArray_lf_primary_lfno_arrayAccess_lf_primaryContext() {
}

func NewPrimaryNoNewArray_lf_primary_lfno_arrayAccess_lf_primaryContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PrimaryNoNewArray_lf_primary_lfno_arrayAccess_lf_primaryContext {
	var p = new(PrimaryNoNewArray_lf_primary_lfno_arrayAccess_lf_primaryContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java9ParserRULE_primaryNoNewArray_lf_primary_lfno_arrayAccess_lf_primary

	return p
}

func (s *PrimaryNoNewArray_lf_primary_lfno_arrayAccess_lf_primaryContext) GetParser() antlr.Parser {
	return s.parser
}

func (s *PrimaryNoNewArray_lf_primary_lfno_arrayAccess_lf_primaryContext) ClassInstanceCreationExpression_lf_primary() IClassInstanceCreationExpression_lf_primaryContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IClassInstanceCreationExpression_lf_primaryContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IClassInstanceCreationExpression_lf_primaryContext)
}

func (s *PrimaryNoNewArray_lf_primary_lfno_arrayAccess_lf_primaryContext) FieldAccess_lf_primary() IFieldAccess_lf_primaryContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFieldAccess_lf_primaryContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFieldAccess_lf_primaryContext)
}

func (s *PrimaryNoNewArray_lf_primary_lfno_arrayAccess_lf_primaryContext) MethodInvocation_lf_primary() IMethodInvocation_lf_primaryContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMethodInvocation_lf_primaryContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMethodInvocation_lf_primaryContext)
}

func (s *PrimaryNoNewArray_lf_primary_lfno_arrayAccess_lf_primaryContext) MethodReference_lf_primary() IMethodReference_lf_primaryContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMethodReference_lf_primaryContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMethodReference_lf_primaryContext)
}

func (s *PrimaryNoNewArray_lf_primary_lfno_arrayAccess_lf_primaryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PrimaryNoNewArray_lf_primary_lfno_arrayAccess_lf_primaryContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PrimaryNoNewArray_lf_primary_lfno_arrayAccess_lf_primaryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.EnterPrimaryNoNewArray_lf_primary_lfno_arrayAccess_lf_primary(s)
	}
}

func (s *PrimaryNoNewArray_lf_primary_lfno_arrayAccess_lf_primaryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.ExitPrimaryNoNewArray_lf_primary_lfno_arrayAccess_lf_primary(s)
	}
}

func (p *Java9Parser) PrimaryNoNewArray_lf_primary_lfno_arrayAccess_lf_primary() (localctx IPrimaryNoNewArray_lf_primary_lfno_arrayAccess_lf_primaryContext) {
	localctx = NewPrimaryNoNewArray_lf_primary_lfno_arrayAccess_lf_primaryContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 376, Java9ParserRULE_primaryNoNewArray_lf_primary_lfno_arrayAccess_lf_primary)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(2048)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 210, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2044)
			p.ClassInstanceCreationExpression_lf_primary()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2045)
			p.FieldAccess_lf_primary()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2046)
			p.MethodInvocation_lf_primary()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(2047)
			p.MethodReference_lf_primary()
		}

	}

	return localctx
}

// IPrimaryNoNewArray_lfno_primaryContext is an interface to support dynamic dispatch.
type IPrimaryNoNewArray_lfno_primaryContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPrimaryNoNewArray_lfno_primaryContext differentiates from other interfaces.
	IsPrimaryNoNewArray_lfno_primaryContext()
}

type PrimaryNoNewArray_lfno_primaryContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPrimaryNoNewArray_lfno_primaryContext() *PrimaryNoNewArray_lfno_primaryContext {
	var p = new(PrimaryNoNewArray_lfno_primaryContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Java9ParserRULE_primaryNoNewArray_lfno_primary
	return p
}

func (*PrimaryNoNewArray_lfno_primaryContext) IsPrimaryNoNewArray_lfno_primaryContext() {}

func NewPrimaryNoNewArray_lfno_primaryContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PrimaryNoNewArray_lfno_primaryContext {
	var p = new(PrimaryNoNewArray_lfno_primaryContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java9ParserRULE_primaryNoNewArray_lfno_primary

	return p
}

func (s *PrimaryNoNewArray_lfno_primaryContext) GetParser() antlr.Parser { return s.parser }

func (s *PrimaryNoNewArray_lfno_primaryContext) Literal() ILiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILiteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILiteralContext)
}

func (s *PrimaryNoNewArray_lfno_primaryContext) TypeName() ITypeNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypeNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITypeNameContext)
}

func (s *PrimaryNoNewArray_lfno_primaryContext) DOT() antlr.TerminalNode {
	return s.GetToken(Java9ParserDOT, 0)
}

func (s *PrimaryNoNewArray_lfno_primaryContext) CLASS() antlr.TerminalNode {
	return s.GetToken(Java9ParserCLASS, 0)
}

func (s *PrimaryNoNewArray_lfno_primaryContext) AllLBRACK() []antlr.TerminalNode {
	return s.GetTokens(Java9ParserLBRACK)
}

func (s *PrimaryNoNewArray_lfno_primaryContext) LBRACK(i int) antlr.TerminalNode {
	return s.GetToken(Java9ParserLBRACK, i)
}

func (s *PrimaryNoNewArray_lfno_primaryContext) AllRBRACK() []antlr.TerminalNode {
	return s.GetTokens(Java9ParserRBRACK)
}

func (s *PrimaryNoNewArray_lfno_primaryContext) RBRACK(i int) antlr.TerminalNode {
	return s.GetToken(Java9ParserRBRACK, i)
}

func (s *PrimaryNoNewArray_lfno_primaryContext) UnannPrimitiveType() IUnannPrimitiveTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUnannPrimitiveTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IUnannPrimitiveTypeContext)
}

func (s *PrimaryNoNewArray_lfno_primaryContext) VOID() antlr.TerminalNode {
	return s.GetToken(Java9ParserVOID, 0)
}

func (s *PrimaryNoNewArray_lfno_primaryContext) THIS() antlr.TerminalNode {
	return s.GetToken(Java9ParserTHIS, 0)
}

func (s *PrimaryNoNewArray_lfno_primaryContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(Java9ParserLPAREN, 0)
}

func (s *PrimaryNoNewArray_lfno_primaryContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *PrimaryNoNewArray_lfno_primaryContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(Java9ParserRPAREN, 0)
}

func (s *PrimaryNoNewArray_lfno_primaryContext) ClassInstanceCreationExpression_lfno_primary() IClassInstanceCreationExpression_lfno_primaryContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IClassInstanceCreationExpression_lfno_primaryContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IClassInstanceCreationExpression_lfno_primaryContext)
}

func (s *PrimaryNoNewArray_lfno_primaryContext) FieldAccess_lfno_primary() IFieldAccess_lfno_primaryContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFieldAccess_lfno_primaryContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFieldAccess_lfno_primaryContext)
}

func (s *PrimaryNoNewArray_lfno_primaryContext) ArrayAccess_lfno_primary() IArrayAccess_lfno_primaryContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IArrayAccess_lfno_primaryContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IArrayAccess_lfno_primaryContext)
}

func (s *PrimaryNoNewArray_lfno_primaryContext) MethodInvocation_lfno_primary() IMethodInvocation_lfno_primaryContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMethodInvocation_lfno_primaryContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMethodInvocation_lfno_primaryContext)
}

func (s *PrimaryNoNewArray_lfno_primaryContext) MethodReference_lfno_primary() IMethodReference_lfno_primaryContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMethodReference_lfno_primaryContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMethodReference_lfno_primaryContext)
}

func (s *PrimaryNoNewArray_lfno_primaryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PrimaryNoNewArray_lfno_primaryContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PrimaryNoNewArray_lfno_primaryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.EnterPrimaryNoNewArray_lfno_primary(s)
	}
}

func (s *PrimaryNoNewArray_lfno_primaryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.ExitPrimaryNoNewArray_lfno_primary(s)
	}
}

func (p *Java9Parser) PrimaryNoNewArray_lfno_primary() (localctx IPrimaryNoNewArray_lfno_primaryContext) {
	localctx = NewPrimaryNoNewArray_lfno_primaryContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 378, Java9ParserRULE_primaryNoNewArray_lfno_primary)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(2090)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 213, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2050)
			p.Literal()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2051)
			p.TypeName()
		}
		p.SetState(2056)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == Java9ParserLBRACK {
			{
				p.SetState(2052)
				p.Match(Java9ParserLBRACK)
			}
			{
				p.SetState(2053)
				p.Match(Java9ParserRBRACK)
			}

			p.SetState(2058)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(2059)
			p.Match(Java9ParserDOT)
		}
		{
			p.SetState(2060)
			p.Match(Java9ParserCLASS)
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2062)
			p.UnannPrimitiveType()
		}
		p.SetState(2067)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == Java9ParserLBRACK {
			{
				p.SetState(2063)
				p.Match(Java9ParserLBRACK)
			}
			{
				p.SetState(2064)
				p.Match(Java9ParserRBRACK)
			}

			p.SetState(2069)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(2070)
			p.Match(Java9ParserDOT)
		}
		{
			p.SetState(2071)
			p.Match(Java9ParserCLASS)
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(2073)
			p.Match(Java9ParserVOID)
		}
		{
			p.SetState(2074)
			p.Match(Java9ParserDOT)
		}
		{
			p.SetState(2075)
			p.Match(Java9ParserCLASS)
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(2076)
			p.Match(Java9ParserTHIS)
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(2077)
			p.TypeName()
		}
		{
			p.SetState(2078)
			p.Match(Java9ParserDOT)
		}
		{
			p.SetState(2079)
			p.Match(Java9ParserTHIS)
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(2081)
			p.Match(Java9ParserLPAREN)
		}
		{
			p.SetState(2082)
			p.Expression()
		}
		{
			p.SetState(2083)
			p.Match(Java9ParserRPAREN)
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(2085)
			p.ClassInstanceCreationExpression_lfno_primary()
		}

	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(2086)
			p.FieldAccess_lfno_primary()
		}

	case 10:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(2087)
			p.ArrayAccess_lfno_primary()
		}

	case 11:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(2088)
			p.MethodInvocation_lfno_primary()
		}

	case 12:
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(2089)
			p.MethodReference_lfno_primary()
		}

	}

	return localctx
}

// IPrimaryNoNewArray_lfno_primary_lf_arrayAccess_lfno_primaryContext is an interface to support dynamic dispatch.
type IPrimaryNoNewArray_lfno_primary_lf_arrayAccess_lfno_primaryContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPrimaryNoNewArray_lfno_primary_lf_arrayAccess_lfno_primaryContext differentiates from other interfaces.
	IsPrimaryNoNewArray_lfno_primary_lf_arrayAccess_lfno_primaryContext()
}

type PrimaryNoNewArray_lfno_primary_lf_arrayAccess_lfno_primaryContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPrimaryNoNewArray_lfno_primary_lf_arrayAccess_lfno_primaryContext() *PrimaryNoNewArray_lfno_primary_lf_arrayAccess_lfno_primaryContext {
	var p = new(PrimaryNoNewArray_lfno_primary_lf_arrayAccess_lfno_primaryContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Java9ParserRULE_primaryNoNewArray_lfno_primary_lf_arrayAccess_lfno_primary
	return p
}

func (*PrimaryNoNewArray_lfno_primary_lf_arrayAccess_lfno_primaryContext) IsPrimaryNoNewArray_lfno_primary_lf_arrayAccess_lfno_primaryContext() {
}

func NewPrimaryNoNewArray_lfno_primary_lf_arrayAccess_lfno_primaryContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PrimaryNoNewArray_lfno_primary_lf_arrayAccess_lfno_primaryContext {
	var p = new(PrimaryNoNewArray_lfno_primary_lf_arrayAccess_lfno_primaryContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java9ParserRULE_primaryNoNewArray_lfno_primary_lf_arrayAccess_lfno_primary

	return p
}

func (s *PrimaryNoNewArray_lfno_primary_lf_arrayAccess_lfno_primaryContext) GetParser() antlr.Parser {
	return s.parser
}
func (s *PrimaryNoNewArray_lfno_primary_lf_arrayAccess_lfno_primaryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PrimaryNoNewArray_lfno_primary_lf_arrayAccess_lfno_primaryContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PrimaryNoNewArray_lfno_primary_lf_arrayAccess_lfno_primaryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.EnterPrimaryNoNewArray_lfno_primary_lf_arrayAccess_lfno_primary(s)
	}
}

func (s *PrimaryNoNewArray_lfno_primary_lf_arrayAccess_lfno_primaryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.ExitPrimaryNoNewArray_lfno_primary_lf_arrayAccess_lfno_primary(s)
	}
}

func (p *Java9Parser) PrimaryNoNewArray_lfno_primary_lf_arrayAccess_lfno_primary() (localctx IPrimaryNoNewArray_lfno_primary_lf_arrayAccess_lfno_primaryContext) {
	localctx = NewPrimaryNoNewArray_lfno_primary_lf_arrayAccess_lfno_primaryContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 380, Java9ParserRULE_primaryNoNewArray_lfno_primary_lf_arrayAccess_lfno_primary)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)

	return localctx
}

// IPrimaryNoNewArray_lfno_primary_lfno_arrayAccess_lfno_primaryContext is an interface to support dynamic dispatch.
type IPrimaryNoNewArray_lfno_primary_lfno_arrayAccess_lfno_primaryContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPrimaryNoNewArray_lfno_primary_lfno_arrayAccess_lfno_primaryContext differentiates from other interfaces.
	IsPrimaryNoNewArray_lfno_primary_lfno_arrayAccess_lfno_primaryContext()
}

type PrimaryNoNewArray_lfno_primary_lfno_arrayAccess_lfno_primaryContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPrimaryNoNewArray_lfno_primary_lfno_arrayAccess_lfno_primaryContext() *PrimaryNoNewArray_lfno_primary_lfno_arrayAccess_lfno_primaryContext {
	var p = new(PrimaryNoNewArray_lfno_primary_lfno_arrayAccess_lfno_primaryContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Java9ParserRULE_primaryNoNewArray_lfno_primary_lfno_arrayAccess_lfno_primary
	return p
}

func (*PrimaryNoNewArray_lfno_primary_lfno_arrayAccess_lfno_primaryContext) IsPrimaryNoNewArray_lfno_primary_lfno_arrayAccess_lfno_primaryContext() {
}

func NewPrimaryNoNewArray_lfno_primary_lfno_arrayAccess_lfno_primaryContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PrimaryNoNewArray_lfno_primary_lfno_arrayAccess_lfno_primaryContext {
	var p = new(PrimaryNoNewArray_lfno_primary_lfno_arrayAccess_lfno_primaryContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java9ParserRULE_primaryNoNewArray_lfno_primary_lfno_arrayAccess_lfno_primary

	return p
}

func (s *PrimaryNoNewArray_lfno_primary_lfno_arrayAccess_lfno_primaryContext) GetParser() antlr.Parser {
	return s.parser
}

func (s *PrimaryNoNewArray_lfno_primary_lfno_arrayAccess_lfno_primaryContext) Literal() ILiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILiteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILiteralContext)
}

func (s *PrimaryNoNewArray_lfno_primary_lfno_arrayAccess_lfno_primaryContext) TypeName() ITypeNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypeNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITypeNameContext)
}

func (s *PrimaryNoNewArray_lfno_primary_lfno_arrayAccess_lfno_primaryContext) DOT() antlr.TerminalNode {
	return s.GetToken(Java9ParserDOT, 0)
}

func (s *PrimaryNoNewArray_lfno_primary_lfno_arrayAccess_lfno_primaryContext) CLASS() antlr.TerminalNode {
	return s.GetToken(Java9ParserCLASS, 0)
}

func (s *PrimaryNoNewArray_lfno_primary_lfno_arrayAccess_lfno_primaryContext) AllLBRACK() []antlr.TerminalNode {
	return s.GetTokens(Java9ParserLBRACK)
}

func (s *PrimaryNoNewArray_lfno_primary_lfno_arrayAccess_lfno_primaryContext) LBRACK(i int) antlr.TerminalNode {
	return s.GetToken(Java9ParserLBRACK, i)
}

func (s *PrimaryNoNewArray_lfno_primary_lfno_arrayAccess_lfno_primaryContext) AllRBRACK() []antlr.TerminalNode {
	return s.GetTokens(Java9ParserRBRACK)
}

func (s *PrimaryNoNewArray_lfno_primary_lfno_arrayAccess_lfno_primaryContext) RBRACK(i int) antlr.TerminalNode {
	return s.GetToken(Java9ParserRBRACK, i)
}

func (s *PrimaryNoNewArray_lfno_primary_lfno_arrayAccess_lfno_primaryContext) UnannPrimitiveType() IUnannPrimitiveTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUnannPrimitiveTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IUnannPrimitiveTypeContext)
}

func (s *PrimaryNoNewArray_lfno_primary_lfno_arrayAccess_lfno_primaryContext) VOID() antlr.TerminalNode {
	return s.GetToken(Java9ParserVOID, 0)
}

func (s *PrimaryNoNewArray_lfno_primary_lfno_arrayAccess_lfno_primaryContext) THIS() antlr.TerminalNode {
	return s.GetToken(Java9ParserTHIS, 0)
}

func (s *PrimaryNoNewArray_lfno_primary_lfno_arrayAccess_lfno_primaryContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(Java9ParserLPAREN, 0)
}

func (s *PrimaryNoNewArray_lfno_primary_lfno_arrayAccess_lfno_primaryContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *PrimaryNoNewArray_lfno_primary_lfno_arrayAccess_lfno_primaryContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(Java9ParserRPAREN, 0)
}

func (s *PrimaryNoNewArray_lfno_primary_lfno_arrayAccess_lfno_primaryContext) ClassInstanceCreationExpression_lfno_primary() IClassInstanceCreationExpression_lfno_primaryContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IClassInstanceCreationExpression_lfno_primaryContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IClassInstanceCreationExpression_lfno_primaryContext)
}

func (s *PrimaryNoNewArray_lfno_primary_lfno_arrayAccess_lfno_primaryContext) FieldAccess_lfno_primary() IFieldAccess_lfno_primaryContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFieldAccess_lfno_primaryContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFieldAccess_lfno_primaryContext)
}

func (s *PrimaryNoNewArray_lfno_primary_lfno_arrayAccess_lfno_primaryContext) MethodInvocation_lfno_primary() IMethodInvocation_lfno_primaryContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMethodInvocation_lfno_primaryContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMethodInvocation_lfno_primaryContext)
}

func (s *PrimaryNoNewArray_lfno_primary_lfno_arrayAccess_lfno_primaryContext) MethodReference_lfno_primary() IMethodReference_lfno_primaryContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMethodReference_lfno_primaryContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMethodReference_lfno_primaryContext)
}

func (s *PrimaryNoNewArray_lfno_primary_lfno_arrayAccess_lfno_primaryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PrimaryNoNewArray_lfno_primary_lfno_arrayAccess_lfno_primaryContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PrimaryNoNewArray_lfno_primary_lfno_arrayAccess_lfno_primaryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.EnterPrimaryNoNewArray_lfno_primary_lfno_arrayAccess_lfno_primary(s)
	}
}

func (s *PrimaryNoNewArray_lfno_primary_lfno_arrayAccess_lfno_primaryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.ExitPrimaryNoNewArray_lfno_primary_lfno_arrayAccess_lfno_primary(s)
	}
}

func (p *Java9Parser) PrimaryNoNewArray_lfno_primary_lfno_arrayAccess_lfno_primary() (localctx IPrimaryNoNewArray_lfno_primary_lfno_arrayAccess_lfno_primaryContext) {
	localctx = NewPrimaryNoNewArray_lfno_primary_lfno_arrayAccess_lfno_primaryContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 382, Java9ParserRULE_primaryNoNewArray_lfno_primary_lfno_arrayAccess_lfno_primary)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(2133)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 216, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2094)
			p.Literal()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2095)
			p.TypeName()
		}
		p.SetState(2100)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == Java9ParserLBRACK {
			{
				p.SetState(2096)
				p.Match(Java9ParserLBRACK)
			}
			{
				p.SetState(2097)
				p.Match(Java9ParserRBRACK)
			}

			p.SetState(2102)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(2103)
			p.Match(Java9ParserDOT)
		}
		{
			p.SetState(2104)
			p.Match(Java9ParserCLASS)
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2106)
			p.UnannPrimitiveType()
		}
		p.SetState(2111)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == Java9ParserLBRACK {
			{
				p.SetState(2107)
				p.Match(Java9ParserLBRACK)
			}
			{
				p.SetState(2108)
				p.Match(Java9ParserRBRACK)
			}

			p.SetState(2113)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(2114)
			p.Match(Java9ParserDOT)
		}
		{
			p.SetState(2115)
			p.Match(Java9ParserCLASS)
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(2117)
			p.Match(Java9ParserVOID)
		}
		{
			p.SetState(2118)
			p.Match(Java9ParserDOT)
		}
		{
			p.SetState(2119)
			p.Match(Java9ParserCLASS)
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(2120)
			p.Match(Java9ParserTHIS)
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(2121)
			p.TypeName()
		}
		{
			p.SetState(2122)
			p.Match(Java9ParserDOT)
		}
		{
			p.SetState(2123)
			p.Match(Java9ParserTHIS)
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(2125)
			p.Match(Java9ParserLPAREN)
		}
		{
			p.SetState(2126)
			p.Expression()
		}
		{
			p.SetState(2127)
			p.Match(Java9ParserRPAREN)
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(2129)
			p.ClassInstanceCreationExpression_lfno_primary()
		}

	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(2130)
			p.FieldAccess_lfno_primary()
		}

	case 10:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(2131)
			p.MethodInvocation_lfno_primary()
		}

	case 11:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(2132)
			p.MethodReference_lfno_primary()
		}

	}

	return localctx
}

// IClassLiteralContext is an interface to support dynamic dispatch.
type IClassLiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsClassLiteralContext differentiates from other interfaces.
	IsClassLiteralContext()
}

type ClassLiteralContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyClassLiteralContext() *ClassLiteralContext {
	var p = new(ClassLiteralContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Java9ParserRULE_classLiteral
	return p
}

func (*ClassLiteralContext) IsClassLiteralContext() {}

func NewClassLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ClassLiteralContext {
	var p = new(ClassLiteralContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java9ParserRULE_classLiteral

	return p
}

func (s *ClassLiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *ClassLiteralContext) DOT() antlr.TerminalNode {
	return s.GetToken(Java9ParserDOT, 0)
}

func (s *ClassLiteralContext) CLASS() antlr.TerminalNode {
	return s.GetToken(Java9ParserCLASS, 0)
}

func (s *ClassLiteralContext) TypeName() ITypeNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypeNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITypeNameContext)
}

func (s *ClassLiteralContext) NumericType() INumericTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INumericTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INumericTypeContext)
}

func (s *ClassLiteralContext) BOOLEAN() antlr.TerminalNode {
	return s.GetToken(Java9ParserBOOLEAN, 0)
}

func (s *ClassLiteralContext) AllLBRACK() []antlr.TerminalNode {
	return s.GetTokens(Java9ParserLBRACK)
}

func (s *ClassLiteralContext) LBRACK(i int) antlr.TerminalNode {
	return s.GetToken(Java9ParserLBRACK, i)
}

func (s *ClassLiteralContext) AllRBRACK() []antlr.TerminalNode {
	return s.GetTokens(Java9ParserRBRACK)
}

func (s *ClassLiteralContext) RBRACK(i int) antlr.TerminalNode {
	return s.GetToken(Java9ParserRBRACK, i)
}

func (s *ClassLiteralContext) VOID() antlr.TerminalNode {
	return s.GetToken(Java9ParserVOID, 0)
}

func (s *ClassLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ClassLiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ClassLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.EnterClassLiteral(s)
	}
}

func (s *ClassLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.ExitClassLiteral(s)
	}
}

func (p *Java9Parser) ClassLiteral() (localctx IClassLiteralContext) {
	localctx = NewClassLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 384, Java9ParserRULE_classLiteral)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(2152)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case Java9ParserBOOLEAN, Java9ParserBYTE, Java9ParserCHAR, Java9ParserDOUBLE, Java9ParserEXPORTS, Java9ParserFLOAT, Java9ParserINT, Java9ParserLONG, Java9ParserMODULE, Java9ParserOPEN, Java9ParserOPERNS, Java9ParserPROVIDES, Java9ParserREQUIRES, Java9ParserSHORT, Java9ParserTO, Java9ParserUSES, Java9ParserWITH, Java9ParserIdentifier:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(2138)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case Java9ParserEXPORTS, Java9ParserMODULE, Java9ParserOPEN, Java9ParserOPERNS, Java9ParserPROVIDES, Java9ParserREQUIRES, Java9ParserTO, Java9ParserUSES, Java9ParserWITH, Java9ParserIdentifier:
			{
				p.SetState(2135)
				p.TypeName()
			}

		case Java9ParserBYTE, Java9ParserCHAR, Java9ParserDOUBLE, Java9ParserFLOAT, Java9ParserINT, Java9ParserLONG, Java9ParserSHORT:
			{
				p.SetState(2136)
				p.NumericType()
			}

		case Java9ParserBOOLEAN:
			{
				p.SetState(2137)
				p.Match(Java9ParserBOOLEAN)
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}
		p.SetState(2144)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == Java9ParserLBRACK {
			{
				p.SetState(2140)
				p.Match(Java9ParserLBRACK)
			}
			{
				p.SetState(2141)
				p.Match(Java9ParserRBRACK)
			}

			p.SetState(2146)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(2147)
			p.Match(Java9ParserDOT)
		}
		{
			p.SetState(2148)
			p.Match(Java9ParserCLASS)
		}

	case Java9ParserVOID:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2149)
			p.Match(Java9ParserVOID)
		}
		{
			p.SetState(2150)
			p.Match(Java9ParserDOT)
		}
		{
			p.SetState(2151)
			p.Match(Java9ParserCLASS)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IClassInstanceCreationExpressionContext is an interface to support dynamic dispatch.
type IClassInstanceCreationExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsClassInstanceCreationExpressionContext differentiates from other interfaces.
	IsClassInstanceCreationExpressionContext()
}

type ClassInstanceCreationExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyClassInstanceCreationExpressionContext() *ClassInstanceCreationExpressionContext {
	var p = new(ClassInstanceCreationExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Java9ParserRULE_classInstanceCreationExpression
	return p
}

func (*ClassInstanceCreationExpressionContext) IsClassInstanceCreationExpressionContext() {}

func NewClassInstanceCreationExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ClassInstanceCreationExpressionContext {
	var p = new(ClassInstanceCreationExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java9ParserRULE_classInstanceCreationExpression

	return p
}

func (s *ClassInstanceCreationExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *ClassInstanceCreationExpressionContext) NEW() antlr.TerminalNode {
	return s.GetToken(Java9ParserNEW, 0)
}

func (s *ClassInstanceCreationExpressionContext) AllIdentifier() []IIdentifierContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IIdentifierContext)(nil)).Elem())
	var tst = make([]IIdentifierContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IIdentifierContext)
		}
	}

	return tst
}

func (s *ClassInstanceCreationExpressionContext) Identifier(i int) IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ClassInstanceCreationExpressionContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(Java9ParserLPAREN, 0)
}

func (s *ClassInstanceCreationExpressionContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(Java9ParserRPAREN, 0)
}

func (s *ClassInstanceCreationExpressionContext) TypeArguments() ITypeArgumentsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypeArgumentsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITypeArgumentsContext)
}

func (s *ClassInstanceCreationExpressionContext) AllAnnotation() []IAnnotationContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAnnotationContext)(nil)).Elem())
	var tst = make([]IAnnotationContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAnnotationContext)
		}
	}

	return tst
}

func (s *ClassInstanceCreationExpressionContext) Annotation(i int) IAnnotationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAnnotationContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAnnotationContext)
}

func (s *ClassInstanceCreationExpressionContext) AllDOT() []antlr.TerminalNode {
	return s.GetTokens(Java9ParserDOT)
}

func (s *ClassInstanceCreationExpressionContext) DOT(i int) antlr.TerminalNode {
	return s.GetToken(Java9ParserDOT, i)
}

func (s *ClassInstanceCreationExpressionContext) TypeArgumentsOrDiamond() ITypeArgumentsOrDiamondContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypeArgumentsOrDiamondContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITypeArgumentsOrDiamondContext)
}

func (s *ClassInstanceCreationExpressionContext) ArgumentList() IArgumentListContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IArgumentListContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IArgumentListContext)
}

func (s *ClassInstanceCreationExpressionContext) ClassBody() IClassBodyContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IClassBodyContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IClassBodyContext)
}

func (s *ClassInstanceCreationExpressionContext) ExpressionName() IExpressionNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionNameContext)
}

func (s *ClassInstanceCreationExpressionContext) Primary() IPrimaryContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPrimaryContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPrimaryContext)
}

func (s *ClassInstanceCreationExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ClassInstanceCreationExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ClassInstanceCreationExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.EnterClassInstanceCreationExpression(s)
	}
}

func (s *ClassInstanceCreationExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.ExitClassInstanceCreationExpression(s)
	}
}

func (p *Java9Parser) ClassInstanceCreationExpression() (localctx IClassInstanceCreationExpressionContext) {
	localctx = NewClassInstanceCreationExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 386, Java9ParserRULE_classInstanceCreationExpression)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(2237)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 237, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2154)
			p.Match(Java9ParserNEW)
		}
		p.SetState(2156)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == Java9ParserLT {
			{
				p.SetState(2155)
				p.TypeArguments()
			}

		}
		p.SetState(2161)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == Java9ParserAT {
			{
				p.SetState(2158)
				p.Annotation()
			}

			p.SetState(2163)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(2164)
			p.Identifier()
		}
		p.SetState(2175)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == Java9ParserDOT {
			{
				p.SetState(2165)
				p.Match(Java9ParserDOT)
			}
			p.SetState(2169)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			for _la == Java9ParserAT {
				{
					p.SetState(2166)
					p.Annotation()
				}

				p.SetState(2171)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)
			}
			{
				p.SetState(2172)
				p.Identifier()
			}

			p.SetState(2177)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		p.SetState(2179)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == Java9ParserLT {
			{
				p.SetState(2178)
				p.TypeArgumentsOrDiamond()
			}

		}
		{
			p.SetState(2181)
			p.Match(Java9ParserLPAREN)
		}
		p.SetState(2183)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<Java9ParserBOOLEAN)|(1<<Java9ParserBYTE)|(1<<Java9ParserCHAR)|(1<<Java9ParserDOUBLE)|(1<<Java9ParserEXPORTS)|(1<<Java9ParserFLOAT)|(1<<Java9ParserINT)|(1<<Java9ParserLONG)|(1<<Java9ParserMODULE))) != 0) || (((_la-33)&-(0x1f+1)) == 0 && ((1<<uint((_la-33)))&((1<<(Java9ParserNEW-33))|(1<<(Java9ParserOPEN-33))|(1<<(Java9ParserOPERNS-33))|(1<<(Java9ParserPROVIDES-33))|(1<<(Java9ParserREQUIRES-33))|(1<<(Java9ParserSHORT-33))|(1<<(Java9ParserSUPER-33))|(1<<(Java9ParserTHIS-33))|(1<<(Java9ParserTO-33))|(1<<(Java9ParserUSES-33))|(1<<(Java9ParserVOID-33))|(1<<(Java9ParserWITH-33))|(1<<(Java9ParserIntegerLiteral-33))|(1<<(Java9ParserFloatingPointLiteral-33))|(1<<(Java9ParserBooleanLiteral-33)))) != 0) || (((_la-65)&-(0x1f+1)) == 0 && ((1<<uint((_la-65)))&((1<<(Java9ParserCharacterLiteral-65))|(1<<(Java9ParserStringLiteral-65))|(1<<(Java9ParserNullLiteral-65))|(1<<(Java9ParserLPAREN-65))|(1<<(Java9ParserAT-65))|(1<<(Java9ParserBANG-65))|(1<<(Java9ParserTILDE-65))|(1<<(Java9ParserINC-65))|(1<<(Java9ParserDEC-65))|(1<<(Java9ParserADD-65)))) != 0) || _la == Java9ParserSUB || _la == Java9ParserIdentifier {
			{
				p.SetState(2182)
				p.ArgumentList()
			}

		}
		{
			p.SetState(2185)
			p.Match(Java9ParserRPAREN)
		}
		p.SetState(2187)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == Java9ParserLBRACE {
			{
				p.SetState(2186)
				p.ClassBody()
			}

		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2189)
			p.ExpressionName()
		}
		{
			p.SetState(2190)
			p.Match(Java9ParserDOT)
		}
		{
			p.SetState(2191)
			p.Match(Java9ParserNEW)
		}
		p.SetState(2193)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == Java9ParserLT {
			{
				p.SetState(2192)
				p.TypeArguments()
			}

		}
		p.SetState(2198)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == Java9ParserAT {
			{
				p.SetState(2195)
				p.Annotation()
			}

			p.SetState(2200)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(2201)
			p.Identifier()
		}
		p.SetState(2203)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == Java9ParserLT {
			{
				p.SetState(2202)
				p.TypeArgumentsOrDiamond()
			}

		}
		{
			p.SetState(2205)
			p.Match(Java9ParserLPAREN)
		}
		p.SetState(2207)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<Java9ParserBOOLEAN)|(1<<Java9ParserBYTE)|(1<<Java9ParserCHAR)|(1<<Java9ParserDOUBLE)|(1<<Java9ParserEXPORTS)|(1<<Java9ParserFLOAT)|(1<<Java9ParserINT)|(1<<Java9ParserLONG)|(1<<Java9ParserMODULE))) != 0) || (((_la-33)&-(0x1f+1)) == 0 && ((1<<uint((_la-33)))&((1<<(Java9ParserNEW-33))|(1<<(Java9ParserOPEN-33))|(1<<(Java9ParserOPERNS-33))|(1<<(Java9ParserPROVIDES-33))|(1<<(Java9ParserREQUIRES-33))|(1<<(Java9ParserSHORT-33))|(1<<(Java9ParserSUPER-33))|(1<<(Java9ParserTHIS-33))|(1<<(Java9ParserTO-33))|(1<<(Java9ParserUSES-33))|(1<<(Java9ParserVOID-33))|(1<<(Java9ParserWITH-33))|(1<<(Java9ParserIntegerLiteral-33))|(1<<(Java9ParserFloatingPointLiteral-33))|(1<<(Java9ParserBooleanLiteral-33)))) != 0) || (((_la-65)&-(0x1f+1)) == 0 && ((1<<uint((_la-65)))&((1<<(Java9ParserCharacterLiteral-65))|(1<<(Java9ParserStringLiteral-65))|(1<<(Java9ParserNullLiteral-65))|(1<<(Java9ParserLPAREN-65))|(1<<(Java9ParserAT-65))|(1<<(Java9ParserBANG-65))|(1<<(Java9ParserTILDE-65))|(1<<(Java9ParserINC-65))|(1<<(Java9ParserDEC-65))|(1<<(Java9ParserADD-65)))) != 0) || _la == Java9ParserSUB || _la == Java9ParserIdentifier {
			{
				p.SetState(2206)
				p.ArgumentList()
			}

		}
		{
			p.SetState(2209)
			p.Match(Java9ParserRPAREN)
		}
		p.SetState(2211)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == Java9ParserLBRACE {
			{
				p.SetState(2210)
				p.ClassBody()
			}

		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2213)
			p.Primary()
		}
		{
			p.SetState(2214)
			p.Match(Java9ParserDOT)
		}
		{
			p.SetState(2215)
			p.Match(Java9ParserNEW)
		}
		p.SetState(2217)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == Java9ParserLT {
			{
				p.SetState(2216)
				p.TypeArguments()
			}

		}
		p.SetState(2222)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == Java9ParserAT {
			{
				p.SetState(2219)
				p.Annotation()
			}

			p.SetState(2224)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(2225)
			p.Identifier()
		}
		p.SetState(2227)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == Java9ParserLT {
			{
				p.SetState(2226)
				p.TypeArgumentsOrDiamond()
			}

		}
		{
			p.SetState(2229)
			p.Match(Java9ParserLPAREN)
		}
		p.SetState(2231)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<Java9ParserBOOLEAN)|(1<<Java9ParserBYTE)|(1<<Java9ParserCHAR)|(1<<Java9ParserDOUBLE)|(1<<Java9ParserEXPORTS)|(1<<Java9ParserFLOAT)|(1<<Java9ParserINT)|(1<<Java9ParserLONG)|(1<<Java9ParserMODULE))) != 0) || (((_la-33)&-(0x1f+1)) == 0 && ((1<<uint((_la-33)))&((1<<(Java9ParserNEW-33))|(1<<(Java9ParserOPEN-33))|(1<<(Java9ParserOPERNS-33))|(1<<(Java9ParserPROVIDES-33))|(1<<(Java9ParserREQUIRES-33))|(1<<(Java9ParserSHORT-33))|(1<<(Java9ParserSUPER-33))|(1<<(Java9ParserTHIS-33))|(1<<(Java9ParserTO-33))|(1<<(Java9ParserUSES-33))|(1<<(Java9ParserVOID-33))|(1<<(Java9ParserWITH-33))|(1<<(Java9ParserIntegerLiteral-33))|(1<<(Java9ParserFloatingPointLiteral-33))|(1<<(Java9ParserBooleanLiteral-33)))) != 0) || (((_la-65)&-(0x1f+1)) == 0 && ((1<<uint((_la-65)))&((1<<(Java9ParserCharacterLiteral-65))|(1<<(Java9ParserStringLiteral-65))|(1<<(Java9ParserNullLiteral-65))|(1<<(Java9ParserLPAREN-65))|(1<<(Java9ParserAT-65))|(1<<(Java9ParserBANG-65))|(1<<(Java9ParserTILDE-65))|(1<<(Java9ParserINC-65))|(1<<(Java9ParserDEC-65))|(1<<(Java9ParserADD-65)))) != 0) || _la == Java9ParserSUB || _la == Java9ParserIdentifier {
			{
				p.SetState(2230)
				p.ArgumentList()
			}

		}
		{
			p.SetState(2233)
			p.Match(Java9ParserRPAREN)
		}
		p.SetState(2235)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == Java9ParserLBRACE {
			{
				p.SetState(2234)
				p.ClassBody()
			}

		}

	}

	return localctx
}

// IClassInstanceCreationExpression_lf_primaryContext is an interface to support dynamic dispatch.
type IClassInstanceCreationExpression_lf_primaryContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsClassInstanceCreationExpression_lf_primaryContext differentiates from other interfaces.
	IsClassInstanceCreationExpression_lf_primaryContext()
}

type ClassInstanceCreationExpression_lf_primaryContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyClassInstanceCreationExpression_lf_primaryContext() *ClassInstanceCreationExpression_lf_primaryContext {
	var p = new(ClassInstanceCreationExpression_lf_primaryContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Java9ParserRULE_classInstanceCreationExpression_lf_primary
	return p
}

func (*ClassInstanceCreationExpression_lf_primaryContext) IsClassInstanceCreationExpression_lf_primaryContext() {
}

func NewClassInstanceCreationExpression_lf_primaryContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ClassInstanceCreationExpression_lf_primaryContext {
	var p = new(ClassInstanceCreationExpression_lf_primaryContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java9ParserRULE_classInstanceCreationExpression_lf_primary

	return p
}

func (s *ClassInstanceCreationExpression_lf_primaryContext) GetParser() antlr.Parser { return s.parser }

func (s *ClassInstanceCreationExpression_lf_primaryContext) DOT() antlr.TerminalNode {
	return s.GetToken(Java9ParserDOT, 0)
}

func (s *ClassInstanceCreationExpression_lf_primaryContext) NEW() antlr.TerminalNode {
	return s.GetToken(Java9ParserNEW, 0)
}

func (s *ClassInstanceCreationExpression_lf_primaryContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ClassInstanceCreationExpression_lf_primaryContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(Java9ParserLPAREN, 0)
}

func (s *ClassInstanceCreationExpression_lf_primaryContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(Java9ParserRPAREN, 0)
}

func (s *ClassInstanceCreationExpression_lf_primaryContext) TypeArguments() ITypeArgumentsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypeArgumentsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITypeArgumentsContext)
}

func (s *ClassInstanceCreationExpression_lf_primaryContext) AllAnnotation() []IAnnotationContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAnnotationContext)(nil)).Elem())
	var tst = make([]IAnnotationContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAnnotationContext)
		}
	}

	return tst
}

func (s *ClassInstanceCreationExpression_lf_primaryContext) Annotation(i int) IAnnotationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAnnotationContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAnnotationContext)
}

func (s *ClassInstanceCreationExpression_lf_primaryContext) TypeArgumentsOrDiamond() ITypeArgumentsOrDiamondContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypeArgumentsOrDiamondContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITypeArgumentsOrDiamondContext)
}

func (s *ClassInstanceCreationExpression_lf_primaryContext) ArgumentList() IArgumentListContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IArgumentListContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IArgumentListContext)
}

func (s *ClassInstanceCreationExpression_lf_primaryContext) ClassBody() IClassBodyContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IClassBodyContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IClassBodyContext)
}

func (s *ClassInstanceCreationExpression_lf_primaryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ClassInstanceCreationExpression_lf_primaryContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ClassInstanceCreationExpression_lf_primaryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.EnterClassInstanceCreationExpression_lf_primary(s)
	}
}

func (s *ClassInstanceCreationExpression_lf_primaryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.ExitClassInstanceCreationExpression_lf_primary(s)
	}
}

func (p *Java9Parser) ClassInstanceCreationExpression_lf_primary() (localctx IClassInstanceCreationExpression_lf_primaryContext) {
	localctx = NewClassInstanceCreationExpression_lf_primaryContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 388, Java9ParserRULE_classInstanceCreationExpression_lf_primary)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2239)
		p.Match(Java9ParserDOT)
	}
	{
		p.SetState(2240)
		p.Match(Java9ParserNEW)
	}
	p.SetState(2242)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Java9ParserLT {
		{
			p.SetState(2241)
			p.TypeArguments()
		}

	}
	p.SetState(2247)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == Java9ParserAT {
		{
			p.SetState(2244)
			p.Annotation()
		}

		p.SetState(2249)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(2250)
		p.Identifier()
	}
	p.SetState(2252)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Java9ParserLT {
		{
			p.SetState(2251)
			p.TypeArgumentsOrDiamond()
		}

	}
	{
		p.SetState(2254)
		p.Match(Java9ParserLPAREN)
	}
	p.SetState(2256)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<Java9ParserBOOLEAN)|(1<<Java9ParserBYTE)|(1<<Java9ParserCHAR)|(1<<Java9ParserDOUBLE)|(1<<Java9ParserEXPORTS)|(1<<Java9ParserFLOAT)|(1<<Java9ParserINT)|(1<<Java9ParserLONG)|(1<<Java9ParserMODULE))) != 0) || (((_la-33)&-(0x1f+1)) == 0 && ((1<<uint((_la-33)))&((1<<(Java9ParserNEW-33))|(1<<(Java9ParserOPEN-33))|(1<<(Java9ParserOPERNS-33))|(1<<(Java9ParserPROVIDES-33))|(1<<(Java9ParserREQUIRES-33))|(1<<(Java9ParserSHORT-33))|(1<<(Java9ParserSUPER-33))|(1<<(Java9ParserTHIS-33))|(1<<(Java9ParserTO-33))|(1<<(Java9ParserUSES-33))|(1<<(Java9ParserVOID-33))|(1<<(Java9ParserWITH-33))|(1<<(Java9ParserIntegerLiteral-33))|(1<<(Java9ParserFloatingPointLiteral-33))|(1<<(Java9ParserBooleanLiteral-33)))) != 0) || (((_la-65)&-(0x1f+1)) == 0 && ((1<<uint((_la-65)))&((1<<(Java9ParserCharacterLiteral-65))|(1<<(Java9ParserStringLiteral-65))|(1<<(Java9ParserNullLiteral-65))|(1<<(Java9ParserLPAREN-65))|(1<<(Java9ParserAT-65))|(1<<(Java9ParserBANG-65))|(1<<(Java9ParserTILDE-65))|(1<<(Java9ParserINC-65))|(1<<(Java9ParserDEC-65))|(1<<(Java9ParserADD-65)))) != 0) || _la == Java9ParserSUB || _la == Java9ParserIdentifier {
		{
			p.SetState(2255)
			p.ArgumentList()
		}

	}
	{
		p.SetState(2258)
		p.Match(Java9ParserRPAREN)
	}
	p.SetState(2260)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 242, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(2259)
			p.ClassBody()
		}

	}

	return localctx
}

// IClassInstanceCreationExpression_lfno_primaryContext is an interface to support dynamic dispatch.
type IClassInstanceCreationExpression_lfno_primaryContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsClassInstanceCreationExpression_lfno_primaryContext differentiates from other interfaces.
	IsClassInstanceCreationExpression_lfno_primaryContext()
}

type ClassInstanceCreationExpression_lfno_primaryContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyClassInstanceCreationExpression_lfno_primaryContext() *ClassInstanceCreationExpression_lfno_primaryContext {
	var p = new(ClassInstanceCreationExpression_lfno_primaryContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Java9ParserRULE_classInstanceCreationExpression_lfno_primary
	return p
}

func (*ClassInstanceCreationExpression_lfno_primaryContext) IsClassInstanceCreationExpression_lfno_primaryContext() {
}

func NewClassInstanceCreationExpression_lfno_primaryContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ClassInstanceCreationExpression_lfno_primaryContext {
	var p = new(ClassInstanceCreationExpression_lfno_primaryContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java9ParserRULE_classInstanceCreationExpression_lfno_primary

	return p
}

func (s *ClassInstanceCreationExpression_lfno_primaryContext) GetParser() antlr.Parser {
	return s.parser
}

func (s *ClassInstanceCreationExpression_lfno_primaryContext) NEW() antlr.TerminalNode {
	return s.GetToken(Java9ParserNEW, 0)
}

func (s *ClassInstanceCreationExpression_lfno_primaryContext) AllIdentifier() []IIdentifierContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IIdentifierContext)(nil)).Elem())
	var tst = make([]IIdentifierContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IIdentifierContext)
		}
	}

	return tst
}

func (s *ClassInstanceCreationExpression_lfno_primaryContext) Identifier(i int) IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ClassInstanceCreationExpression_lfno_primaryContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(Java9ParserLPAREN, 0)
}

func (s *ClassInstanceCreationExpression_lfno_primaryContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(Java9ParserRPAREN, 0)
}

func (s *ClassInstanceCreationExpression_lfno_primaryContext) TypeArguments() ITypeArgumentsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypeArgumentsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITypeArgumentsContext)
}

func (s *ClassInstanceCreationExpression_lfno_primaryContext) AllAnnotation() []IAnnotationContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAnnotationContext)(nil)).Elem())
	var tst = make([]IAnnotationContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAnnotationContext)
		}
	}

	return tst
}

func (s *ClassInstanceCreationExpression_lfno_primaryContext) Annotation(i int) IAnnotationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAnnotationContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAnnotationContext)
}

func (s *ClassInstanceCreationExpression_lfno_primaryContext) AllDOT() []antlr.TerminalNode {
	return s.GetTokens(Java9ParserDOT)
}

func (s *ClassInstanceCreationExpression_lfno_primaryContext) DOT(i int) antlr.TerminalNode {
	return s.GetToken(Java9ParserDOT, i)
}

func (s *ClassInstanceCreationExpression_lfno_primaryContext) TypeArgumentsOrDiamond() ITypeArgumentsOrDiamondContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypeArgumentsOrDiamondContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITypeArgumentsOrDiamondContext)
}

func (s *ClassInstanceCreationExpression_lfno_primaryContext) ArgumentList() IArgumentListContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IArgumentListContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IArgumentListContext)
}

func (s *ClassInstanceCreationExpression_lfno_primaryContext) ClassBody() IClassBodyContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IClassBodyContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IClassBodyContext)
}

func (s *ClassInstanceCreationExpression_lfno_primaryContext) ExpressionName() IExpressionNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionNameContext)
}

func (s *ClassInstanceCreationExpression_lfno_primaryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ClassInstanceCreationExpression_lfno_primaryContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ClassInstanceCreationExpression_lfno_primaryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.EnterClassInstanceCreationExpression_lfno_primary(s)
	}
}

func (s *ClassInstanceCreationExpression_lfno_primaryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.ExitClassInstanceCreationExpression_lfno_primary(s)
	}
}

func (p *Java9Parser) ClassInstanceCreationExpression_lfno_primary() (localctx IClassInstanceCreationExpression_lfno_primaryContext) {
	localctx = NewClassInstanceCreationExpression_lfno_primaryContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 390, Java9ParserRULE_classInstanceCreationExpression_lfno_primary)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(2321)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case Java9ParserNEW:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2262)
			p.Match(Java9ParserNEW)
		}
		p.SetState(2264)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == Java9ParserLT {
			{
				p.SetState(2263)
				p.TypeArguments()
			}

		}
		p.SetState(2269)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == Java9ParserAT {
			{
				p.SetState(2266)
				p.Annotation()
			}

			p.SetState(2271)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(2272)
			p.Identifier()
		}
		p.SetState(2283)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == Java9ParserDOT {
			{
				p.SetState(2273)
				p.Match(Java9ParserDOT)
			}
			p.SetState(2277)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			for _la == Java9ParserAT {
				{
					p.SetState(2274)
					p.Annotation()
				}

				p.SetState(2279)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)
			}
			{
				p.SetState(2280)
				p.Identifier()
			}

			p.SetState(2285)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		p.SetState(2287)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == Java9ParserLT {
			{
				p.SetState(2286)
				p.TypeArgumentsOrDiamond()
			}

		}
		{
			p.SetState(2289)
			p.Match(Java9ParserLPAREN)
		}
		p.SetState(2291)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<Java9ParserBOOLEAN)|(1<<Java9ParserBYTE)|(1<<Java9ParserCHAR)|(1<<Java9ParserDOUBLE)|(1<<Java9ParserEXPORTS)|(1<<Java9ParserFLOAT)|(1<<Java9ParserINT)|(1<<Java9ParserLONG)|(1<<Java9ParserMODULE))) != 0) || (((_la-33)&-(0x1f+1)) == 0 && ((1<<uint((_la-33)))&((1<<(Java9ParserNEW-33))|(1<<(Java9ParserOPEN-33))|(1<<(Java9ParserOPERNS-33))|(1<<(Java9ParserPROVIDES-33))|(1<<(Java9ParserREQUIRES-33))|(1<<(Java9ParserSHORT-33))|(1<<(Java9ParserSUPER-33))|(1<<(Java9ParserTHIS-33))|(1<<(Java9ParserTO-33))|(1<<(Java9ParserUSES-33))|(1<<(Java9ParserVOID-33))|(1<<(Java9ParserWITH-33))|(1<<(Java9ParserIntegerLiteral-33))|(1<<(Java9ParserFloatingPointLiteral-33))|(1<<(Java9ParserBooleanLiteral-33)))) != 0) || (((_la-65)&-(0x1f+1)) == 0 && ((1<<uint((_la-65)))&((1<<(Java9ParserCharacterLiteral-65))|(1<<(Java9ParserStringLiteral-65))|(1<<(Java9ParserNullLiteral-65))|(1<<(Java9ParserLPAREN-65))|(1<<(Java9ParserAT-65))|(1<<(Java9ParserBANG-65))|(1<<(Java9ParserTILDE-65))|(1<<(Java9ParserINC-65))|(1<<(Java9ParserDEC-65))|(1<<(Java9ParserADD-65)))) != 0) || _la == Java9ParserSUB || _la == Java9ParserIdentifier {
			{
				p.SetState(2290)
				p.ArgumentList()
			}

		}
		{
			p.SetState(2293)
			p.Match(Java9ParserRPAREN)
		}
		p.SetState(2295)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 249, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(2294)
				p.ClassBody()
			}

		}

	case Java9ParserEXPORTS, Java9ParserMODULE, Java9ParserOPEN, Java9ParserOPERNS, Java9ParserPROVIDES, Java9ParserREQUIRES, Java9ParserTO, Java9ParserUSES, Java9ParserWITH, Java9ParserIdentifier:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2297)
			p.ExpressionName()
		}
		{
			p.SetState(2298)
			p.Match(Java9ParserDOT)
		}
		{
			p.SetState(2299)
			p.Match(Java9ParserNEW)
		}
		p.SetState(2301)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == Java9ParserLT {
			{
				p.SetState(2300)
				p.TypeArguments()
			}

		}
		p.SetState(2306)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == Java9ParserAT {
			{
				p.SetState(2303)
				p.Annotation()
			}

			p.SetState(2308)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(2309)
			p.Identifier()
		}
		p.SetState(2311)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == Java9ParserLT {
			{
				p.SetState(2310)
				p.TypeArgumentsOrDiamond()
			}

		}
		{
			p.SetState(2313)
			p.Match(Java9ParserLPAREN)
		}
		p.SetState(2315)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<Java9ParserBOOLEAN)|(1<<Java9ParserBYTE)|(1<<Java9ParserCHAR)|(1<<Java9ParserDOUBLE)|(1<<Java9ParserEXPORTS)|(1<<Java9ParserFLOAT)|(1<<Java9ParserINT)|(1<<Java9ParserLONG)|(1<<Java9ParserMODULE))) != 0) || (((_la-33)&-(0x1f+1)) == 0 && ((1<<uint((_la-33)))&((1<<(Java9ParserNEW-33))|(1<<(Java9ParserOPEN-33))|(1<<(Java9ParserOPERNS-33))|(1<<(Java9ParserPROVIDES-33))|(1<<(Java9ParserREQUIRES-33))|(1<<(Java9ParserSHORT-33))|(1<<(Java9ParserSUPER-33))|(1<<(Java9ParserTHIS-33))|(1<<(Java9ParserTO-33))|(1<<(Java9ParserUSES-33))|(1<<(Java9ParserVOID-33))|(1<<(Java9ParserWITH-33))|(1<<(Java9ParserIntegerLiteral-33))|(1<<(Java9ParserFloatingPointLiteral-33))|(1<<(Java9ParserBooleanLiteral-33)))) != 0) || (((_la-65)&-(0x1f+1)) == 0 && ((1<<uint((_la-65)))&((1<<(Java9ParserCharacterLiteral-65))|(1<<(Java9ParserStringLiteral-65))|(1<<(Java9ParserNullLiteral-65))|(1<<(Java9ParserLPAREN-65))|(1<<(Java9ParserAT-65))|(1<<(Java9ParserBANG-65))|(1<<(Java9ParserTILDE-65))|(1<<(Java9ParserINC-65))|(1<<(Java9ParserDEC-65))|(1<<(Java9ParserADD-65)))) != 0) || _la == Java9ParserSUB || _la == Java9ParserIdentifier {
			{
				p.SetState(2314)
				p.ArgumentList()
			}

		}
		{
			p.SetState(2317)
			p.Match(Java9ParserRPAREN)
		}
		p.SetState(2319)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 254, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(2318)
				p.ClassBody()
			}

		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ITypeArgumentsOrDiamondContext is an interface to support dynamic dispatch.
type ITypeArgumentsOrDiamondContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTypeArgumentsOrDiamondContext differentiates from other interfaces.
	IsTypeArgumentsOrDiamondContext()
}

type TypeArgumentsOrDiamondContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeArgumentsOrDiamondContext() *TypeArgumentsOrDiamondContext {
	var p = new(TypeArgumentsOrDiamondContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Java9ParserRULE_typeArgumentsOrDiamond
	return p
}

func (*TypeArgumentsOrDiamondContext) IsTypeArgumentsOrDiamondContext() {}

func NewTypeArgumentsOrDiamondContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeArgumentsOrDiamondContext {
	var p = new(TypeArgumentsOrDiamondContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java9ParserRULE_typeArgumentsOrDiamond

	return p
}

func (s *TypeArgumentsOrDiamondContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeArgumentsOrDiamondContext) TypeArguments() ITypeArgumentsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypeArgumentsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITypeArgumentsContext)
}

func (s *TypeArgumentsOrDiamondContext) LT() antlr.TerminalNode {
	return s.GetToken(Java9ParserLT, 0)
}

func (s *TypeArgumentsOrDiamondContext) GT() antlr.TerminalNode {
	return s.GetToken(Java9ParserGT, 0)
}

func (s *TypeArgumentsOrDiamondContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeArgumentsOrDiamondContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeArgumentsOrDiamondContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.EnterTypeArgumentsOrDiamond(s)
	}
}

func (s *TypeArgumentsOrDiamondContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.ExitTypeArgumentsOrDiamond(s)
	}
}

func (p *Java9Parser) TypeArgumentsOrDiamond() (localctx ITypeArgumentsOrDiamondContext) {
	localctx = NewTypeArgumentsOrDiamondContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 392, Java9ParserRULE_typeArgumentsOrDiamond)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(2326)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 256, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2323)
			p.TypeArguments()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2324)
			p.Match(Java9ParserLT)
		}
		{
			p.SetState(2325)
			p.Match(Java9ParserGT)
		}

	}

	return localctx
}

// IFieldAccessContext is an interface to support dynamic dispatch.
type IFieldAccessContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFieldAccessContext differentiates from other interfaces.
	IsFieldAccessContext()
}

type FieldAccessContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFieldAccessContext() *FieldAccessContext {
	var p = new(FieldAccessContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Java9ParserRULE_fieldAccess
	return p
}

func (*FieldAccessContext) IsFieldAccessContext() {}

func NewFieldAccessContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FieldAccessContext {
	var p = new(FieldAccessContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java9ParserRULE_fieldAccess

	return p
}

func (s *FieldAccessContext) GetParser() antlr.Parser { return s.parser }

func (s *FieldAccessContext) Primary() IPrimaryContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPrimaryContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPrimaryContext)
}

func (s *FieldAccessContext) AllDOT() []antlr.TerminalNode {
	return s.GetTokens(Java9ParserDOT)
}

func (s *FieldAccessContext) DOT(i int) antlr.TerminalNode {
	return s.GetToken(Java9ParserDOT, i)
}

func (s *FieldAccessContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *FieldAccessContext) SUPER() antlr.TerminalNode {
	return s.GetToken(Java9ParserSUPER, 0)
}

func (s *FieldAccessContext) TypeName() ITypeNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypeNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITypeNameContext)
}

func (s *FieldAccessContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FieldAccessContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FieldAccessContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.EnterFieldAccess(s)
	}
}

func (s *FieldAccessContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.ExitFieldAccess(s)
	}
}

func (p *Java9Parser) FieldAccess() (localctx IFieldAccessContext) {
	localctx = NewFieldAccessContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 394, Java9ParserRULE_fieldAccess)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(2341)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 257, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2328)
			p.Primary()
		}
		{
			p.SetState(2329)
			p.Match(Java9ParserDOT)
		}
		{
			p.SetState(2330)
			p.Identifier()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2332)
			p.Match(Java9ParserSUPER)
		}
		{
			p.SetState(2333)
			p.Match(Java9ParserDOT)
		}
		{
			p.SetState(2334)
			p.Identifier()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2335)
			p.TypeName()
		}
		{
			p.SetState(2336)
			p.Match(Java9ParserDOT)
		}
		{
			p.SetState(2337)
			p.Match(Java9ParserSUPER)
		}
		{
			p.SetState(2338)
			p.Match(Java9ParserDOT)
		}
		{
			p.SetState(2339)
			p.Identifier()
		}

	}

	return localctx
}

// IFieldAccess_lf_primaryContext is an interface to support dynamic dispatch.
type IFieldAccess_lf_primaryContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFieldAccess_lf_primaryContext differentiates from other interfaces.
	IsFieldAccess_lf_primaryContext()
}

type FieldAccess_lf_primaryContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFieldAccess_lf_primaryContext() *FieldAccess_lf_primaryContext {
	var p = new(FieldAccess_lf_primaryContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Java9ParserRULE_fieldAccess_lf_primary
	return p
}

func (*FieldAccess_lf_primaryContext) IsFieldAccess_lf_primaryContext() {}

func NewFieldAccess_lf_primaryContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FieldAccess_lf_primaryContext {
	var p = new(FieldAccess_lf_primaryContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java9ParserRULE_fieldAccess_lf_primary

	return p
}

func (s *FieldAccess_lf_primaryContext) GetParser() antlr.Parser { return s.parser }

func (s *FieldAccess_lf_primaryContext) DOT() antlr.TerminalNode {
	return s.GetToken(Java9ParserDOT, 0)
}

func (s *FieldAccess_lf_primaryContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *FieldAccess_lf_primaryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FieldAccess_lf_primaryContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FieldAccess_lf_primaryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.EnterFieldAccess_lf_primary(s)
	}
}

func (s *FieldAccess_lf_primaryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.ExitFieldAccess_lf_primary(s)
	}
}

func (p *Java9Parser) FieldAccess_lf_primary() (localctx IFieldAccess_lf_primaryContext) {
	localctx = NewFieldAccess_lf_primaryContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 396, Java9ParserRULE_fieldAccess_lf_primary)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2343)
		p.Match(Java9ParserDOT)
	}
	{
		p.SetState(2344)
		p.Identifier()
	}

	return localctx
}

// IFieldAccess_lfno_primaryContext is an interface to support dynamic dispatch.
type IFieldAccess_lfno_primaryContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFieldAccess_lfno_primaryContext differentiates from other interfaces.
	IsFieldAccess_lfno_primaryContext()
}

type FieldAccess_lfno_primaryContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFieldAccess_lfno_primaryContext() *FieldAccess_lfno_primaryContext {
	var p = new(FieldAccess_lfno_primaryContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Java9ParserRULE_fieldAccess_lfno_primary
	return p
}

func (*FieldAccess_lfno_primaryContext) IsFieldAccess_lfno_primaryContext() {}

func NewFieldAccess_lfno_primaryContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FieldAccess_lfno_primaryContext {
	var p = new(FieldAccess_lfno_primaryContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java9ParserRULE_fieldAccess_lfno_primary

	return p
}

func (s *FieldAccess_lfno_primaryContext) GetParser() antlr.Parser { return s.parser }

func (s *FieldAccess_lfno_primaryContext) SUPER() antlr.TerminalNode {
	return s.GetToken(Java9ParserSUPER, 0)
}

func (s *FieldAccess_lfno_primaryContext) AllDOT() []antlr.TerminalNode {
	return s.GetTokens(Java9ParserDOT)
}

func (s *FieldAccess_lfno_primaryContext) DOT(i int) antlr.TerminalNode {
	return s.GetToken(Java9ParserDOT, i)
}

func (s *FieldAccess_lfno_primaryContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *FieldAccess_lfno_primaryContext) TypeName() ITypeNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypeNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITypeNameContext)
}

func (s *FieldAccess_lfno_primaryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FieldAccess_lfno_primaryContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FieldAccess_lfno_primaryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.EnterFieldAccess_lfno_primary(s)
	}
}

func (s *FieldAccess_lfno_primaryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.ExitFieldAccess_lfno_primary(s)
	}
}

func (p *Java9Parser) FieldAccess_lfno_primary() (localctx IFieldAccess_lfno_primaryContext) {
	localctx = NewFieldAccess_lfno_primaryContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 398, Java9ParserRULE_fieldAccess_lfno_primary)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(2355)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case Java9ParserSUPER:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2346)
			p.Match(Java9ParserSUPER)
		}
		{
			p.SetState(2347)
			p.Match(Java9ParserDOT)
		}
		{
			p.SetState(2348)
			p.Identifier()
		}

	case Java9ParserEXPORTS, Java9ParserMODULE, Java9ParserOPEN, Java9ParserOPERNS, Java9ParserPROVIDES, Java9ParserREQUIRES, Java9ParserTO, Java9ParserUSES, Java9ParserWITH, Java9ParserIdentifier:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2349)
			p.TypeName()
		}
		{
			p.SetState(2350)
			p.Match(Java9ParserDOT)
		}
		{
			p.SetState(2351)
			p.Match(Java9ParserSUPER)
		}
		{
			p.SetState(2352)
			p.Match(Java9ParserDOT)
		}
		{
			p.SetState(2353)
			p.Identifier()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IArrayAccessContext is an interface to support dynamic dispatch.
type IArrayAccessContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsArrayAccessContext differentiates from other interfaces.
	IsArrayAccessContext()
}

type ArrayAccessContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyArrayAccessContext() *ArrayAccessContext {
	var p = new(ArrayAccessContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Java9ParserRULE_arrayAccess
	return p
}

func (*ArrayAccessContext) IsArrayAccessContext() {}

func NewArrayAccessContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ArrayAccessContext {
	var p = new(ArrayAccessContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java9ParserRULE_arrayAccess

	return p
}

func (s *ArrayAccessContext) GetParser() antlr.Parser { return s.parser }

func (s *ArrayAccessContext) ExpressionName() IExpressionNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionNameContext)
}

func (s *ArrayAccessContext) AllLBRACK() []antlr.TerminalNode {
	return s.GetTokens(Java9ParserLBRACK)
}

func (s *ArrayAccessContext) LBRACK(i int) antlr.TerminalNode {
	return s.GetToken(Java9ParserLBRACK, i)
}

func (s *ArrayAccessContext) AllExpression() []IExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExpressionContext)(nil)).Elem())
	var tst = make([]IExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExpressionContext)
		}
	}

	return tst
}

func (s *ArrayAccessContext) Expression(i int) IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ArrayAccessContext) AllRBRACK() []antlr.TerminalNode {
	return s.GetTokens(Java9ParserRBRACK)
}

func (s *ArrayAccessContext) RBRACK(i int) antlr.TerminalNode {
	return s.GetToken(Java9ParserRBRACK, i)
}

func (s *ArrayAccessContext) PrimaryNoNewArray_lfno_arrayAccess() IPrimaryNoNewArray_lfno_arrayAccessContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPrimaryNoNewArray_lfno_arrayAccessContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPrimaryNoNewArray_lfno_arrayAccessContext)
}

func (s *ArrayAccessContext) AllPrimaryNoNewArray_lf_arrayAccess() []IPrimaryNoNewArray_lf_arrayAccessContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IPrimaryNoNewArray_lf_arrayAccessContext)(nil)).Elem())
	var tst = make([]IPrimaryNoNewArray_lf_arrayAccessContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IPrimaryNoNewArray_lf_arrayAccessContext)
		}
	}

	return tst
}

func (s *ArrayAccessContext) PrimaryNoNewArray_lf_arrayAccess(i int) IPrimaryNoNewArray_lf_arrayAccessContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPrimaryNoNewArray_lf_arrayAccessContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IPrimaryNoNewArray_lf_arrayAccessContext)
}

func (s *ArrayAccessContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArrayAccessContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ArrayAccessContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.EnterArrayAccess(s)
	}
}

func (s *ArrayAccessContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.ExitArrayAccess(s)
	}
}

func (p *Java9Parser) ArrayAccess() (localctx IArrayAccessContext) {
	localctx = NewArrayAccessContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 400, Java9ParserRULE_arrayAccess)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(2367)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 259, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(2357)
			p.ExpressionName()
		}
		{
			p.SetState(2358)
			p.Match(Java9ParserLBRACK)
		}
		{
			p.SetState(2359)
			p.Expression()
		}
		{
			p.SetState(2360)
			p.Match(Java9ParserRBRACK)
		}

	case 2:
		{
			p.SetState(2362)
			p.PrimaryNoNewArray_lfno_arrayAccess()
		}
		{
			p.SetState(2363)
			p.Match(Java9ParserLBRACK)
		}
		{
			p.SetState(2364)
			p.Expression()
		}
		{
			p.SetState(2365)
			p.Match(Java9ParserRBRACK)
		}

	}
	p.SetState(2376)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == Java9ParserLBRACK {
		{
			p.SetState(2369)
			p.PrimaryNoNewArray_lf_arrayAccess()
		}
		{
			p.SetState(2370)
			p.Match(Java9ParserLBRACK)
		}
		{
			p.SetState(2371)
			p.Expression()
		}
		{
			p.SetState(2372)
			p.Match(Java9ParserRBRACK)
		}

		p.SetState(2378)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IArrayAccess_lf_primaryContext is an interface to support dynamic dispatch.
type IArrayAccess_lf_primaryContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsArrayAccess_lf_primaryContext differentiates from other interfaces.
	IsArrayAccess_lf_primaryContext()
}

type ArrayAccess_lf_primaryContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyArrayAccess_lf_primaryContext() *ArrayAccess_lf_primaryContext {
	var p = new(ArrayAccess_lf_primaryContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Java9ParserRULE_arrayAccess_lf_primary
	return p
}

func (*ArrayAccess_lf_primaryContext) IsArrayAccess_lf_primaryContext() {}

func NewArrayAccess_lf_primaryContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ArrayAccess_lf_primaryContext {
	var p = new(ArrayAccess_lf_primaryContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java9ParserRULE_arrayAccess_lf_primary

	return p
}

func (s *ArrayAccess_lf_primaryContext) GetParser() antlr.Parser { return s.parser }

func (s *ArrayAccess_lf_primaryContext) PrimaryNoNewArray_lf_primary_lfno_arrayAccess_lf_primary() IPrimaryNoNewArray_lf_primary_lfno_arrayAccess_lf_primaryContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPrimaryNoNewArray_lf_primary_lfno_arrayAccess_lf_primaryContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPrimaryNoNewArray_lf_primary_lfno_arrayAccess_lf_primaryContext)
}

func (s *ArrayAccess_lf_primaryContext) AllLBRACK() []antlr.TerminalNode {
	return s.GetTokens(Java9ParserLBRACK)
}

func (s *ArrayAccess_lf_primaryContext) LBRACK(i int) antlr.TerminalNode {
	return s.GetToken(Java9ParserLBRACK, i)
}

func (s *ArrayAccess_lf_primaryContext) AllExpression() []IExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExpressionContext)(nil)).Elem())
	var tst = make([]IExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExpressionContext)
		}
	}

	return tst
}

func (s *ArrayAccess_lf_primaryContext) Expression(i int) IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ArrayAccess_lf_primaryContext) AllRBRACK() []antlr.TerminalNode {
	return s.GetTokens(Java9ParserRBRACK)
}

func (s *ArrayAccess_lf_primaryContext) RBRACK(i int) antlr.TerminalNode {
	return s.GetToken(Java9ParserRBRACK, i)
}

func (s *ArrayAccess_lf_primaryContext) AllPrimaryNoNewArray_lf_primary_lf_arrayAccess_lf_primary() []IPrimaryNoNewArray_lf_primary_lf_arrayAccess_lf_primaryContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IPrimaryNoNewArray_lf_primary_lf_arrayAccess_lf_primaryContext)(nil)).Elem())
	var tst = make([]IPrimaryNoNewArray_lf_primary_lf_arrayAccess_lf_primaryContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IPrimaryNoNewArray_lf_primary_lf_arrayAccess_lf_primaryContext)
		}
	}

	return tst
}

func (s *ArrayAccess_lf_primaryContext) PrimaryNoNewArray_lf_primary_lf_arrayAccess_lf_primary(i int) IPrimaryNoNewArray_lf_primary_lf_arrayAccess_lf_primaryContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPrimaryNoNewArray_lf_primary_lf_arrayAccess_lf_primaryContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IPrimaryNoNewArray_lf_primary_lf_arrayAccess_lf_primaryContext)
}

func (s *ArrayAccess_lf_primaryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArrayAccess_lf_primaryContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ArrayAccess_lf_primaryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.EnterArrayAccess_lf_primary(s)
	}
}

func (s *ArrayAccess_lf_primaryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.ExitArrayAccess_lf_primary(s)
	}
}

func (p *Java9Parser) ArrayAccess_lf_primary() (localctx IArrayAccess_lf_primaryContext) {
	localctx = NewArrayAccess_lf_primaryContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 402, Java9ParserRULE_arrayAccess_lf_primary)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2379)
		p.PrimaryNoNewArray_lf_primary_lfno_arrayAccess_lf_primary()
	}
	{
		p.SetState(2380)
		p.Match(Java9ParserLBRACK)
	}
	{
		p.SetState(2381)
		p.Expression()
	}
	{
		p.SetState(2382)
		p.Match(Java9ParserRBRACK)
	}

	p.SetState(2391)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 261, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(2384)
				p.PrimaryNoNewArray_lf_primary_lf_arrayAccess_lf_primary()
			}
			{
				p.SetState(2385)
				p.Match(Java9ParserLBRACK)
			}
			{
				p.SetState(2386)
				p.Expression()
			}
			{
				p.SetState(2387)
				p.Match(Java9ParserRBRACK)
			}

		}
		p.SetState(2393)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 261, p.GetParserRuleContext())
	}

	return localctx
}

// IArrayAccess_lfno_primaryContext is an interface to support dynamic dispatch.
type IArrayAccess_lfno_primaryContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsArrayAccess_lfno_primaryContext differentiates from other interfaces.
	IsArrayAccess_lfno_primaryContext()
}

type ArrayAccess_lfno_primaryContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyArrayAccess_lfno_primaryContext() *ArrayAccess_lfno_primaryContext {
	var p = new(ArrayAccess_lfno_primaryContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Java9ParserRULE_arrayAccess_lfno_primary
	return p
}

func (*ArrayAccess_lfno_primaryContext) IsArrayAccess_lfno_primaryContext() {}

func NewArrayAccess_lfno_primaryContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ArrayAccess_lfno_primaryContext {
	var p = new(ArrayAccess_lfno_primaryContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java9ParserRULE_arrayAccess_lfno_primary

	return p
}

func (s *ArrayAccess_lfno_primaryContext) GetParser() antlr.Parser { return s.parser }

func (s *ArrayAccess_lfno_primaryContext) ExpressionName() IExpressionNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionNameContext)
}

func (s *ArrayAccess_lfno_primaryContext) AllLBRACK() []antlr.TerminalNode {
	return s.GetTokens(Java9ParserLBRACK)
}

func (s *ArrayAccess_lfno_primaryContext) LBRACK(i int) antlr.TerminalNode {
	return s.GetToken(Java9ParserLBRACK, i)
}

func (s *ArrayAccess_lfno_primaryContext) AllExpression() []IExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExpressionContext)(nil)).Elem())
	var tst = make([]IExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExpressionContext)
		}
	}

	return tst
}

func (s *ArrayAccess_lfno_primaryContext) Expression(i int) IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ArrayAccess_lfno_primaryContext) AllRBRACK() []antlr.TerminalNode {
	return s.GetTokens(Java9ParserRBRACK)
}

func (s *ArrayAccess_lfno_primaryContext) RBRACK(i int) antlr.TerminalNode {
	return s.GetToken(Java9ParserRBRACK, i)
}

func (s *ArrayAccess_lfno_primaryContext) PrimaryNoNewArray_lfno_primary_lfno_arrayAccess_lfno_primary() IPrimaryNoNewArray_lfno_primary_lfno_arrayAccess_lfno_primaryContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPrimaryNoNewArray_lfno_primary_lfno_arrayAccess_lfno_primaryContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPrimaryNoNewArray_lfno_primary_lfno_arrayAccess_lfno_primaryContext)
}

func (s *ArrayAccess_lfno_primaryContext) AllPrimaryNoNewArray_lfno_primary_lf_arrayAccess_lfno_primary() []IPrimaryNoNewArray_lfno_primary_lf_arrayAccess_lfno_primaryContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IPrimaryNoNewArray_lfno_primary_lf_arrayAccess_lfno_primaryContext)(nil)).Elem())
	var tst = make([]IPrimaryNoNewArray_lfno_primary_lf_arrayAccess_lfno_primaryContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IPrimaryNoNewArray_lfno_primary_lf_arrayAccess_lfno_primaryContext)
		}
	}

	return tst
}

func (s *ArrayAccess_lfno_primaryContext) PrimaryNoNewArray_lfno_primary_lf_arrayAccess_lfno_primary(i int) IPrimaryNoNewArray_lfno_primary_lf_arrayAccess_lfno_primaryContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPrimaryNoNewArray_lfno_primary_lf_arrayAccess_lfno_primaryContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IPrimaryNoNewArray_lfno_primary_lf_arrayAccess_lfno_primaryContext)
}

func (s *ArrayAccess_lfno_primaryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArrayAccess_lfno_primaryContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ArrayAccess_lfno_primaryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.EnterArrayAccess_lfno_primary(s)
	}
}

func (s *ArrayAccess_lfno_primaryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.ExitArrayAccess_lfno_primary(s)
	}
}

func (p *Java9Parser) ArrayAccess_lfno_primary() (localctx IArrayAccess_lfno_primaryContext) {
	localctx = NewArrayAccess_lfno_primaryContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 404, Java9ParserRULE_arrayAccess_lfno_primary)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(2404)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 262, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(2394)
			p.ExpressionName()
		}
		{
			p.SetState(2395)
			p.Match(Java9ParserLBRACK)
		}
		{
			p.SetState(2396)
			p.Expression()
		}
		{
			p.SetState(2397)
			p.Match(Java9ParserRBRACK)
		}

	case 2:
		{
			p.SetState(2399)
			p.PrimaryNoNewArray_lfno_primary_lfno_arrayAccess_lfno_primary()
		}
		{
			p.SetState(2400)
			p.Match(Java9ParserLBRACK)
		}
		{
			p.SetState(2401)
			p.Expression()
		}
		{
			p.SetState(2402)
			p.Match(Java9ParserRBRACK)
		}

	}
	p.SetState(2413)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 263, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(2406)
				p.PrimaryNoNewArray_lfno_primary_lf_arrayAccess_lfno_primary()
			}
			{
				p.SetState(2407)
				p.Match(Java9ParserLBRACK)
			}
			{
				p.SetState(2408)
				p.Expression()
			}
			{
				p.SetState(2409)
				p.Match(Java9ParserRBRACK)
			}

		}
		p.SetState(2415)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 263, p.GetParserRuleContext())
	}

	return localctx
}

// IMethodInvocationContext is an interface to support dynamic dispatch.
type IMethodInvocationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMethodInvocationContext differentiates from other interfaces.
	IsMethodInvocationContext()
}

type MethodInvocationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMethodInvocationContext() *MethodInvocationContext {
	var p = new(MethodInvocationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Java9ParserRULE_methodInvocation
	return p
}

func (*MethodInvocationContext) IsMethodInvocationContext() {}

func NewMethodInvocationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MethodInvocationContext {
	var p = new(MethodInvocationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java9ParserRULE_methodInvocation

	return p
}

func (s *MethodInvocationContext) GetParser() antlr.Parser { return s.parser }

func (s *MethodInvocationContext) MethodName() IMethodNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMethodNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMethodNameContext)
}

func (s *MethodInvocationContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(Java9ParserLPAREN, 0)
}

func (s *MethodInvocationContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(Java9ParserRPAREN, 0)
}

func (s *MethodInvocationContext) ArgumentList() IArgumentListContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IArgumentListContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IArgumentListContext)
}

func (s *MethodInvocationContext) TypeName() ITypeNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypeNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITypeNameContext)
}

func (s *MethodInvocationContext) AllDOT() []antlr.TerminalNode {
	return s.GetTokens(Java9ParserDOT)
}

func (s *MethodInvocationContext) DOT(i int) antlr.TerminalNode {
	return s.GetToken(Java9ParserDOT, i)
}

func (s *MethodInvocationContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *MethodInvocationContext) TypeArguments() ITypeArgumentsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypeArgumentsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITypeArgumentsContext)
}

func (s *MethodInvocationContext) ExpressionName() IExpressionNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionNameContext)
}

func (s *MethodInvocationContext) Primary() IPrimaryContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPrimaryContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPrimaryContext)
}

func (s *MethodInvocationContext) SUPER() antlr.TerminalNode {
	return s.GetToken(Java9ParserSUPER, 0)
}

func (s *MethodInvocationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MethodInvocationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MethodInvocationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.EnterMethodInvocation(s)
	}
}

func (s *MethodInvocationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.ExitMethodInvocation(s)
	}
}

func (p *Java9Parser) MethodInvocation() (localctx IMethodInvocationContext) {
	localctx = NewMethodInvocationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 406, Java9ParserRULE_methodInvocation)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(2485)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 275, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2416)
			p.MethodName()
		}
		{
			p.SetState(2417)
			p.Match(Java9ParserLPAREN)
		}
		p.SetState(2419)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<Java9ParserBOOLEAN)|(1<<Java9ParserBYTE)|(1<<Java9ParserCHAR)|(1<<Java9ParserDOUBLE)|(1<<Java9ParserEXPORTS)|(1<<Java9ParserFLOAT)|(1<<Java9ParserINT)|(1<<Java9ParserLONG)|(1<<Java9ParserMODULE))) != 0) || (((_la-33)&-(0x1f+1)) == 0 && ((1<<uint((_la-33)))&((1<<(Java9ParserNEW-33))|(1<<(Java9ParserOPEN-33))|(1<<(Java9ParserOPERNS-33))|(1<<(Java9ParserPROVIDES-33))|(1<<(Java9ParserREQUIRES-33))|(1<<(Java9ParserSHORT-33))|(1<<(Java9ParserSUPER-33))|(1<<(Java9ParserTHIS-33))|(1<<(Java9ParserTO-33))|(1<<(Java9ParserUSES-33))|(1<<(Java9ParserVOID-33))|(1<<(Java9ParserWITH-33))|(1<<(Java9ParserIntegerLiteral-33))|(1<<(Java9ParserFloatingPointLiteral-33))|(1<<(Java9ParserBooleanLiteral-33)))) != 0) || (((_la-65)&-(0x1f+1)) == 0 && ((1<<uint((_la-65)))&((1<<(Java9ParserCharacterLiteral-65))|(1<<(Java9ParserStringLiteral-65))|(1<<(Java9ParserNullLiteral-65))|(1<<(Java9ParserLPAREN-65))|(1<<(Java9ParserAT-65))|(1<<(Java9ParserBANG-65))|(1<<(Java9ParserTILDE-65))|(1<<(Java9ParserINC-65))|(1<<(Java9ParserDEC-65))|(1<<(Java9ParserADD-65)))) != 0) || _la == Java9ParserSUB || _la == Java9ParserIdentifier {
			{
				p.SetState(2418)
				p.ArgumentList()
			}

		}
		{
			p.SetState(2421)
			p.Match(Java9ParserRPAREN)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2423)
			p.TypeName()
		}
		{
			p.SetState(2424)
			p.Match(Java9ParserDOT)
		}
		p.SetState(2426)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == Java9ParserLT {
			{
				p.SetState(2425)
				p.TypeArguments()
			}

		}
		{
			p.SetState(2428)
			p.Identifier()
		}
		{
			p.SetState(2429)
			p.Match(Java9ParserLPAREN)
		}
		p.SetState(2431)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<Java9ParserBOOLEAN)|(1<<Java9ParserBYTE)|(1<<Java9ParserCHAR)|(1<<Java9ParserDOUBLE)|(1<<Java9ParserEXPORTS)|(1<<Java9ParserFLOAT)|(1<<Java9ParserINT)|(1<<Java9ParserLONG)|(1<<Java9ParserMODULE))) != 0) || (((_la-33)&-(0x1f+1)) == 0 && ((1<<uint((_la-33)))&((1<<(Java9ParserNEW-33))|(1<<(Java9ParserOPEN-33))|(1<<(Java9ParserOPERNS-33))|(1<<(Java9ParserPROVIDES-33))|(1<<(Java9ParserREQUIRES-33))|(1<<(Java9ParserSHORT-33))|(1<<(Java9ParserSUPER-33))|(1<<(Java9ParserTHIS-33))|(1<<(Java9ParserTO-33))|(1<<(Java9ParserUSES-33))|(1<<(Java9ParserVOID-33))|(1<<(Java9ParserWITH-33))|(1<<(Java9ParserIntegerLiteral-33))|(1<<(Java9ParserFloatingPointLiteral-33))|(1<<(Java9ParserBooleanLiteral-33)))) != 0) || (((_la-65)&-(0x1f+1)) == 0 && ((1<<uint((_la-65)))&((1<<(Java9ParserCharacterLiteral-65))|(1<<(Java9ParserStringLiteral-65))|(1<<(Java9ParserNullLiteral-65))|(1<<(Java9ParserLPAREN-65))|(1<<(Java9ParserAT-65))|(1<<(Java9ParserBANG-65))|(1<<(Java9ParserTILDE-65))|(1<<(Java9ParserINC-65))|(1<<(Java9ParserDEC-65))|(1<<(Java9ParserADD-65)))) != 0) || _la == Java9ParserSUB || _la == Java9ParserIdentifier {
			{
				p.SetState(2430)
				p.ArgumentList()
			}

		}
		{
			p.SetState(2433)
			p.Match(Java9ParserRPAREN)
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2435)
			p.ExpressionName()
		}
		{
			p.SetState(2436)
			p.Match(Java9ParserDOT)
		}
		p.SetState(2438)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == Java9ParserLT {
			{
				p.SetState(2437)
				p.TypeArguments()
			}

		}
		{
			p.SetState(2440)
			p.Identifier()
		}
		{
			p.SetState(2441)
			p.Match(Java9ParserLPAREN)
		}
		p.SetState(2443)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<Java9ParserBOOLEAN)|(1<<Java9ParserBYTE)|(1<<Java9ParserCHAR)|(1<<Java9ParserDOUBLE)|(1<<Java9ParserEXPORTS)|(1<<Java9ParserFLOAT)|(1<<Java9ParserINT)|(1<<Java9ParserLONG)|(1<<Java9ParserMODULE))) != 0) || (((_la-33)&-(0x1f+1)) == 0 && ((1<<uint((_la-33)))&((1<<(Java9ParserNEW-33))|(1<<(Java9ParserOPEN-33))|(1<<(Java9ParserOPERNS-33))|(1<<(Java9ParserPROVIDES-33))|(1<<(Java9ParserREQUIRES-33))|(1<<(Java9ParserSHORT-33))|(1<<(Java9ParserSUPER-33))|(1<<(Java9ParserTHIS-33))|(1<<(Java9ParserTO-33))|(1<<(Java9ParserUSES-33))|(1<<(Java9ParserVOID-33))|(1<<(Java9ParserWITH-33))|(1<<(Java9ParserIntegerLiteral-33))|(1<<(Java9ParserFloatingPointLiteral-33))|(1<<(Java9ParserBooleanLiteral-33)))) != 0) || (((_la-65)&-(0x1f+1)) == 0 && ((1<<uint((_la-65)))&((1<<(Java9ParserCharacterLiteral-65))|(1<<(Java9ParserStringLiteral-65))|(1<<(Java9ParserNullLiteral-65))|(1<<(Java9ParserLPAREN-65))|(1<<(Java9ParserAT-65))|(1<<(Java9ParserBANG-65))|(1<<(Java9ParserTILDE-65))|(1<<(Java9ParserINC-65))|(1<<(Java9ParserDEC-65))|(1<<(Java9ParserADD-65)))) != 0) || _la == Java9ParserSUB || _la == Java9ParserIdentifier {
			{
				p.SetState(2442)
				p.ArgumentList()
			}

		}
		{
			p.SetState(2445)
			p.Match(Java9ParserRPAREN)
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(2447)
			p.Primary()
		}
		{
			p.SetState(2448)
			p.Match(Java9ParserDOT)
		}
		p.SetState(2450)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == Java9ParserLT {
			{
				p.SetState(2449)
				p.TypeArguments()
			}

		}
		{
			p.SetState(2452)
			p.Identifier()
		}
		{
			p.SetState(2453)
			p.Match(Java9ParserLPAREN)
		}
		p.SetState(2455)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<Java9ParserBOOLEAN)|(1<<Java9ParserBYTE)|(1<<Java9ParserCHAR)|(1<<Java9ParserDOUBLE)|(1<<Java9ParserEXPORTS)|(1<<Java9ParserFLOAT)|(1<<Java9ParserINT)|(1<<Java9ParserLONG)|(1<<Java9ParserMODULE))) != 0) || (((_la-33)&-(0x1f+1)) == 0 && ((1<<uint((_la-33)))&((1<<(Java9ParserNEW-33))|(1<<(Java9ParserOPEN-33))|(1<<(Java9ParserOPERNS-33))|(1<<(Java9ParserPROVIDES-33))|(1<<(Java9ParserREQUIRES-33))|(1<<(Java9ParserSHORT-33))|(1<<(Java9ParserSUPER-33))|(1<<(Java9ParserTHIS-33))|(1<<(Java9ParserTO-33))|(1<<(Java9ParserUSES-33))|(1<<(Java9ParserVOID-33))|(1<<(Java9ParserWITH-33))|(1<<(Java9ParserIntegerLiteral-33))|(1<<(Java9ParserFloatingPointLiteral-33))|(1<<(Java9ParserBooleanLiteral-33)))) != 0) || (((_la-65)&-(0x1f+1)) == 0 && ((1<<uint((_la-65)))&((1<<(Java9ParserCharacterLiteral-65))|(1<<(Java9ParserStringLiteral-65))|(1<<(Java9ParserNullLiteral-65))|(1<<(Java9ParserLPAREN-65))|(1<<(Java9ParserAT-65))|(1<<(Java9ParserBANG-65))|(1<<(Java9ParserTILDE-65))|(1<<(Java9ParserINC-65))|(1<<(Java9ParserDEC-65))|(1<<(Java9ParserADD-65)))) != 0) || _la == Java9ParserSUB || _la == Java9ParserIdentifier {
			{
				p.SetState(2454)
				p.ArgumentList()
			}

		}
		{
			p.SetState(2457)
			p.Match(Java9ParserRPAREN)
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(2459)
			p.Match(Java9ParserSUPER)
		}
		{
			p.SetState(2460)
			p.Match(Java9ParserDOT)
		}
		p.SetState(2462)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == Java9ParserLT {
			{
				p.SetState(2461)
				p.TypeArguments()
			}

		}
		{
			p.SetState(2464)
			p.Identifier()
		}
		{
			p.SetState(2465)
			p.Match(Java9ParserLPAREN)
		}
		p.SetState(2467)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<Java9ParserBOOLEAN)|(1<<Java9ParserBYTE)|(1<<Java9ParserCHAR)|(1<<Java9ParserDOUBLE)|(1<<Java9ParserEXPORTS)|(1<<Java9ParserFLOAT)|(1<<Java9ParserINT)|(1<<Java9ParserLONG)|(1<<Java9ParserMODULE))) != 0) || (((_la-33)&-(0x1f+1)) == 0 && ((1<<uint((_la-33)))&((1<<(Java9ParserNEW-33))|(1<<(Java9ParserOPEN-33))|(1<<(Java9ParserOPERNS-33))|(1<<(Java9ParserPROVIDES-33))|(1<<(Java9ParserREQUIRES-33))|(1<<(Java9ParserSHORT-33))|(1<<(Java9ParserSUPER-33))|(1<<(Java9ParserTHIS-33))|(1<<(Java9ParserTO-33))|(1<<(Java9ParserUSES-33))|(1<<(Java9ParserVOID-33))|(1<<(Java9ParserWITH-33))|(1<<(Java9ParserIntegerLiteral-33))|(1<<(Java9ParserFloatingPointLiteral-33))|(1<<(Java9ParserBooleanLiteral-33)))) != 0) || (((_la-65)&-(0x1f+1)) == 0 && ((1<<uint((_la-65)))&((1<<(Java9ParserCharacterLiteral-65))|(1<<(Java9ParserStringLiteral-65))|(1<<(Java9ParserNullLiteral-65))|(1<<(Java9ParserLPAREN-65))|(1<<(Java9ParserAT-65))|(1<<(Java9ParserBANG-65))|(1<<(Java9ParserTILDE-65))|(1<<(Java9ParserINC-65))|(1<<(Java9ParserDEC-65))|(1<<(Java9ParserADD-65)))) != 0) || _la == Java9ParserSUB || _la == Java9ParserIdentifier {
			{
				p.SetState(2466)
				p.ArgumentList()
			}

		}
		{
			p.SetState(2469)
			p.Match(Java9ParserRPAREN)
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(2471)
			p.TypeName()
		}
		{
			p.SetState(2472)
			p.Match(Java9ParserDOT)
		}
		{
			p.SetState(2473)
			p.Match(Java9ParserSUPER)
		}
		{
			p.SetState(2474)
			p.Match(Java9ParserDOT)
		}
		p.SetState(2476)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == Java9ParserLT {
			{
				p.SetState(2475)
				p.TypeArguments()
			}

		}
		{
			p.SetState(2478)
			p.Identifier()
		}
		{
			p.SetState(2479)
			p.Match(Java9ParserLPAREN)
		}
		p.SetState(2481)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<Java9ParserBOOLEAN)|(1<<Java9ParserBYTE)|(1<<Java9ParserCHAR)|(1<<Java9ParserDOUBLE)|(1<<Java9ParserEXPORTS)|(1<<Java9ParserFLOAT)|(1<<Java9ParserINT)|(1<<Java9ParserLONG)|(1<<Java9ParserMODULE))) != 0) || (((_la-33)&-(0x1f+1)) == 0 && ((1<<uint((_la-33)))&((1<<(Java9ParserNEW-33))|(1<<(Java9ParserOPEN-33))|(1<<(Java9ParserOPERNS-33))|(1<<(Java9ParserPROVIDES-33))|(1<<(Java9ParserREQUIRES-33))|(1<<(Java9ParserSHORT-33))|(1<<(Java9ParserSUPER-33))|(1<<(Java9ParserTHIS-33))|(1<<(Java9ParserTO-33))|(1<<(Java9ParserUSES-33))|(1<<(Java9ParserVOID-33))|(1<<(Java9ParserWITH-33))|(1<<(Java9ParserIntegerLiteral-33))|(1<<(Java9ParserFloatingPointLiteral-33))|(1<<(Java9ParserBooleanLiteral-33)))) != 0) || (((_la-65)&-(0x1f+1)) == 0 && ((1<<uint((_la-65)))&((1<<(Java9ParserCharacterLiteral-65))|(1<<(Java9ParserStringLiteral-65))|(1<<(Java9ParserNullLiteral-65))|(1<<(Java9ParserLPAREN-65))|(1<<(Java9ParserAT-65))|(1<<(Java9ParserBANG-65))|(1<<(Java9ParserTILDE-65))|(1<<(Java9ParserINC-65))|(1<<(Java9ParserDEC-65))|(1<<(Java9ParserADD-65)))) != 0) || _la == Java9ParserSUB || _la == Java9ParserIdentifier {
			{
				p.SetState(2480)
				p.ArgumentList()
			}

		}
		{
			p.SetState(2483)
			p.Match(Java9ParserRPAREN)
		}

	}

	return localctx
}

// IMethodInvocation_lf_primaryContext is an interface to support dynamic dispatch.
type IMethodInvocation_lf_primaryContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMethodInvocation_lf_primaryContext differentiates from other interfaces.
	IsMethodInvocation_lf_primaryContext()
}

type MethodInvocation_lf_primaryContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMethodInvocation_lf_primaryContext() *MethodInvocation_lf_primaryContext {
	var p = new(MethodInvocation_lf_primaryContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Java9ParserRULE_methodInvocation_lf_primary
	return p
}

func (*MethodInvocation_lf_primaryContext) IsMethodInvocation_lf_primaryContext() {}

func NewMethodInvocation_lf_primaryContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MethodInvocation_lf_primaryContext {
	var p = new(MethodInvocation_lf_primaryContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java9ParserRULE_methodInvocation_lf_primary

	return p
}

func (s *MethodInvocation_lf_primaryContext) GetParser() antlr.Parser { return s.parser }

func (s *MethodInvocation_lf_primaryContext) DOT() antlr.TerminalNode {
	return s.GetToken(Java9ParserDOT, 0)
}

func (s *MethodInvocation_lf_primaryContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *MethodInvocation_lf_primaryContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(Java9ParserLPAREN, 0)
}

func (s *MethodInvocation_lf_primaryContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(Java9ParserRPAREN, 0)
}

func (s *MethodInvocation_lf_primaryContext) TypeArguments() ITypeArgumentsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypeArgumentsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITypeArgumentsContext)
}

func (s *MethodInvocation_lf_primaryContext) ArgumentList() IArgumentListContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IArgumentListContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IArgumentListContext)
}

func (s *MethodInvocation_lf_primaryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MethodInvocation_lf_primaryContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MethodInvocation_lf_primaryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.EnterMethodInvocation_lf_primary(s)
	}
}

func (s *MethodInvocation_lf_primaryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.ExitMethodInvocation_lf_primary(s)
	}
}

func (p *Java9Parser) MethodInvocation_lf_primary() (localctx IMethodInvocation_lf_primaryContext) {
	localctx = NewMethodInvocation_lf_primaryContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 408, Java9ParserRULE_methodInvocation_lf_primary)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2487)
		p.Match(Java9ParserDOT)
	}
	p.SetState(2489)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Java9ParserLT {
		{
			p.SetState(2488)
			p.TypeArguments()
		}

	}
	{
		p.SetState(2491)
		p.Identifier()
	}
	{
		p.SetState(2492)
		p.Match(Java9ParserLPAREN)
	}
	p.SetState(2494)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<Java9ParserBOOLEAN)|(1<<Java9ParserBYTE)|(1<<Java9ParserCHAR)|(1<<Java9ParserDOUBLE)|(1<<Java9ParserEXPORTS)|(1<<Java9ParserFLOAT)|(1<<Java9ParserINT)|(1<<Java9ParserLONG)|(1<<Java9ParserMODULE))) != 0) || (((_la-33)&-(0x1f+1)) == 0 && ((1<<uint((_la-33)))&((1<<(Java9ParserNEW-33))|(1<<(Java9ParserOPEN-33))|(1<<(Java9ParserOPERNS-33))|(1<<(Java9ParserPROVIDES-33))|(1<<(Java9ParserREQUIRES-33))|(1<<(Java9ParserSHORT-33))|(1<<(Java9ParserSUPER-33))|(1<<(Java9ParserTHIS-33))|(1<<(Java9ParserTO-33))|(1<<(Java9ParserUSES-33))|(1<<(Java9ParserVOID-33))|(1<<(Java9ParserWITH-33))|(1<<(Java9ParserIntegerLiteral-33))|(1<<(Java9ParserFloatingPointLiteral-33))|(1<<(Java9ParserBooleanLiteral-33)))) != 0) || (((_la-65)&-(0x1f+1)) == 0 && ((1<<uint((_la-65)))&((1<<(Java9ParserCharacterLiteral-65))|(1<<(Java9ParserStringLiteral-65))|(1<<(Java9ParserNullLiteral-65))|(1<<(Java9ParserLPAREN-65))|(1<<(Java9ParserAT-65))|(1<<(Java9ParserBANG-65))|(1<<(Java9ParserTILDE-65))|(1<<(Java9ParserINC-65))|(1<<(Java9ParserDEC-65))|(1<<(Java9ParserADD-65)))) != 0) || _la == Java9ParserSUB || _la == Java9ParserIdentifier {
		{
			p.SetState(2493)
			p.ArgumentList()
		}

	}
	{
		p.SetState(2496)
		p.Match(Java9ParserRPAREN)
	}

	return localctx
}

// IMethodInvocation_lfno_primaryContext is an interface to support dynamic dispatch.
type IMethodInvocation_lfno_primaryContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMethodInvocation_lfno_primaryContext differentiates from other interfaces.
	IsMethodInvocation_lfno_primaryContext()
}

type MethodInvocation_lfno_primaryContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMethodInvocation_lfno_primaryContext() *MethodInvocation_lfno_primaryContext {
	var p = new(MethodInvocation_lfno_primaryContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Java9ParserRULE_methodInvocation_lfno_primary
	return p
}

func (*MethodInvocation_lfno_primaryContext) IsMethodInvocation_lfno_primaryContext() {}

func NewMethodInvocation_lfno_primaryContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MethodInvocation_lfno_primaryContext {
	var p = new(MethodInvocation_lfno_primaryContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java9ParserRULE_methodInvocation_lfno_primary

	return p
}

func (s *MethodInvocation_lfno_primaryContext) GetParser() antlr.Parser { return s.parser }

func (s *MethodInvocation_lfno_primaryContext) MethodName() IMethodNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMethodNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMethodNameContext)
}

func (s *MethodInvocation_lfno_primaryContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(Java9ParserLPAREN, 0)
}

func (s *MethodInvocation_lfno_primaryContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(Java9ParserRPAREN, 0)
}

func (s *MethodInvocation_lfno_primaryContext) ArgumentList() IArgumentListContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IArgumentListContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IArgumentListContext)
}

func (s *MethodInvocation_lfno_primaryContext) TypeName() ITypeNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypeNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITypeNameContext)
}

func (s *MethodInvocation_lfno_primaryContext) AllDOT() []antlr.TerminalNode {
	return s.GetTokens(Java9ParserDOT)
}

func (s *MethodInvocation_lfno_primaryContext) DOT(i int) antlr.TerminalNode {
	return s.GetToken(Java9ParserDOT, i)
}

func (s *MethodInvocation_lfno_primaryContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *MethodInvocation_lfno_primaryContext) TypeArguments() ITypeArgumentsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypeArgumentsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITypeArgumentsContext)
}

func (s *MethodInvocation_lfno_primaryContext) ExpressionName() IExpressionNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionNameContext)
}

func (s *MethodInvocation_lfno_primaryContext) SUPER() antlr.TerminalNode {
	return s.GetToken(Java9ParserSUPER, 0)
}

func (s *MethodInvocation_lfno_primaryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MethodInvocation_lfno_primaryContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MethodInvocation_lfno_primaryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.EnterMethodInvocation_lfno_primary(s)
	}
}

func (s *MethodInvocation_lfno_primaryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.ExitMethodInvocation_lfno_primary(s)
	}
}

func (p *Java9Parser) MethodInvocation_lfno_primary() (localctx IMethodInvocation_lfno_primaryContext) {
	localctx = NewMethodInvocation_lfno_primaryContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 410, Java9ParserRULE_methodInvocation_lfno_primary)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(2555)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 287, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2498)
			p.MethodName()
		}
		{
			p.SetState(2499)
			p.Match(Java9ParserLPAREN)
		}
		p.SetState(2501)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<Java9ParserBOOLEAN)|(1<<Java9ParserBYTE)|(1<<Java9ParserCHAR)|(1<<Java9ParserDOUBLE)|(1<<Java9ParserEXPORTS)|(1<<Java9ParserFLOAT)|(1<<Java9ParserINT)|(1<<Java9ParserLONG)|(1<<Java9ParserMODULE))) != 0) || (((_la-33)&-(0x1f+1)) == 0 && ((1<<uint((_la-33)))&((1<<(Java9ParserNEW-33))|(1<<(Java9ParserOPEN-33))|(1<<(Java9ParserOPERNS-33))|(1<<(Java9ParserPROVIDES-33))|(1<<(Java9ParserREQUIRES-33))|(1<<(Java9ParserSHORT-33))|(1<<(Java9ParserSUPER-33))|(1<<(Java9ParserTHIS-33))|(1<<(Java9ParserTO-33))|(1<<(Java9ParserUSES-33))|(1<<(Java9ParserVOID-33))|(1<<(Java9ParserWITH-33))|(1<<(Java9ParserIntegerLiteral-33))|(1<<(Java9ParserFloatingPointLiteral-33))|(1<<(Java9ParserBooleanLiteral-33)))) != 0) || (((_la-65)&-(0x1f+1)) == 0 && ((1<<uint((_la-65)))&((1<<(Java9ParserCharacterLiteral-65))|(1<<(Java9ParserStringLiteral-65))|(1<<(Java9ParserNullLiteral-65))|(1<<(Java9ParserLPAREN-65))|(1<<(Java9ParserAT-65))|(1<<(Java9ParserBANG-65))|(1<<(Java9ParserTILDE-65))|(1<<(Java9ParserINC-65))|(1<<(Java9ParserDEC-65))|(1<<(Java9ParserADD-65)))) != 0) || _la == Java9ParserSUB || _la == Java9ParserIdentifier {
			{
				p.SetState(2500)
				p.ArgumentList()
			}

		}
		{
			p.SetState(2503)
			p.Match(Java9ParserRPAREN)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2505)
			p.TypeName()
		}
		{
			p.SetState(2506)
			p.Match(Java9ParserDOT)
		}
		p.SetState(2508)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == Java9ParserLT {
			{
				p.SetState(2507)
				p.TypeArguments()
			}

		}
		{
			p.SetState(2510)
			p.Identifier()
		}
		{
			p.SetState(2511)
			p.Match(Java9ParserLPAREN)
		}
		p.SetState(2513)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<Java9ParserBOOLEAN)|(1<<Java9ParserBYTE)|(1<<Java9ParserCHAR)|(1<<Java9ParserDOUBLE)|(1<<Java9ParserEXPORTS)|(1<<Java9ParserFLOAT)|(1<<Java9ParserINT)|(1<<Java9ParserLONG)|(1<<Java9ParserMODULE))) != 0) || (((_la-33)&-(0x1f+1)) == 0 && ((1<<uint((_la-33)))&((1<<(Java9ParserNEW-33))|(1<<(Java9ParserOPEN-33))|(1<<(Java9ParserOPERNS-33))|(1<<(Java9ParserPROVIDES-33))|(1<<(Java9ParserREQUIRES-33))|(1<<(Java9ParserSHORT-33))|(1<<(Java9ParserSUPER-33))|(1<<(Java9ParserTHIS-33))|(1<<(Java9ParserTO-33))|(1<<(Java9ParserUSES-33))|(1<<(Java9ParserVOID-33))|(1<<(Java9ParserWITH-33))|(1<<(Java9ParserIntegerLiteral-33))|(1<<(Java9ParserFloatingPointLiteral-33))|(1<<(Java9ParserBooleanLiteral-33)))) != 0) || (((_la-65)&-(0x1f+1)) == 0 && ((1<<uint((_la-65)))&((1<<(Java9ParserCharacterLiteral-65))|(1<<(Java9ParserStringLiteral-65))|(1<<(Java9ParserNullLiteral-65))|(1<<(Java9ParserLPAREN-65))|(1<<(Java9ParserAT-65))|(1<<(Java9ParserBANG-65))|(1<<(Java9ParserTILDE-65))|(1<<(Java9ParserINC-65))|(1<<(Java9ParserDEC-65))|(1<<(Java9ParserADD-65)))) != 0) || _la == Java9ParserSUB || _la == Java9ParserIdentifier {
			{
				p.SetState(2512)
				p.ArgumentList()
			}

		}
		{
			p.SetState(2515)
			p.Match(Java9ParserRPAREN)
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2517)
			p.ExpressionName()
		}
		{
			p.SetState(2518)
			p.Match(Java9ParserDOT)
		}
		p.SetState(2520)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == Java9ParserLT {
			{
				p.SetState(2519)
				p.TypeArguments()
			}

		}
		{
			p.SetState(2522)
			p.Identifier()
		}
		{
			p.SetState(2523)
			p.Match(Java9ParserLPAREN)
		}
		p.SetState(2525)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<Java9ParserBOOLEAN)|(1<<Java9ParserBYTE)|(1<<Java9ParserCHAR)|(1<<Java9ParserDOUBLE)|(1<<Java9ParserEXPORTS)|(1<<Java9ParserFLOAT)|(1<<Java9ParserINT)|(1<<Java9ParserLONG)|(1<<Java9ParserMODULE))) != 0) || (((_la-33)&-(0x1f+1)) == 0 && ((1<<uint((_la-33)))&((1<<(Java9ParserNEW-33))|(1<<(Java9ParserOPEN-33))|(1<<(Java9ParserOPERNS-33))|(1<<(Java9ParserPROVIDES-33))|(1<<(Java9ParserREQUIRES-33))|(1<<(Java9ParserSHORT-33))|(1<<(Java9ParserSUPER-33))|(1<<(Java9ParserTHIS-33))|(1<<(Java9ParserTO-33))|(1<<(Java9ParserUSES-33))|(1<<(Java9ParserVOID-33))|(1<<(Java9ParserWITH-33))|(1<<(Java9ParserIntegerLiteral-33))|(1<<(Java9ParserFloatingPointLiteral-33))|(1<<(Java9ParserBooleanLiteral-33)))) != 0) || (((_la-65)&-(0x1f+1)) == 0 && ((1<<uint((_la-65)))&((1<<(Java9ParserCharacterLiteral-65))|(1<<(Java9ParserStringLiteral-65))|(1<<(Java9ParserNullLiteral-65))|(1<<(Java9ParserLPAREN-65))|(1<<(Java9ParserAT-65))|(1<<(Java9ParserBANG-65))|(1<<(Java9ParserTILDE-65))|(1<<(Java9ParserINC-65))|(1<<(Java9ParserDEC-65))|(1<<(Java9ParserADD-65)))) != 0) || _la == Java9ParserSUB || _la == Java9ParserIdentifier {
			{
				p.SetState(2524)
				p.ArgumentList()
			}

		}
		{
			p.SetState(2527)
			p.Match(Java9ParserRPAREN)
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(2529)
			p.Match(Java9ParserSUPER)
		}
		{
			p.SetState(2530)
			p.Match(Java9ParserDOT)
		}
		p.SetState(2532)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == Java9ParserLT {
			{
				p.SetState(2531)
				p.TypeArguments()
			}

		}
		{
			p.SetState(2534)
			p.Identifier()
		}
		{
			p.SetState(2535)
			p.Match(Java9ParserLPAREN)
		}
		p.SetState(2537)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<Java9ParserBOOLEAN)|(1<<Java9ParserBYTE)|(1<<Java9ParserCHAR)|(1<<Java9ParserDOUBLE)|(1<<Java9ParserEXPORTS)|(1<<Java9ParserFLOAT)|(1<<Java9ParserINT)|(1<<Java9ParserLONG)|(1<<Java9ParserMODULE))) != 0) || (((_la-33)&-(0x1f+1)) == 0 && ((1<<uint((_la-33)))&((1<<(Java9ParserNEW-33))|(1<<(Java9ParserOPEN-33))|(1<<(Java9ParserOPERNS-33))|(1<<(Java9ParserPROVIDES-33))|(1<<(Java9ParserREQUIRES-33))|(1<<(Java9ParserSHORT-33))|(1<<(Java9ParserSUPER-33))|(1<<(Java9ParserTHIS-33))|(1<<(Java9ParserTO-33))|(1<<(Java9ParserUSES-33))|(1<<(Java9ParserVOID-33))|(1<<(Java9ParserWITH-33))|(1<<(Java9ParserIntegerLiteral-33))|(1<<(Java9ParserFloatingPointLiteral-33))|(1<<(Java9ParserBooleanLiteral-33)))) != 0) || (((_la-65)&-(0x1f+1)) == 0 && ((1<<uint((_la-65)))&((1<<(Java9ParserCharacterLiteral-65))|(1<<(Java9ParserStringLiteral-65))|(1<<(Java9ParserNullLiteral-65))|(1<<(Java9ParserLPAREN-65))|(1<<(Java9ParserAT-65))|(1<<(Java9ParserBANG-65))|(1<<(Java9ParserTILDE-65))|(1<<(Java9ParserINC-65))|(1<<(Java9ParserDEC-65))|(1<<(Java9ParserADD-65)))) != 0) || _la == Java9ParserSUB || _la == Java9ParserIdentifier {
			{
				p.SetState(2536)
				p.ArgumentList()
			}

		}
		{
			p.SetState(2539)
			p.Match(Java9ParserRPAREN)
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(2541)
			p.TypeName()
		}
		{
			p.SetState(2542)
			p.Match(Java9ParserDOT)
		}
		{
			p.SetState(2543)
			p.Match(Java9ParserSUPER)
		}
		{
			p.SetState(2544)
			p.Match(Java9ParserDOT)
		}
		p.SetState(2546)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == Java9ParserLT {
			{
				p.SetState(2545)
				p.TypeArguments()
			}

		}
		{
			p.SetState(2548)
			p.Identifier()
		}
		{
			p.SetState(2549)
			p.Match(Java9ParserLPAREN)
		}
		p.SetState(2551)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<Java9ParserBOOLEAN)|(1<<Java9ParserBYTE)|(1<<Java9ParserCHAR)|(1<<Java9ParserDOUBLE)|(1<<Java9ParserEXPORTS)|(1<<Java9ParserFLOAT)|(1<<Java9ParserINT)|(1<<Java9ParserLONG)|(1<<Java9ParserMODULE))) != 0) || (((_la-33)&-(0x1f+1)) == 0 && ((1<<uint((_la-33)))&((1<<(Java9ParserNEW-33))|(1<<(Java9ParserOPEN-33))|(1<<(Java9ParserOPERNS-33))|(1<<(Java9ParserPROVIDES-33))|(1<<(Java9ParserREQUIRES-33))|(1<<(Java9ParserSHORT-33))|(1<<(Java9ParserSUPER-33))|(1<<(Java9ParserTHIS-33))|(1<<(Java9ParserTO-33))|(1<<(Java9ParserUSES-33))|(1<<(Java9ParserVOID-33))|(1<<(Java9ParserWITH-33))|(1<<(Java9ParserIntegerLiteral-33))|(1<<(Java9ParserFloatingPointLiteral-33))|(1<<(Java9ParserBooleanLiteral-33)))) != 0) || (((_la-65)&-(0x1f+1)) == 0 && ((1<<uint((_la-65)))&((1<<(Java9ParserCharacterLiteral-65))|(1<<(Java9ParserStringLiteral-65))|(1<<(Java9ParserNullLiteral-65))|(1<<(Java9ParserLPAREN-65))|(1<<(Java9ParserAT-65))|(1<<(Java9ParserBANG-65))|(1<<(Java9ParserTILDE-65))|(1<<(Java9ParserINC-65))|(1<<(Java9ParserDEC-65))|(1<<(Java9ParserADD-65)))) != 0) || _la == Java9ParserSUB || _la == Java9ParserIdentifier {
			{
				p.SetState(2550)
				p.ArgumentList()
			}

		}
		{
			p.SetState(2553)
			p.Match(Java9ParserRPAREN)
		}

	}

	return localctx
}

// IArgumentListContext is an interface to support dynamic dispatch.
type IArgumentListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsArgumentListContext differentiates from other interfaces.
	IsArgumentListContext()
}

type ArgumentListContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyArgumentListContext() *ArgumentListContext {
	var p = new(ArgumentListContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Java9ParserRULE_argumentList
	return p
}

func (*ArgumentListContext) IsArgumentListContext() {}

func NewArgumentListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ArgumentListContext {
	var p = new(ArgumentListContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java9ParserRULE_argumentList

	return p
}

func (s *ArgumentListContext) GetParser() antlr.Parser { return s.parser }

func (s *ArgumentListContext) AllExpression() []IExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExpressionContext)(nil)).Elem())
	var tst = make([]IExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExpressionContext)
		}
	}

	return tst
}

func (s *ArgumentListContext) Expression(i int) IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ArgumentListContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(Java9ParserCOMMA)
}

func (s *ArgumentListContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(Java9ParserCOMMA, i)
}

func (s *ArgumentListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArgumentListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ArgumentListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.EnterArgumentList(s)
	}
}

func (s *ArgumentListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.ExitArgumentList(s)
	}
}

func (p *Java9Parser) ArgumentList() (localctx IArgumentListContext) {
	localctx = NewArgumentListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 412, Java9ParserRULE_argumentList)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2557)
		p.Expression()
	}
	p.SetState(2562)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == Java9ParserCOMMA {
		{
			p.SetState(2558)
			p.Match(Java9ParserCOMMA)
		}
		{
			p.SetState(2559)
			p.Expression()
		}

		p.SetState(2564)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IMethodReferenceContext is an interface to support dynamic dispatch.
type IMethodReferenceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMethodReferenceContext differentiates from other interfaces.
	IsMethodReferenceContext()
}

type MethodReferenceContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMethodReferenceContext() *MethodReferenceContext {
	var p = new(MethodReferenceContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Java9ParserRULE_methodReference
	return p
}

func (*MethodReferenceContext) IsMethodReferenceContext() {}

func NewMethodReferenceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MethodReferenceContext {
	var p = new(MethodReferenceContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java9ParserRULE_methodReference

	return p
}

func (s *MethodReferenceContext) GetParser() antlr.Parser { return s.parser }

func (s *MethodReferenceContext) ExpressionName() IExpressionNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionNameContext)
}

func (s *MethodReferenceContext) COLONCOLON() antlr.TerminalNode {
	return s.GetToken(Java9ParserCOLONCOLON, 0)
}

func (s *MethodReferenceContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *MethodReferenceContext) TypeArguments() ITypeArgumentsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypeArgumentsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITypeArgumentsContext)
}

func (s *MethodReferenceContext) ReferenceType() IReferenceTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IReferenceTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IReferenceTypeContext)
}

func (s *MethodReferenceContext) Primary() IPrimaryContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPrimaryContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPrimaryContext)
}

func (s *MethodReferenceContext) SUPER() antlr.TerminalNode {
	return s.GetToken(Java9ParserSUPER, 0)
}

func (s *MethodReferenceContext) TypeName() ITypeNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypeNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITypeNameContext)
}

func (s *MethodReferenceContext) DOT() antlr.TerminalNode {
	return s.GetToken(Java9ParserDOT, 0)
}

func (s *MethodReferenceContext) ClassType() IClassTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IClassTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IClassTypeContext)
}

func (s *MethodReferenceContext) NEW() antlr.TerminalNode {
	return s.GetToken(Java9ParserNEW, 0)
}

func (s *MethodReferenceContext) ArrayType() IArrayTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IArrayTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IArrayTypeContext)
}

func (s *MethodReferenceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MethodReferenceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MethodReferenceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.EnterMethodReference(s)
	}
}

func (s *MethodReferenceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.ExitMethodReference(s)
	}
}

func (p *Java9Parser) MethodReference() (localctx IMethodReferenceContext) {
	localctx = NewMethodReferenceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 414, Java9ParserRULE_methodReference)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(2612)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 295, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2565)
			p.ExpressionName()
		}
		{
			p.SetState(2566)
			p.Match(Java9ParserCOLONCOLON)
		}
		p.SetState(2568)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == Java9ParserLT {
			{
				p.SetState(2567)
				p.TypeArguments()
			}

		}
		{
			p.SetState(2570)
			p.Identifier()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2572)
			p.ReferenceType()
		}
		{
			p.SetState(2573)
			p.Match(Java9ParserCOLONCOLON)
		}
		p.SetState(2575)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == Java9ParserLT {
			{
				p.SetState(2574)
				p.TypeArguments()
			}

		}
		{
			p.SetState(2577)
			p.Identifier()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2579)
			p.Primary()
		}
		{
			p.SetState(2580)
			p.Match(Java9ParserCOLONCOLON)
		}
		p.SetState(2582)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == Java9ParserLT {
			{
				p.SetState(2581)
				p.TypeArguments()
			}

		}
		{
			p.SetState(2584)
			p.Identifier()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(2586)
			p.Match(Java9ParserSUPER)
		}
		{
			p.SetState(2587)
			p.Match(Java9ParserCOLONCOLON)
		}
		p.SetState(2589)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == Java9ParserLT {
			{
				p.SetState(2588)
				p.TypeArguments()
			}

		}
		{
			p.SetState(2591)
			p.Identifier()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(2592)
			p.TypeName()
		}
		{
			p.SetState(2593)
			p.Match(Java9ParserDOT)
		}
		{
			p.SetState(2594)
			p.Match(Java9ParserSUPER)
		}
		{
			p.SetState(2595)
			p.Match(Java9ParserCOLONCOLON)
		}
		p.SetState(2597)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == Java9ParserLT {
			{
				p.SetState(2596)
				p.TypeArguments()
			}

		}
		{
			p.SetState(2599)
			p.Identifier()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(2601)
			p.ClassType()
		}
		{
			p.SetState(2602)
			p.Match(Java9ParserCOLONCOLON)
		}
		p.SetState(2604)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == Java9ParserLT {
			{
				p.SetState(2603)
				p.TypeArguments()
			}

		}
		{
			p.SetState(2606)
			p.Match(Java9ParserNEW)
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(2608)
			p.ArrayType()
		}
		{
			p.SetState(2609)
			p.Match(Java9ParserCOLONCOLON)
		}
		{
			p.SetState(2610)
			p.Match(Java9ParserNEW)
		}

	}

	return localctx
}

// IMethodReference_lf_primaryContext is an interface to support dynamic dispatch.
type IMethodReference_lf_primaryContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMethodReference_lf_primaryContext differentiates from other interfaces.
	IsMethodReference_lf_primaryContext()
}

type MethodReference_lf_primaryContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMethodReference_lf_primaryContext() *MethodReference_lf_primaryContext {
	var p = new(MethodReference_lf_primaryContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Java9ParserRULE_methodReference_lf_primary
	return p
}

func (*MethodReference_lf_primaryContext) IsMethodReference_lf_primaryContext() {}

func NewMethodReference_lf_primaryContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MethodReference_lf_primaryContext {
	var p = new(MethodReference_lf_primaryContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java9ParserRULE_methodReference_lf_primary

	return p
}

func (s *MethodReference_lf_primaryContext) GetParser() antlr.Parser { return s.parser }

func (s *MethodReference_lf_primaryContext) COLONCOLON() antlr.TerminalNode {
	return s.GetToken(Java9ParserCOLONCOLON, 0)
}

func (s *MethodReference_lf_primaryContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *MethodReference_lf_primaryContext) TypeArguments() ITypeArgumentsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypeArgumentsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITypeArgumentsContext)
}

func (s *MethodReference_lf_primaryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MethodReference_lf_primaryContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MethodReference_lf_primaryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.EnterMethodReference_lf_primary(s)
	}
}

func (s *MethodReference_lf_primaryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.ExitMethodReference_lf_primary(s)
	}
}

func (p *Java9Parser) MethodReference_lf_primary() (localctx IMethodReference_lf_primaryContext) {
	localctx = NewMethodReference_lf_primaryContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 416, Java9ParserRULE_methodReference_lf_primary)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2614)
		p.Match(Java9ParserCOLONCOLON)
	}
	p.SetState(2616)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Java9ParserLT {
		{
			p.SetState(2615)
			p.TypeArguments()
		}

	}
	{
		p.SetState(2618)
		p.Identifier()
	}

	return localctx
}

// IMethodReference_lfno_primaryContext is an interface to support dynamic dispatch.
type IMethodReference_lfno_primaryContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMethodReference_lfno_primaryContext differentiates from other interfaces.
	IsMethodReference_lfno_primaryContext()
}

type MethodReference_lfno_primaryContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMethodReference_lfno_primaryContext() *MethodReference_lfno_primaryContext {
	var p = new(MethodReference_lfno_primaryContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Java9ParserRULE_methodReference_lfno_primary
	return p
}

func (*MethodReference_lfno_primaryContext) IsMethodReference_lfno_primaryContext() {}

func NewMethodReference_lfno_primaryContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MethodReference_lfno_primaryContext {
	var p = new(MethodReference_lfno_primaryContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java9ParserRULE_methodReference_lfno_primary

	return p
}

func (s *MethodReference_lfno_primaryContext) GetParser() antlr.Parser { return s.parser }

func (s *MethodReference_lfno_primaryContext) ExpressionName() IExpressionNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionNameContext)
}

func (s *MethodReference_lfno_primaryContext) COLONCOLON() antlr.TerminalNode {
	return s.GetToken(Java9ParserCOLONCOLON, 0)
}

func (s *MethodReference_lfno_primaryContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *MethodReference_lfno_primaryContext) TypeArguments() ITypeArgumentsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypeArgumentsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITypeArgumentsContext)
}

func (s *MethodReference_lfno_primaryContext) ReferenceType() IReferenceTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IReferenceTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IReferenceTypeContext)
}

func (s *MethodReference_lfno_primaryContext) SUPER() antlr.TerminalNode {
	return s.GetToken(Java9ParserSUPER, 0)
}

func (s *MethodReference_lfno_primaryContext) TypeName() ITypeNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypeNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITypeNameContext)
}

func (s *MethodReference_lfno_primaryContext) DOT() antlr.TerminalNode {
	return s.GetToken(Java9ParserDOT, 0)
}

func (s *MethodReference_lfno_primaryContext) ClassType() IClassTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IClassTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IClassTypeContext)
}

func (s *MethodReference_lfno_primaryContext) NEW() antlr.TerminalNode {
	return s.GetToken(Java9ParserNEW, 0)
}

func (s *MethodReference_lfno_primaryContext) ArrayType() IArrayTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IArrayTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IArrayTypeContext)
}

func (s *MethodReference_lfno_primaryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MethodReference_lfno_primaryContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MethodReference_lfno_primaryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.EnterMethodReference_lfno_primary(s)
	}
}

func (s *MethodReference_lfno_primaryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.ExitMethodReference_lfno_primary(s)
	}
}

func (p *Java9Parser) MethodReference_lfno_primary() (localctx IMethodReference_lfno_primaryContext) {
	localctx = NewMethodReference_lfno_primaryContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 418, Java9ParserRULE_methodReference_lfno_primary)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(2660)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 302, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2620)
			p.ExpressionName()
		}
		{
			p.SetState(2621)
			p.Match(Java9ParserCOLONCOLON)
		}
		p.SetState(2623)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == Java9ParserLT {
			{
				p.SetState(2622)
				p.TypeArguments()
			}

		}
		{
			p.SetState(2625)
			p.Identifier()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2627)
			p.ReferenceType()
		}
		{
			p.SetState(2628)
			p.Match(Java9ParserCOLONCOLON)
		}
		p.SetState(2630)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == Java9ParserLT {
			{
				p.SetState(2629)
				p.TypeArguments()
			}

		}
		{
			p.SetState(2632)
			p.Identifier()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2634)
			p.Match(Java9ParserSUPER)
		}
		{
			p.SetState(2635)
			p.Match(Java9ParserCOLONCOLON)
		}
		p.SetState(2637)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == Java9ParserLT {
			{
				p.SetState(2636)
				p.TypeArguments()
			}

		}
		{
			p.SetState(2639)
			p.Identifier()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(2640)
			p.TypeName()
		}
		{
			p.SetState(2641)
			p.Match(Java9ParserDOT)
		}
		{
			p.SetState(2642)
			p.Match(Java9ParserSUPER)
		}
		{
			p.SetState(2643)
			p.Match(Java9ParserCOLONCOLON)
		}
		p.SetState(2645)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == Java9ParserLT {
			{
				p.SetState(2644)
				p.TypeArguments()
			}

		}
		{
			p.SetState(2647)
			p.Identifier()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(2649)
			p.ClassType()
		}
		{
			p.SetState(2650)
			p.Match(Java9ParserCOLONCOLON)
		}
		p.SetState(2652)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == Java9ParserLT {
			{
				p.SetState(2651)
				p.TypeArguments()
			}

		}
		{
			p.SetState(2654)
			p.Match(Java9ParserNEW)
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(2656)
			p.ArrayType()
		}
		{
			p.SetState(2657)
			p.Match(Java9ParserCOLONCOLON)
		}
		{
			p.SetState(2658)
			p.Match(Java9ParserNEW)
		}

	}

	return localctx
}

// IArrayCreationExpressionContext is an interface to support dynamic dispatch.
type IArrayCreationExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsArrayCreationExpressionContext differentiates from other interfaces.
	IsArrayCreationExpressionContext()
}

type ArrayCreationExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyArrayCreationExpressionContext() *ArrayCreationExpressionContext {
	var p = new(ArrayCreationExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Java9ParserRULE_arrayCreationExpression
	return p
}

func (*ArrayCreationExpressionContext) IsArrayCreationExpressionContext() {}

func NewArrayCreationExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ArrayCreationExpressionContext {
	var p = new(ArrayCreationExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java9ParserRULE_arrayCreationExpression

	return p
}

func (s *ArrayCreationExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *ArrayCreationExpressionContext) NEW() antlr.TerminalNode {
	return s.GetToken(Java9ParserNEW, 0)
}

func (s *ArrayCreationExpressionContext) PrimitiveType() IPrimitiveTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPrimitiveTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPrimitiveTypeContext)
}

func (s *ArrayCreationExpressionContext) DimExprs() IDimExprsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDimExprsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDimExprsContext)
}

func (s *ArrayCreationExpressionContext) Dims() IDimsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDimsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDimsContext)
}

func (s *ArrayCreationExpressionContext) ClassOrInterfaceType() IClassOrInterfaceTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IClassOrInterfaceTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IClassOrInterfaceTypeContext)
}

func (s *ArrayCreationExpressionContext) ArrayInitializer() IArrayInitializerContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IArrayInitializerContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IArrayInitializerContext)
}

func (s *ArrayCreationExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArrayCreationExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ArrayCreationExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.EnterArrayCreationExpression(s)
	}
}

func (s *ArrayCreationExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.ExitArrayCreationExpression(s)
	}
}

func (p *Java9Parser) ArrayCreationExpression() (localctx IArrayCreationExpressionContext) {
	localctx = NewArrayCreationExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 420, Java9ParserRULE_arrayCreationExpression)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(2684)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 305, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2662)
			p.Match(Java9ParserNEW)
		}
		{
			p.SetState(2663)
			p.PrimitiveType()
		}
		{
			p.SetState(2664)
			p.DimExprs()
		}
		p.SetState(2666)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 303, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(2665)
				p.Dims()
			}

		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2668)
			p.Match(Java9ParserNEW)
		}
		{
			p.SetState(2669)
			p.ClassOrInterfaceType()
		}
		{
			p.SetState(2670)
			p.DimExprs()
		}
		p.SetState(2672)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 304, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(2671)
				p.Dims()
			}

		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2674)
			p.Match(Java9ParserNEW)
		}
		{
			p.SetState(2675)
			p.PrimitiveType()
		}
		{
			p.SetState(2676)
			p.Dims()
		}
		{
			p.SetState(2677)
			p.ArrayInitializer()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(2679)
			p.Match(Java9ParserNEW)
		}
		{
			p.SetState(2680)
			p.ClassOrInterfaceType()
		}
		{
			p.SetState(2681)
			p.Dims()
		}
		{
			p.SetState(2682)
			p.ArrayInitializer()
		}

	}

	return localctx
}

// IDimExprsContext is an interface to support dynamic dispatch.
type IDimExprsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDimExprsContext differentiates from other interfaces.
	IsDimExprsContext()
}

type DimExprsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDimExprsContext() *DimExprsContext {
	var p = new(DimExprsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Java9ParserRULE_dimExprs
	return p
}

func (*DimExprsContext) IsDimExprsContext() {}

func NewDimExprsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DimExprsContext {
	var p = new(DimExprsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java9ParserRULE_dimExprs

	return p
}

func (s *DimExprsContext) GetParser() antlr.Parser { return s.parser }

func (s *DimExprsContext) AllDimExpr() []IDimExprContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IDimExprContext)(nil)).Elem())
	var tst = make([]IDimExprContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IDimExprContext)
		}
	}

	return tst
}

func (s *DimExprsContext) DimExpr(i int) IDimExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDimExprContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IDimExprContext)
}

func (s *DimExprsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DimExprsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DimExprsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.EnterDimExprs(s)
	}
}

func (s *DimExprsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.ExitDimExprs(s)
	}
}

func (p *Java9Parser) DimExprs() (localctx IDimExprsContext) {
	localctx = NewDimExprsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 422, Java9ParserRULE_dimExprs)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(2687)
	p.GetErrorHandler().Sync(p)
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			{
				p.SetState(2686)
				p.DimExpr()
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(2689)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 306, p.GetParserRuleContext())
	}

	return localctx
}

// IDimExprContext is an interface to support dynamic dispatch.
type IDimExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDimExprContext differentiates from other interfaces.
	IsDimExprContext()
}

type DimExprContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDimExprContext() *DimExprContext {
	var p = new(DimExprContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Java9ParserRULE_dimExpr
	return p
}

func (*DimExprContext) IsDimExprContext() {}

func NewDimExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DimExprContext {
	var p = new(DimExprContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java9ParserRULE_dimExpr

	return p
}

func (s *DimExprContext) GetParser() antlr.Parser { return s.parser }

func (s *DimExprContext) LBRACK() antlr.TerminalNode {
	return s.GetToken(Java9ParserLBRACK, 0)
}

func (s *DimExprContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *DimExprContext) RBRACK() antlr.TerminalNode {
	return s.GetToken(Java9ParserRBRACK, 0)
}

func (s *DimExprContext) AllAnnotation() []IAnnotationContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAnnotationContext)(nil)).Elem())
	var tst = make([]IAnnotationContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAnnotationContext)
		}
	}

	return tst
}

func (s *DimExprContext) Annotation(i int) IAnnotationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAnnotationContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAnnotationContext)
}

func (s *DimExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DimExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DimExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.EnterDimExpr(s)
	}
}

func (s *DimExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.ExitDimExpr(s)
	}
}

func (p *Java9Parser) DimExpr() (localctx IDimExprContext) {
	localctx = NewDimExprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 424, Java9ParserRULE_dimExpr)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(2694)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == Java9ParserAT {
		{
			p.SetState(2691)
			p.Annotation()
		}

		p.SetState(2696)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(2697)
		p.Match(Java9ParserLBRACK)
	}
	{
		p.SetState(2698)
		p.Expression()
	}
	{
		p.SetState(2699)
		p.Match(Java9ParserRBRACK)
	}

	return localctx
}

// IConstantExpressionContext is an interface to support dynamic dispatch.
type IConstantExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsConstantExpressionContext differentiates from other interfaces.
	IsConstantExpressionContext()
}

type ConstantExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConstantExpressionContext() *ConstantExpressionContext {
	var p = new(ConstantExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Java9ParserRULE_constantExpression
	return p
}

func (*ConstantExpressionContext) IsConstantExpressionContext() {}

func NewConstantExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ConstantExpressionContext {
	var p = new(ConstantExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java9ParserRULE_constantExpression

	return p
}

func (s *ConstantExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *ConstantExpressionContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ConstantExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ConstantExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ConstantExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.EnterConstantExpression(s)
	}
}

func (s *ConstantExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.ExitConstantExpression(s)
	}
}

func (p *Java9Parser) ConstantExpression() (localctx IConstantExpressionContext) {
	localctx = NewConstantExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 426, Java9ParserRULE_constantExpression)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2701)
		p.Expression()
	}

	return localctx
}

// IExpressionContext is an interface to support dynamic dispatch.
type IExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExpressionContext differentiates from other interfaces.
	IsExpressionContext()
}

type ExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpressionContext() *ExpressionContext {
	var p = new(ExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Java9ParserRULE_expression
	return p
}

func (*ExpressionContext) IsExpressionContext() {}

func NewExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExpressionContext {
	var p = new(ExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java9ParserRULE_expression

	return p
}

func (s *ExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *ExpressionContext) LambdaExpression() ILambdaExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILambdaExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILambdaExpressionContext)
}

func (s *ExpressionContext) AssignmentExpression() IAssignmentExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAssignmentExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAssignmentExpressionContext)
}

func (s *ExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.EnterExpression(s)
	}
}

func (s *ExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.ExitExpression(s)
	}
}

func (p *Java9Parser) Expression() (localctx IExpressionContext) {
	localctx = NewExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 428, Java9ParserRULE_expression)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(2705)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 308, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2703)
			p.LambdaExpression()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2704)
			p.AssignmentExpression()
		}

	}

	return localctx
}

// ILambdaExpressionContext is an interface to support dynamic dispatch.
type ILambdaExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLambdaExpressionContext differentiates from other interfaces.
	IsLambdaExpressionContext()
}

type LambdaExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLambdaExpressionContext() *LambdaExpressionContext {
	var p = new(LambdaExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Java9ParserRULE_lambdaExpression
	return p
}

func (*LambdaExpressionContext) IsLambdaExpressionContext() {}

func NewLambdaExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LambdaExpressionContext {
	var p = new(LambdaExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java9ParserRULE_lambdaExpression

	return p
}

func (s *LambdaExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *LambdaExpressionContext) LambdaParameters() ILambdaParametersContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILambdaParametersContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILambdaParametersContext)
}

func (s *LambdaExpressionContext) ARROW() antlr.TerminalNode {
	return s.GetToken(Java9ParserARROW, 0)
}

func (s *LambdaExpressionContext) LambdaBody() ILambdaBodyContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILambdaBodyContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILambdaBodyContext)
}

func (s *LambdaExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LambdaExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LambdaExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.EnterLambdaExpression(s)
	}
}

func (s *LambdaExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.ExitLambdaExpression(s)
	}
}

func (p *Java9Parser) LambdaExpression() (localctx ILambdaExpressionContext) {
	localctx = NewLambdaExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 430, Java9ParserRULE_lambdaExpression)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2707)
		p.LambdaParameters()
	}
	{
		p.SetState(2708)
		p.Match(Java9ParserARROW)
	}
	{
		p.SetState(2709)
		p.LambdaBody()
	}

	return localctx
}

// ILambdaParametersContext is an interface to support dynamic dispatch.
type ILambdaParametersContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLambdaParametersContext differentiates from other interfaces.
	IsLambdaParametersContext()
}

type LambdaParametersContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLambdaParametersContext() *LambdaParametersContext {
	var p = new(LambdaParametersContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Java9ParserRULE_lambdaParameters
	return p
}

func (*LambdaParametersContext) IsLambdaParametersContext() {}

func NewLambdaParametersContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LambdaParametersContext {
	var p = new(LambdaParametersContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java9ParserRULE_lambdaParameters

	return p
}

func (s *LambdaParametersContext) GetParser() antlr.Parser { return s.parser }

func (s *LambdaParametersContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *LambdaParametersContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(Java9ParserLPAREN, 0)
}

func (s *LambdaParametersContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(Java9ParserRPAREN, 0)
}

func (s *LambdaParametersContext) FormalParameterList() IFormalParameterListContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFormalParameterListContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFormalParameterListContext)
}

func (s *LambdaParametersContext) InferredFormalParameterList() IInferredFormalParameterListContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInferredFormalParameterListContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInferredFormalParameterListContext)
}

func (s *LambdaParametersContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LambdaParametersContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LambdaParametersContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.EnterLambdaParameters(s)
	}
}

func (s *LambdaParametersContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.ExitLambdaParameters(s)
	}
}

func (p *Java9Parser) LambdaParameters() (localctx ILambdaParametersContext) {
	localctx = NewLambdaParametersContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 432, Java9ParserRULE_lambdaParameters)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(2721)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 310, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2711)
			p.Identifier()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2712)
			p.Match(Java9ParserLPAREN)
		}
		p.SetState(2714)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<Java9ParserBOOLEAN)|(1<<Java9ParserBYTE)|(1<<Java9ParserCHAR)|(1<<Java9ParserDOUBLE)|(1<<Java9ParserEXPORTS)|(1<<Java9ParserFINAL)|(1<<Java9ParserFLOAT)|(1<<Java9ParserINT)|(1<<Java9ParserLONG)|(1<<Java9ParserMODULE))) != 0) || (((_la-34)&-(0x1f+1)) == 0 && ((1<<uint((_la-34)))&((1<<(Java9ParserOPEN-34))|(1<<(Java9ParserOPERNS-34))|(1<<(Java9ParserPROVIDES-34))|(1<<(Java9ParserREQUIRES-34))|(1<<(Java9ParserSHORT-34))|(1<<(Java9ParserTO-34))|(1<<(Java9ParserUSES-34))|(1<<(Java9ParserWITH-34)))) != 0) || _la == Java9ParserAT || _la == Java9ParserIdentifier {
			{
				p.SetState(2713)
				p.FormalParameterList()
			}

		}
		{
			p.SetState(2716)
			p.Match(Java9ParserRPAREN)
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2717)
			p.Match(Java9ParserLPAREN)
		}
		{
			p.SetState(2718)
			p.InferredFormalParameterList()
		}
		{
			p.SetState(2719)
			p.Match(Java9ParserRPAREN)
		}

	}

	return localctx
}

// IInferredFormalParameterListContext is an interface to support dynamic dispatch.
type IInferredFormalParameterListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsInferredFormalParameterListContext differentiates from other interfaces.
	IsInferredFormalParameterListContext()
}

type InferredFormalParameterListContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInferredFormalParameterListContext() *InferredFormalParameterListContext {
	var p = new(InferredFormalParameterListContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Java9ParserRULE_inferredFormalParameterList
	return p
}

func (*InferredFormalParameterListContext) IsInferredFormalParameterListContext() {}

func NewInferredFormalParameterListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InferredFormalParameterListContext {
	var p = new(InferredFormalParameterListContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java9ParserRULE_inferredFormalParameterList

	return p
}

func (s *InferredFormalParameterListContext) GetParser() antlr.Parser { return s.parser }

func (s *InferredFormalParameterListContext) AllIdentifier() []IIdentifierContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IIdentifierContext)(nil)).Elem())
	var tst = make([]IIdentifierContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IIdentifierContext)
		}
	}

	return tst
}

func (s *InferredFormalParameterListContext) Identifier(i int) IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *InferredFormalParameterListContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(Java9ParserCOMMA)
}

func (s *InferredFormalParameterListContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(Java9ParserCOMMA, i)
}

func (s *InferredFormalParameterListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InferredFormalParameterListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InferredFormalParameterListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.EnterInferredFormalParameterList(s)
	}
}

func (s *InferredFormalParameterListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.ExitInferredFormalParameterList(s)
	}
}

func (p *Java9Parser) InferredFormalParameterList() (localctx IInferredFormalParameterListContext) {
	localctx = NewInferredFormalParameterListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 434, Java9ParserRULE_inferredFormalParameterList)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2723)
		p.Identifier()
	}
	p.SetState(2728)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == Java9ParserCOMMA {
		{
			p.SetState(2724)
			p.Match(Java9ParserCOMMA)
		}
		{
			p.SetState(2725)
			p.Identifier()
		}

		p.SetState(2730)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// ILambdaBodyContext is an interface to support dynamic dispatch.
type ILambdaBodyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLambdaBodyContext differentiates from other interfaces.
	IsLambdaBodyContext()
}

type LambdaBodyContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLambdaBodyContext() *LambdaBodyContext {
	var p = new(LambdaBodyContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Java9ParserRULE_lambdaBody
	return p
}

func (*LambdaBodyContext) IsLambdaBodyContext() {}

func NewLambdaBodyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LambdaBodyContext {
	var p = new(LambdaBodyContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java9ParserRULE_lambdaBody

	return p
}

func (s *LambdaBodyContext) GetParser() antlr.Parser { return s.parser }

func (s *LambdaBodyContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *LambdaBodyContext) Block() IBlockContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBlockContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBlockContext)
}

func (s *LambdaBodyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LambdaBodyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LambdaBodyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.EnterLambdaBody(s)
	}
}

func (s *LambdaBodyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.ExitLambdaBody(s)
	}
}

func (p *Java9Parser) LambdaBody() (localctx ILambdaBodyContext) {
	localctx = NewLambdaBodyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 436, Java9ParserRULE_lambdaBody)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(2733)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case Java9ParserBOOLEAN, Java9ParserBYTE, Java9ParserCHAR, Java9ParserDOUBLE, Java9ParserEXPORTS, Java9ParserFLOAT, Java9ParserINT, Java9ParserLONG, Java9ParserMODULE, Java9ParserNEW, Java9ParserOPEN, Java9ParserOPERNS, Java9ParserPROVIDES, Java9ParserREQUIRES, Java9ParserSHORT, Java9ParserSUPER, Java9ParserTHIS, Java9ParserTO, Java9ParserUSES, Java9ParserVOID, Java9ParserWITH, Java9ParserIntegerLiteral, Java9ParserFloatingPointLiteral, Java9ParserBooleanLiteral, Java9ParserCharacterLiteral, Java9ParserStringLiteral, Java9ParserNullLiteral, Java9ParserLPAREN, Java9ParserAT, Java9ParserBANG, Java9ParserTILDE, Java9ParserINC, Java9ParserDEC, Java9ParserADD, Java9ParserSUB, Java9ParserIdentifier:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2731)
			p.Expression()
		}

	case Java9ParserLBRACE:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2732)
			p.Block()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IAssignmentExpressionContext is an interface to support dynamic dispatch.
type IAssignmentExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAssignmentExpressionContext differentiates from other interfaces.
	IsAssignmentExpressionContext()
}

type AssignmentExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAssignmentExpressionContext() *AssignmentExpressionContext {
	var p = new(AssignmentExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Java9ParserRULE_assignmentExpression
	return p
}

func (*AssignmentExpressionContext) IsAssignmentExpressionContext() {}

func NewAssignmentExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AssignmentExpressionContext {
	var p = new(AssignmentExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java9ParserRULE_assignmentExpression

	return p
}

func (s *AssignmentExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *AssignmentExpressionContext) ConditionalExpression() IConditionalExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConditionalExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConditionalExpressionContext)
}

func (s *AssignmentExpressionContext) Assignment() IAssignmentContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAssignmentContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAssignmentContext)
}

func (s *AssignmentExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AssignmentExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AssignmentExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.EnterAssignmentExpression(s)
	}
}

func (s *AssignmentExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.ExitAssignmentExpression(s)
	}
}

func (p *Java9Parser) AssignmentExpression() (localctx IAssignmentExpressionContext) {
	localctx = NewAssignmentExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 438, Java9ParserRULE_assignmentExpression)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(2737)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 313, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2735)
			p.ConditionalExpression()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2736)
			p.Assignment()
		}

	}

	return localctx
}

// IAssignmentContext is an interface to support dynamic dispatch.
type IAssignmentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAssignmentContext differentiates from other interfaces.
	IsAssignmentContext()
}

type AssignmentContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAssignmentContext() *AssignmentContext {
	var p = new(AssignmentContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Java9ParserRULE_assignment
	return p
}

func (*AssignmentContext) IsAssignmentContext() {}

func NewAssignmentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AssignmentContext {
	var p = new(AssignmentContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java9ParserRULE_assignment

	return p
}

func (s *AssignmentContext) GetParser() antlr.Parser { return s.parser }

func (s *AssignmentContext) LeftHandSide() ILeftHandSideContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILeftHandSideContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILeftHandSideContext)
}

func (s *AssignmentContext) AssignmentOperator() IAssignmentOperatorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAssignmentOperatorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAssignmentOperatorContext)
}

func (s *AssignmentContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *AssignmentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AssignmentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AssignmentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.EnterAssignment(s)
	}
}

func (s *AssignmentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.ExitAssignment(s)
	}
}

func (p *Java9Parser) Assignment() (localctx IAssignmentContext) {
	localctx = NewAssignmentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 440, Java9ParserRULE_assignment)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2739)
		p.LeftHandSide()
	}
	{
		p.SetState(2740)
		p.AssignmentOperator()
	}
	{
		p.SetState(2741)
		p.Expression()
	}

	return localctx
}

// ILeftHandSideContext is an interface to support dynamic dispatch.
type ILeftHandSideContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLeftHandSideContext differentiates from other interfaces.
	IsLeftHandSideContext()
}

type LeftHandSideContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLeftHandSideContext() *LeftHandSideContext {
	var p = new(LeftHandSideContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Java9ParserRULE_leftHandSide
	return p
}

func (*LeftHandSideContext) IsLeftHandSideContext() {}

func NewLeftHandSideContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LeftHandSideContext {
	var p = new(LeftHandSideContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java9ParserRULE_leftHandSide

	return p
}

func (s *LeftHandSideContext) GetParser() antlr.Parser { return s.parser }

func (s *LeftHandSideContext) ExpressionName() IExpressionNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionNameContext)
}

func (s *LeftHandSideContext) FieldAccess() IFieldAccessContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFieldAccessContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFieldAccessContext)
}

func (s *LeftHandSideContext) ArrayAccess() IArrayAccessContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IArrayAccessContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IArrayAccessContext)
}

func (s *LeftHandSideContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LeftHandSideContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LeftHandSideContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.EnterLeftHandSide(s)
	}
}

func (s *LeftHandSideContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.ExitLeftHandSide(s)
	}
}

func (p *Java9Parser) LeftHandSide() (localctx ILeftHandSideContext) {
	localctx = NewLeftHandSideContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 442, Java9ParserRULE_leftHandSide)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(2746)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 314, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2743)
			p.ExpressionName()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2744)
			p.FieldAccess()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2745)
			p.ArrayAccess()
		}

	}

	return localctx
}

// IAssignmentOperatorContext is an interface to support dynamic dispatch.
type IAssignmentOperatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAssignmentOperatorContext differentiates from other interfaces.
	IsAssignmentOperatorContext()
}

type AssignmentOperatorContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAssignmentOperatorContext() *AssignmentOperatorContext {
	var p = new(AssignmentOperatorContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Java9ParserRULE_assignmentOperator
	return p
}

func (*AssignmentOperatorContext) IsAssignmentOperatorContext() {}

func NewAssignmentOperatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AssignmentOperatorContext {
	var p = new(AssignmentOperatorContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java9ParserRULE_assignmentOperator

	return p
}

func (s *AssignmentOperatorContext) GetParser() antlr.Parser { return s.parser }

func (s *AssignmentOperatorContext) ASSIGN() antlr.TerminalNode {
	return s.GetToken(Java9ParserASSIGN, 0)
}

func (s *AssignmentOperatorContext) MUL_ASSIGN() antlr.TerminalNode {
	return s.GetToken(Java9ParserMUL_ASSIGN, 0)
}

func (s *AssignmentOperatorContext) DIV_ASSIGN() antlr.TerminalNode {
	return s.GetToken(Java9ParserDIV_ASSIGN, 0)
}

func (s *AssignmentOperatorContext) MOD_ASSIGN() antlr.TerminalNode {
	return s.GetToken(Java9ParserMOD_ASSIGN, 0)
}

func (s *AssignmentOperatorContext) ADD_ASSIGN() antlr.TerminalNode {
	return s.GetToken(Java9ParserADD_ASSIGN, 0)
}

func (s *AssignmentOperatorContext) SUB_ASSIGN() antlr.TerminalNode {
	return s.GetToken(Java9ParserSUB_ASSIGN, 0)
}

func (s *AssignmentOperatorContext) LSHIFT_ASSIGN() antlr.TerminalNode {
	return s.GetToken(Java9ParserLSHIFT_ASSIGN, 0)
}

func (s *AssignmentOperatorContext) RSHIFT_ASSIGN() antlr.TerminalNode {
	return s.GetToken(Java9ParserRSHIFT_ASSIGN, 0)
}

func (s *AssignmentOperatorContext) URSHIFT_ASSIGN() antlr.TerminalNode {
	return s.GetToken(Java9ParserURSHIFT_ASSIGN, 0)
}

func (s *AssignmentOperatorContext) AND_ASSIGN() antlr.TerminalNode {
	return s.GetToken(Java9ParserAND_ASSIGN, 0)
}

func (s *AssignmentOperatorContext) XOR_ASSIGN() antlr.TerminalNode {
	return s.GetToken(Java9ParserXOR_ASSIGN, 0)
}

func (s *AssignmentOperatorContext) OR_ASSIGN() antlr.TerminalNode {
	return s.GetToken(Java9ParserOR_ASSIGN, 0)
}

func (s *AssignmentOperatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AssignmentOperatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AssignmentOperatorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.EnterAssignmentOperator(s)
	}
}

func (s *AssignmentOperatorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.ExitAssignmentOperator(s)
	}
}

func (p *Java9Parser) AssignmentOperator() (localctx IAssignmentOperatorContext) {
	localctx = NewAssignmentOperatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 444, Java9ParserRULE_assignmentOperator)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2748)
		_la = p.GetTokenStream().LA(1)

		if !((((_la-80)&-(0x1f+1)) == 0 && ((1<<uint((_la-80)))&((1<<(Java9ParserASSIGN-80))|(1<<(Java9ParserADD_ASSIGN-80))|(1<<(Java9ParserSUB_ASSIGN-80))|(1<<(Java9ParserMUL_ASSIGN-80))|(1<<(Java9ParserDIV_ASSIGN-80))|(1<<(Java9ParserAND_ASSIGN-80))|(1<<(Java9ParserOR_ASSIGN-80))|(1<<(Java9ParserXOR_ASSIGN-80))|(1<<(Java9ParserMOD_ASSIGN-80)))) != 0) || (((_la-112)&-(0x1f+1)) == 0 && ((1<<uint((_la-112)))&((1<<(Java9ParserLSHIFT_ASSIGN-112))|(1<<(Java9ParserRSHIFT_ASSIGN-112))|(1<<(Java9ParserURSHIFT_ASSIGN-112)))) != 0)) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IConditionalExpressionContext is an interface to support dynamic dispatch.
type IConditionalExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsConditionalExpressionContext differentiates from other interfaces.
	IsConditionalExpressionContext()
}

type ConditionalExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConditionalExpressionContext() *ConditionalExpressionContext {
	var p = new(ConditionalExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Java9ParserRULE_conditionalExpression
	return p
}

func (*ConditionalExpressionContext) IsConditionalExpressionContext() {}

func NewConditionalExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ConditionalExpressionContext {
	var p = new(ConditionalExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java9ParserRULE_conditionalExpression

	return p
}

func (s *ConditionalExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *ConditionalExpressionContext) ConditionalOrExpression() IConditionalOrExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConditionalOrExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConditionalOrExpressionContext)
}

func (s *ConditionalExpressionContext) QUESTION() antlr.TerminalNode {
	return s.GetToken(Java9ParserQUESTION, 0)
}

func (s *ConditionalExpressionContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ConditionalExpressionContext) COLON() antlr.TerminalNode {
	return s.GetToken(Java9ParserCOLON, 0)
}

func (s *ConditionalExpressionContext) ConditionalExpression() IConditionalExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConditionalExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConditionalExpressionContext)
}

func (s *ConditionalExpressionContext) LambdaExpression() ILambdaExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILambdaExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILambdaExpressionContext)
}

func (s *ConditionalExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ConditionalExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ConditionalExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.EnterConditionalExpression(s)
	}
}

func (s *ConditionalExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.ExitConditionalExpression(s)
	}
}

func (p *Java9Parser) ConditionalExpression() (localctx IConditionalExpressionContext) {
	localctx = NewConditionalExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 446, Java9ParserRULE_conditionalExpression)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(2759)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 316, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2750)
			p.conditionalOrExpression(0)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2751)
			p.conditionalOrExpression(0)
		}
		{
			p.SetState(2752)
			p.Match(Java9ParserQUESTION)
		}
		{
			p.SetState(2753)
			p.Expression()
		}
		{
			p.SetState(2754)
			p.Match(Java9ParserCOLON)
		}
		p.SetState(2757)
		p.GetErrorHandler().Sync(p)
		switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 315, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(2755)
				p.ConditionalExpression()
			}

		case 2:
			{
				p.SetState(2756)
				p.LambdaExpression()
			}

		}

	}

	return localctx
}

// IConditionalOrExpressionContext is an interface to support dynamic dispatch.
type IConditionalOrExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsConditionalOrExpressionContext differentiates from other interfaces.
	IsConditionalOrExpressionContext()
}

type ConditionalOrExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConditionalOrExpressionContext() *ConditionalOrExpressionContext {
	var p = new(ConditionalOrExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Java9ParserRULE_conditionalOrExpression
	return p
}

func (*ConditionalOrExpressionContext) IsConditionalOrExpressionContext() {}

func NewConditionalOrExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ConditionalOrExpressionContext {
	var p = new(ConditionalOrExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java9ParserRULE_conditionalOrExpression

	return p
}

func (s *ConditionalOrExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *ConditionalOrExpressionContext) ConditionalAndExpression() IConditionalAndExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConditionalAndExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConditionalAndExpressionContext)
}

func (s *ConditionalOrExpressionContext) ConditionalOrExpression() IConditionalOrExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConditionalOrExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConditionalOrExpressionContext)
}

func (s *ConditionalOrExpressionContext) OR() antlr.TerminalNode {
	return s.GetToken(Java9ParserOR, 0)
}

func (s *ConditionalOrExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ConditionalOrExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ConditionalOrExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.EnterConditionalOrExpression(s)
	}
}

func (s *ConditionalOrExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.ExitConditionalOrExpression(s)
	}
}

func (p *Java9Parser) ConditionalOrExpression() (localctx IConditionalOrExpressionContext) {
	return p.conditionalOrExpression(0)
}

func (p *Java9Parser) conditionalOrExpression(_p int) (localctx IConditionalOrExpressionContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()
	_parentState := p.GetState()
	localctx = NewConditionalOrExpressionContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IConditionalOrExpressionContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 448
	p.EnterRecursionRule(localctx, 448, Java9ParserRULE_conditionalOrExpression, _p)

	defer func() {
		p.UnrollRecursionContexts(_parentctx)
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2762)
		p.conditionalAndExpression(0)
	}

	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(2769)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 317, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			localctx = NewConditionalOrExpressionContext(p, _parentctx, _parentState)
			p.PushNewRecursionContext(localctx, _startState, Java9ParserRULE_conditionalOrExpression)
			p.SetState(2764)

			if !(p.Precpred(p.GetParserRuleContext(), 1)) {
				panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 1)", ""))
			}
			{
				p.SetState(2765)
				p.Match(Java9ParserOR)
			}
			{
				p.SetState(2766)
				p.conditionalAndExpression(0)
			}

		}
		p.SetState(2771)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 317, p.GetParserRuleContext())
	}

	return localctx
}

// IConditionalAndExpressionContext is an interface to support dynamic dispatch.
type IConditionalAndExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsConditionalAndExpressionContext differentiates from other interfaces.
	IsConditionalAndExpressionContext()
}

type ConditionalAndExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConditionalAndExpressionContext() *ConditionalAndExpressionContext {
	var p = new(ConditionalAndExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Java9ParserRULE_conditionalAndExpression
	return p
}

func (*ConditionalAndExpressionContext) IsConditionalAndExpressionContext() {}

func NewConditionalAndExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ConditionalAndExpressionContext {
	var p = new(ConditionalAndExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java9ParserRULE_conditionalAndExpression

	return p
}

func (s *ConditionalAndExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *ConditionalAndExpressionContext) InclusiveOrExpression() IInclusiveOrExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInclusiveOrExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInclusiveOrExpressionContext)
}

func (s *ConditionalAndExpressionContext) ConditionalAndExpression() IConditionalAndExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConditionalAndExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConditionalAndExpressionContext)
}

func (s *ConditionalAndExpressionContext) AND() antlr.TerminalNode {
	return s.GetToken(Java9ParserAND, 0)
}

func (s *ConditionalAndExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ConditionalAndExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ConditionalAndExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.EnterConditionalAndExpression(s)
	}
}

func (s *ConditionalAndExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.ExitConditionalAndExpression(s)
	}
}

func (p *Java9Parser) ConditionalAndExpression() (localctx IConditionalAndExpressionContext) {
	return p.conditionalAndExpression(0)
}

func (p *Java9Parser) conditionalAndExpression(_p int) (localctx IConditionalAndExpressionContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()
	_parentState := p.GetState()
	localctx = NewConditionalAndExpressionContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IConditionalAndExpressionContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 450
	p.EnterRecursionRule(localctx, 450, Java9ParserRULE_conditionalAndExpression, _p)

	defer func() {
		p.UnrollRecursionContexts(_parentctx)
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2773)
		p.inclusiveOrExpression(0)
	}

	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(2780)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 318, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			localctx = NewConditionalAndExpressionContext(p, _parentctx, _parentState)
			p.PushNewRecursionContext(localctx, _startState, Java9ParserRULE_conditionalAndExpression)
			p.SetState(2775)

			if !(p.Precpred(p.GetParserRuleContext(), 1)) {
				panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 1)", ""))
			}
			{
				p.SetState(2776)
				p.Match(Java9ParserAND)
			}
			{
				p.SetState(2777)
				p.inclusiveOrExpression(0)
			}

		}
		p.SetState(2782)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 318, p.GetParserRuleContext())
	}

	return localctx
}

// IInclusiveOrExpressionContext is an interface to support dynamic dispatch.
type IInclusiveOrExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsInclusiveOrExpressionContext differentiates from other interfaces.
	IsInclusiveOrExpressionContext()
}

type InclusiveOrExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInclusiveOrExpressionContext() *InclusiveOrExpressionContext {
	var p = new(InclusiveOrExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Java9ParserRULE_inclusiveOrExpression
	return p
}

func (*InclusiveOrExpressionContext) IsInclusiveOrExpressionContext() {}

func NewInclusiveOrExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InclusiveOrExpressionContext {
	var p = new(InclusiveOrExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java9ParserRULE_inclusiveOrExpression

	return p
}

func (s *InclusiveOrExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *InclusiveOrExpressionContext) ExclusiveOrExpression() IExclusiveOrExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExclusiveOrExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExclusiveOrExpressionContext)
}

func (s *InclusiveOrExpressionContext) InclusiveOrExpression() IInclusiveOrExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInclusiveOrExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInclusiveOrExpressionContext)
}

func (s *InclusiveOrExpressionContext) BITOR() antlr.TerminalNode {
	return s.GetToken(Java9ParserBITOR, 0)
}

func (s *InclusiveOrExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InclusiveOrExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InclusiveOrExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.EnterInclusiveOrExpression(s)
	}
}

func (s *InclusiveOrExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.ExitInclusiveOrExpression(s)
	}
}

func (p *Java9Parser) InclusiveOrExpression() (localctx IInclusiveOrExpressionContext) {
	return p.inclusiveOrExpression(0)
}

func (p *Java9Parser) inclusiveOrExpression(_p int) (localctx IInclusiveOrExpressionContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()
	_parentState := p.GetState()
	localctx = NewInclusiveOrExpressionContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IInclusiveOrExpressionContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 452
	p.EnterRecursionRule(localctx, 452, Java9ParserRULE_inclusiveOrExpression, _p)

	defer func() {
		p.UnrollRecursionContexts(_parentctx)
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2784)
		p.exclusiveOrExpression(0)
	}

	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(2791)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 319, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			localctx = NewInclusiveOrExpressionContext(p, _parentctx, _parentState)
			p.PushNewRecursionContext(localctx, _startState, Java9ParserRULE_inclusiveOrExpression)
			p.SetState(2786)

			if !(p.Precpred(p.GetParserRuleContext(), 1)) {
				panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 1)", ""))
			}
			{
				p.SetState(2787)
				p.Match(Java9ParserBITOR)
			}
			{
				p.SetState(2788)
				p.exclusiveOrExpression(0)
			}

		}
		p.SetState(2793)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 319, p.GetParserRuleContext())
	}

	return localctx
}

// IExclusiveOrExpressionContext is an interface to support dynamic dispatch.
type IExclusiveOrExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExclusiveOrExpressionContext differentiates from other interfaces.
	IsExclusiveOrExpressionContext()
}

type ExclusiveOrExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExclusiveOrExpressionContext() *ExclusiveOrExpressionContext {
	var p = new(ExclusiveOrExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Java9ParserRULE_exclusiveOrExpression
	return p
}

func (*ExclusiveOrExpressionContext) IsExclusiveOrExpressionContext() {}

func NewExclusiveOrExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExclusiveOrExpressionContext {
	var p = new(ExclusiveOrExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java9ParserRULE_exclusiveOrExpression

	return p
}

func (s *ExclusiveOrExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *ExclusiveOrExpressionContext) AndExpression() IAndExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAndExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAndExpressionContext)
}

func (s *ExclusiveOrExpressionContext) ExclusiveOrExpression() IExclusiveOrExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExclusiveOrExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExclusiveOrExpressionContext)
}

func (s *ExclusiveOrExpressionContext) CARET() antlr.TerminalNode {
	return s.GetToken(Java9ParserCARET, 0)
}

func (s *ExclusiveOrExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExclusiveOrExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExclusiveOrExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.EnterExclusiveOrExpression(s)
	}
}

func (s *ExclusiveOrExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.ExitExclusiveOrExpression(s)
	}
}

func (p *Java9Parser) ExclusiveOrExpression() (localctx IExclusiveOrExpressionContext) {
	return p.exclusiveOrExpression(0)
}

func (p *Java9Parser) exclusiveOrExpression(_p int) (localctx IExclusiveOrExpressionContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()
	_parentState := p.GetState()
	localctx = NewExclusiveOrExpressionContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IExclusiveOrExpressionContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 454
	p.EnterRecursionRule(localctx, 454, Java9ParserRULE_exclusiveOrExpression, _p)

	defer func() {
		p.UnrollRecursionContexts(_parentctx)
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2795)
		p.andExpression(0)
	}

	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(2802)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 320, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			localctx = NewExclusiveOrExpressionContext(p, _parentctx, _parentState)
			p.PushNewRecursionContext(localctx, _startState, Java9ParserRULE_exclusiveOrExpression)
			p.SetState(2797)

			if !(p.Precpred(p.GetParserRuleContext(), 1)) {
				panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 1)", ""))
			}
			{
				p.SetState(2798)
				p.Match(Java9ParserCARET)
			}
			{
				p.SetState(2799)
				p.andExpression(0)
			}

		}
		p.SetState(2804)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 320, p.GetParserRuleContext())
	}

	return localctx
}

// IAndExpressionContext is an interface to support dynamic dispatch.
type IAndExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAndExpressionContext differentiates from other interfaces.
	IsAndExpressionContext()
}

type AndExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAndExpressionContext() *AndExpressionContext {
	var p = new(AndExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Java9ParserRULE_andExpression
	return p
}

func (*AndExpressionContext) IsAndExpressionContext() {}

func NewAndExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AndExpressionContext {
	var p = new(AndExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java9ParserRULE_andExpression

	return p
}

func (s *AndExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *AndExpressionContext) EqualityExpression() IEqualityExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEqualityExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEqualityExpressionContext)
}

func (s *AndExpressionContext) AndExpression() IAndExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAndExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAndExpressionContext)
}

func (s *AndExpressionContext) BITAND() antlr.TerminalNode {
	return s.GetToken(Java9ParserBITAND, 0)
}

func (s *AndExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AndExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AndExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.EnterAndExpression(s)
	}
}

func (s *AndExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.ExitAndExpression(s)
	}
}

func (p *Java9Parser) AndExpression() (localctx IAndExpressionContext) {
	return p.andExpression(0)
}

func (p *Java9Parser) andExpression(_p int) (localctx IAndExpressionContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()
	_parentState := p.GetState()
	localctx = NewAndExpressionContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IAndExpressionContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 456
	p.EnterRecursionRule(localctx, 456, Java9ParserRULE_andExpression, _p)

	defer func() {
		p.UnrollRecursionContexts(_parentctx)
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2806)
		p.equalityExpression(0)
	}

	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(2813)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 321, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			localctx = NewAndExpressionContext(p, _parentctx, _parentState)
			p.PushNewRecursionContext(localctx, _startState, Java9ParserRULE_andExpression)
			p.SetState(2808)

			if !(p.Precpred(p.GetParserRuleContext(), 1)) {
				panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 1)", ""))
			}
			{
				p.SetState(2809)
				p.Match(Java9ParserBITAND)
			}
			{
				p.SetState(2810)
				p.equalityExpression(0)
			}

		}
		p.SetState(2815)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 321, p.GetParserRuleContext())
	}

	return localctx
}

// IEqualityExpressionContext is an interface to support dynamic dispatch.
type IEqualityExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEqualityExpressionContext differentiates from other interfaces.
	IsEqualityExpressionContext()
}

type EqualityExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEqualityExpressionContext() *EqualityExpressionContext {
	var p = new(EqualityExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Java9ParserRULE_equalityExpression
	return p
}

func (*EqualityExpressionContext) IsEqualityExpressionContext() {}

func NewEqualityExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EqualityExpressionContext {
	var p = new(EqualityExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java9ParserRULE_equalityExpression

	return p
}

func (s *EqualityExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *EqualityExpressionContext) RelationalExpression() IRelationalExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRelationalExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRelationalExpressionContext)
}

func (s *EqualityExpressionContext) EqualityExpression() IEqualityExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEqualityExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEqualityExpressionContext)
}

func (s *EqualityExpressionContext) EQUAL() antlr.TerminalNode {
	return s.GetToken(Java9ParserEQUAL, 0)
}

func (s *EqualityExpressionContext) NOTEQUAL() antlr.TerminalNode {
	return s.GetToken(Java9ParserNOTEQUAL, 0)
}

func (s *EqualityExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EqualityExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EqualityExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.EnterEqualityExpression(s)
	}
}

func (s *EqualityExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.ExitEqualityExpression(s)
	}
}

func (p *Java9Parser) EqualityExpression() (localctx IEqualityExpressionContext) {
	return p.equalityExpression(0)
}

func (p *Java9Parser) equalityExpression(_p int) (localctx IEqualityExpressionContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()
	_parentState := p.GetState()
	localctx = NewEqualityExpressionContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IEqualityExpressionContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 458
	p.EnterRecursionRule(localctx, 458, Java9ParserRULE_equalityExpression, _p)

	defer func() {
		p.UnrollRecursionContexts(_parentctx)
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2817)
		p.relationalExpression(0)
	}

	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(2827)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 323, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			p.SetState(2825)
			p.GetErrorHandler().Sync(p)
			switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 322, p.GetParserRuleContext()) {
			case 1:
				localctx = NewEqualityExpressionContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, Java9ParserRULE_equalityExpression)
				p.SetState(2819)

				if !(p.Precpred(p.GetParserRuleContext(), 2)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 2)", ""))
				}
				{
					p.SetState(2820)
					p.Match(Java9ParserEQUAL)
				}
				{
					p.SetState(2821)
					p.relationalExpression(0)
				}

			case 2:
				localctx = NewEqualityExpressionContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, Java9ParserRULE_equalityExpression)
				p.SetState(2822)

				if !(p.Precpred(p.GetParserRuleContext(), 1)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 1)", ""))
				}
				{
					p.SetState(2823)
					p.Match(Java9ParserNOTEQUAL)
				}
				{
					p.SetState(2824)
					p.relationalExpression(0)
				}

			}

		}
		p.SetState(2829)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 323, p.GetParserRuleContext())
	}

	return localctx
}

// IRelationalExpressionContext is an interface to support dynamic dispatch.
type IRelationalExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRelationalExpressionContext differentiates from other interfaces.
	IsRelationalExpressionContext()
}

type RelationalExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRelationalExpressionContext() *RelationalExpressionContext {
	var p = new(RelationalExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Java9ParserRULE_relationalExpression
	return p
}

func (*RelationalExpressionContext) IsRelationalExpressionContext() {}

func NewRelationalExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RelationalExpressionContext {
	var p = new(RelationalExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java9ParserRULE_relationalExpression

	return p
}

func (s *RelationalExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *RelationalExpressionContext) ShiftExpression() IShiftExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IShiftExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IShiftExpressionContext)
}

func (s *RelationalExpressionContext) RelationalExpression() IRelationalExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRelationalExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRelationalExpressionContext)
}

func (s *RelationalExpressionContext) LT() antlr.TerminalNode {
	return s.GetToken(Java9ParserLT, 0)
}

func (s *RelationalExpressionContext) GT() antlr.TerminalNode {
	return s.GetToken(Java9ParserGT, 0)
}

func (s *RelationalExpressionContext) LE() antlr.TerminalNode {
	return s.GetToken(Java9ParserLE, 0)
}

func (s *RelationalExpressionContext) GE() antlr.TerminalNode {
	return s.GetToken(Java9ParserGE, 0)
}

func (s *RelationalExpressionContext) INSTANCEOF() antlr.TerminalNode {
	return s.GetToken(Java9ParserINSTANCEOF, 0)
}

func (s *RelationalExpressionContext) ReferenceType() IReferenceTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IReferenceTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IReferenceTypeContext)
}

func (s *RelationalExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RelationalExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RelationalExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.EnterRelationalExpression(s)
	}
}

func (s *RelationalExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.ExitRelationalExpression(s)
	}
}

func (p *Java9Parser) RelationalExpression() (localctx IRelationalExpressionContext) {
	return p.relationalExpression(0)
}

func (p *Java9Parser) relationalExpression(_p int) (localctx IRelationalExpressionContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()
	_parentState := p.GetState()
	localctx = NewRelationalExpressionContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IRelationalExpressionContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 460
	p.EnterRecursionRule(localctx, 460, Java9ParserRULE_relationalExpression, _p)

	defer func() {
		p.UnrollRecursionContexts(_parentctx)
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2831)
		p.shiftExpression(0)
	}

	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(2850)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 325, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			p.SetState(2848)
			p.GetErrorHandler().Sync(p)
			switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 324, p.GetParserRuleContext()) {
			case 1:
				localctx = NewRelationalExpressionContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, Java9ParserRULE_relationalExpression)
				p.SetState(2833)

				if !(p.Precpred(p.GetParserRuleContext(), 5)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 5)", ""))
				}
				{
					p.SetState(2834)
					p.Match(Java9ParserLT)
				}
				{
					p.SetState(2835)
					p.shiftExpression(0)
				}

			case 2:
				localctx = NewRelationalExpressionContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, Java9ParserRULE_relationalExpression)
				p.SetState(2836)

				if !(p.Precpred(p.GetParserRuleContext(), 4)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 4)", ""))
				}
				{
					p.SetState(2837)
					p.Match(Java9ParserGT)
				}
				{
					p.SetState(2838)
					p.shiftExpression(0)
				}

			case 3:
				localctx = NewRelationalExpressionContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, Java9ParserRULE_relationalExpression)
				p.SetState(2839)

				if !(p.Precpred(p.GetParserRuleContext(), 3)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 3)", ""))
				}
				{
					p.SetState(2840)
					p.Match(Java9ParserLE)
				}
				{
					p.SetState(2841)
					p.shiftExpression(0)
				}

			case 4:
				localctx = NewRelationalExpressionContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, Java9ParserRULE_relationalExpression)
				p.SetState(2842)

				if !(p.Precpred(p.GetParserRuleContext(), 2)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 2)", ""))
				}
				{
					p.SetState(2843)
					p.Match(Java9ParserGE)
				}
				{
					p.SetState(2844)
					p.shiftExpression(0)
				}

			case 5:
				localctx = NewRelationalExpressionContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, Java9ParserRULE_relationalExpression)
				p.SetState(2845)

				if !(p.Precpred(p.GetParserRuleContext(), 1)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 1)", ""))
				}
				{
					p.SetState(2846)
					p.Match(Java9ParserINSTANCEOF)
				}
				{
					p.SetState(2847)
					p.ReferenceType()
				}

			}

		}
		p.SetState(2852)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 325, p.GetParserRuleContext())
	}

	return localctx
}

// IShiftExpressionContext is an interface to support dynamic dispatch.
type IShiftExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsShiftExpressionContext differentiates from other interfaces.
	IsShiftExpressionContext()
}

type ShiftExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyShiftExpressionContext() *ShiftExpressionContext {
	var p = new(ShiftExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Java9ParserRULE_shiftExpression
	return p
}

func (*ShiftExpressionContext) IsShiftExpressionContext() {}

func NewShiftExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ShiftExpressionContext {
	var p = new(ShiftExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java9ParserRULE_shiftExpression

	return p
}

func (s *ShiftExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *ShiftExpressionContext) AdditiveExpression() IAdditiveExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAdditiveExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAdditiveExpressionContext)
}

func (s *ShiftExpressionContext) ShiftExpression() IShiftExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IShiftExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IShiftExpressionContext)
}

func (s *ShiftExpressionContext) AllLT() []antlr.TerminalNode {
	return s.GetTokens(Java9ParserLT)
}

func (s *ShiftExpressionContext) LT(i int) antlr.TerminalNode {
	return s.GetToken(Java9ParserLT, i)
}

func (s *ShiftExpressionContext) AllGT() []antlr.TerminalNode {
	return s.GetTokens(Java9ParserGT)
}

func (s *ShiftExpressionContext) GT(i int) antlr.TerminalNode {
	return s.GetToken(Java9ParserGT, i)
}

func (s *ShiftExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShiftExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ShiftExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.EnterShiftExpression(s)
	}
}

func (s *ShiftExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.ExitShiftExpression(s)
	}
}

func (p *Java9Parser) ShiftExpression() (localctx IShiftExpressionContext) {
	return p.shiftExpression(0)
}

func (p *Java9Parser) shiftExpression(_p int) (localctx IShiftExpressionContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()
	_parentState := p.GetState()
	localctx = NewShiftExpressionContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IShiftExpressionContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 462
	p.EnterRecursionRule(localctx, 462, Java9ParserRULE_shiftExpression, _p)

	defer func() {
		p.UnrollRecursionContexts(_parentctx)
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2854)
		p.additiveExpression(0)
	}

	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(2871)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 327, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			p.SetState(2869)
			p.GetErrorHandler().Sync(p)
			switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 326, p.GetParserRuleContext()) {
			case 1:
				localctx = NewShiftExpressionContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, Java9ParserRULE_shiftExpression)
				p.SetState(2856)

				if !(p.Precpred(p.GetParserRuleContext(), 3)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 3)", ""))
				}
				{
					p.SetState(2857)
					p.Match(Java9ParserLT)
				}
				{
					p.SetState(2858)
					p.Match(Java9ParserLT)
				}
				{
					p.SetState(2859)
					p.additiveExpression(0)
				}

			case 2:
				localctx = NewShiftExpressionContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, Java9ParserRULE_shiftExpression)
				p.SetState(2860)

				if !(p.Precpred(p.GetParserRuleContext(), 2)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 2)", ""))
				}
				{
					p.SetState(2861)
					p.Match(Java9ParserGT)
				}
				{
					p.SetState(2862)
					p.Match(Java9ParserGT)
				}
				{
					p.SetState(2863)
					p.additiveExpression(0)
				}

			case 3:
				localctx = NewShiftExpressionContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, Java9ParserRULE_shiftExpression)
				p.SetState(2864)

				if !(p.Precpred(p.GetParserRuleContext(), 1)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 1)", ""))
				}
				{
					p.SetState(2865)
					p.Match(Java9ParserGT)
				}
				{
					p.SetState(2866)
					p.Match(Java9ParserGT)
				}
				{
					p.SetState(2867)
					p.Match(Java9ParserGT)
				}
				{
					p.SetState(2868)
					p.additiveExpression(0)
				}

			}

		}
		p.SetState(2873)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 327, p.GetParserRuleContext())
	}

	return localctx
}

// IAdditiveExpressionContext is an interface to support dynamic dispatch.
type IAdditiveExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAdditiveExpressionContext differentiates from other interfaces.
	IsAdditiveExpressionContext()
}

type AdditiveExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAdditiveExpressionContext() *AdditiveExpressionContext {
	var p = new(AdditiveExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Java9ParserRULE_additiveExpression
	return p
}

func (*AdditiveExpressionContext) IsAdditiveExpressionContext() {}

func NewAdditiveExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AdditiveExpressionContext {
	var p = new(AdditiveExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java9ParserRULE_additiveExpression

	return p
}

func (s *AdditiveExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *AdditiveExpressionContext) MultiplicativeExpression() IMultiplicativeExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMultiplicativeExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMultiplicativeExpressionContext)
}

func (s *AdditiveExpressionContext) AdditiveExpression() IAdditiveExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAdditiveExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAdditiveExpressionContext)
}

func (s *AdditiveExpressionContext) ADD() antlr.TerminalNode {
	return s.GetToken(Java9ParserADD, 0)
}

func (s *AdditiveExpressionContext) SUB() antlr.TerminalNode {
	return s.GetToken(Java9ParserSUB, 0)
}

func (s *AdditiveExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AdditiveExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AdditiveExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.EnterAdditiveExpression(s)
	}
}

func (s *AdditiveExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.ExitAdditiveExpression(s)
	}
}

func (p *Java9Parser) AdditiveExpression() (localctx IAdditiveExpressionContext) {
	return p.additiveExpression(0)
}

func (p *Java9Parser) additiveExpression(_p int) (localctx IAdditiveExpressionContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()
	_parentState := p.GetState()
	localctx = NewAdditiveExpressionContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IAdditiveExpressionContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 464
	p.EnterRecursionRule(localctx, 464, Java9ParserRULE_additiveExpression, _p)

	defer func() {
		p.UnrollRecursionContexts(_parentctx)
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2875)
		p.multiplicativeExpression(0)
	}

	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(2885)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 329, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			p.SetState(2883)
			p.GetErrorHandler().Sync(p)
			switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 328, p.GetParserRuleContext()) {
			case 1:
				localctx = NewAdditiveExpressionContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, Java9ParserRULE_additiveExpression)
				p.SetState(2877)

				if !(p.Precpred(p.GetParserRuleContext(), 2)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 2)", ""))
				}
				{
					p.SetState(2878)
					p.Match(Java9ParserADD)
				}
				{
					p.SetState(2879)
					p.multiplicativeExpression(0)
				}

			case 2:
				localctx = NewAdditiveExpressionContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, Java9ParserRULE_additiveExpression)
				p.SetState(2880)

				if !(p.Precpred(p.GetParserRuleContext(), 1)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 1)", ""))
				}
				{
					p.SetState(2881)
					p.Match(Java9ParserSUB)
				}
				{
					p.SetState(2882)
					p.multiplicativeExpression(0)
				}

			}

		}
		p.SetState(2887)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 329, p.GetParserRuleContext())
	}

	return localctx
}

// IMultiplicativeExpressionContext is an interface to support dynamic dispatch.
type IMultiplicativeExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMultiplicativeExpressionContext differentiates from other interfaces.
	IsMultiplicativeExpressionContext()
}

type MultiplicativeExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMultiplicativeExpressionContext() *MultiplicativeExpressionContext {
	var p = new(MultiplicativeExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Java9ParserRULE_multiplicativeExpression
	return p
}

func (*MultiplicativeExpressionContext) IsMultiplicativeExpressionContext() {}

func NewMultiplicativeExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MultiplicativeExpressionContext {
	var p = new(MultiplicativeExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java9ParserRULE_multiplicativeExpression

	return p
}

func (s *MultiplicativeExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *MultiplicativeExpressionContext) UnaryExpression() IUnaryExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUnaryExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IUnaryExpressionContext)
}

func (s *MultiplicativeExpressionContext) MultiplicativeExpression() IMultiplicativeExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMultiplicativeExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMultiplicativeExpressionContext)
}

func (s *MultiplicativeExpressionContext) MUL() antlr.TerminalNode {
	return s.GetToken(Java9ParserMUL, 0)
}

func (s *MultiplicativeExpressionContext) DIV() antlr.TerminalNode {
	return s.GetToken(Java9ParserDIV, 0)
}

func (s *MultiplicativeExpressionContext) MOD() antlr.TerminalNode {
	return s.GetToken(Java9ParserMOD, 0)
}

func (s *MultiplicativeExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MultiplicativeExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MultiplicativeExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.EnterMultiplicativeExpression(s)
	}
}

func (s *MultiplicativeExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.ExitMultiplicativeExpression(s)
	}
}

func (p *Java9Parser) MultiplicativeExpression() (localctx IMultiplicativeExpressionContext) {
	return p.multiplicativeExpression(0)
}

func (p *Java9Parser) multiplicativeExpression(_p int) (localctx IMultiplicativeExpressionContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()
	_parentState := p.GetState()
	localctx = NewMultiplicativeExpressionContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IMultiplicativeExpressionContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 466
	p.EnterRecursionRule(localctx, 466, Java9ParserRULE_multiplicativeExpression, _p)

	defer func() {
		p.UnrollRecursionContexts(_parentctx)
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2889)
		p.UnaryExpression()
	}

	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(2902)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 331, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			p.SetState(2900)
			p.GetErrorHandler().Sync(p)
			switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 330, p.GetParserRuleContext()) {
			case 1:
				localctx = NewMultiplicativeExpressionContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, Java9ParserRULE_multiplicativeExpression)
				p.SetState(2891)

				if !(p.Precpred(p.GetParserRuleContext(), 3)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 3)", ""))
				}
				{
					p.SetState(2892)
					p.Match(Java9ParserMUL)
				}
				{
					p.SetState(2893)
					p.UnaryExpression()
				}

			case 2:
				localctx = NewMultiplicativeExpressionContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, Java9ParserRULE_multiplicativeExpression)
				p.SetState(2894)

				if !(p.Precpred(p.GetParserRuleContext(), 2)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 2)", ""))
				}
				{
					p.SetState(2895)
					p.Match(Java9ParserDIV)
				}
				{
					p.SetState(2896)
					p.UnaryExpression()
				}

			case 3:
				localctx = NewMultiplicativeExpressionContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, Java9ParserRULE_multiplicativeExpression)
				p.SetState(2897)

				if !(p.Precpred(p.GetParserRuleContext(), 1)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 1)", ""))
				}
				{
					p.SetState(2898)
					p.Match(Java9ParserMOD)
				}
				{
					p.SetState(2899)
					p.UnaryExpression()
				}

			}

		}
		p.SetState(2904)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 331, p.GetParserRuleContext())
	}

	return localctx
}

// IUnaryExpressionContext is an interface to support dynamic dispatch.
type IUnaryExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsUnaryExpressionContext differentiates from other interfaces.
	IsUnaryExpressionContext()
}

type UnaryExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUnaryExpressionContext() *UnaryExpressionContext {
	var p = new(UnaryExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Java9ParserRULE_unaryExpression
	return p
}

func (*UnaryExpressionContext) IsUnaryExpressionContext() {}

func NewUnaryExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UnaryExpressionContext {
	var p = new(UnaryExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java9ParserRULE_unaryExpression

	return p
}

func (s *UnaryExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *UnaryExpressionContext) PreIncrementExpression() IPreIncrementExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPreIncrementExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPreIncrementExpressionContext)
}

func (s *UnaryExpressionContext) PreDecrementExpression() IPreDecrementExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPreDecrementExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPreDecrementExpressionContext)
}

func (s *UnaryExpressionContext) ADD() antlr.TerminalNode {
	return s.GetToken(Java9ParserADD, 0)
}

func (s *UnaryExpressionContext) UnaryExpression() IUnaryExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUnaryExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IUnaryExpressionContext)
}

func (s *UnaryExpressionContext) SUB() antlr.TerminalNode {
	return s.GetToken(Java9ParserSUB, 0)
}

func (s *UnaryExpressionContext) UnaryExpressionNotPlusMinus() IUnaryExpressionNotPlusMinusContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUnaryExpressionNotPlusMinusContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IUnaryExpressionNotPlusMinusContext)
}

func (s *UnaryExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnaryExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UnaryExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.EnterUnaryExpression(s)
	}
}

func (s *UnaryExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.ExitUnaryExpression(s)
	}
}

func (p *Java9Parser) UnaryExpression() (localctx IUnaryExpressionContext) {
	localctx = NewUnaryExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 468, Java9ParserRULE_unaryExpression)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(2912)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case Java9ParserINC:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2905)
			p.PreIncrementExpression()
		}

	case Java9ParserDEC:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2906)
			p.PreDecrementExpression()
		}

	case Java9ParserADD:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2907)
			p.Match(Java9ParserADD)
		}
		{
			p.SetState(2908)
			p.UnaryExpression()
		}

	case Java9ParserSUB:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(2909)
			p.Match(Java9ParserSUB)
		}
		{
			p.SetState(2910)
			p.UnaryExpression()
		}

	case Java9ParserBOOLEAN, Java9ParserBYTE, Java9ParserCHAR, Java9ParserDOUBLE, Java9ParserEXPORTS, Java9ParserFLOAT, Java9ParserINT, Java9ParserLONG, Java9ParserMODULE, Java9ParserNEW, Java9ParserOPEN, Java9ParserOPERNS, Java9ParserPROVIDES, Java9ParserREQUIRES, Java9ParserSHORT, Java9ParserSUPER, Java9ParserTHIS, Java9ParserTO, Java9ParserUSES, Java9ParserVOID, Java9ParserWITH, Java9ParserIntegerLiteral, Java9ParserFloatingPointLiteral, Java9ParserBooleanLiteral, Java9ParserCharacterLiteral, Java9ParserStringLiteral, Java9ParserNullLiteral, Java9ParserLPAREN, Java9ParserAT, Java9ParserBANG, Java9ParserTILDE, Java9ParserIdentifier:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(2911)
			p.UnaryExpressionNotPlusMinus()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IPreIncrementExpressionContext is an interface to support dynamic dispatch.
type IPreIncrementExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPreIncrementExpressionContext differentiates from other interfaces.
	IsPreIncrementExpressionContext()
}

type PreIncrementExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPreIncrementExpressionContext() *PreIncrementExpressionContext {
	var p = new(PreIncrementExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Java9ParserRULE_preIncrementExpression
	return p
}

func (*PreIncrementExpressionContext) IsPreIncrementExpressionContext() {}

func NewPreIncrementExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PreIncrementExpressionContext {
	var p = new(PreIncrementExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java9ParserRULE_preIncrementExpression

	return p
}

func (s *PreIncrementExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *PreIncrementExpressionContext) INC() antlr.TerminalNode {
	return s.GetToken(Java9ParserINC, 0)
}

func (s *PreIncrementExpressionContext) UnaryExpression() IUnaryExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUnaryExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IUnaryExpressionContext)
}

func (s *PreIncrementExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PreIncrementExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PreIncrementExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.EnterPreIncrementExpression(s)
	}
}

func (s *PreIncrementExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.ExitPreIncrementExpression(s)
	}
}

func (p *Java9Parser) PreIncrementExpression() (localctx IPreIncrementExpressionContext) {
	localctx = NewPreIncrementExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 470, Java9ParserRULE_preIncrementExpression)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2914)
		p.Match(Java9ParserINC)
	}
	{
		p.SetState(2915)
		p.UnaryExpression()
	}

	return localctx
}

// IPreDecrementExpressionContext is an interface to support dynamic dispatch.
type IPreDecrementExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPreDecrementExpressionContext differentiates from other interfaces.
	IsPreDecrementExpressionContext()
}

type PreDecrementExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPreDecrementExpressionContext() *PreDecrementExpressionContext {
	var p = new(PreDecrementExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Java9ParserRULE_preDecrementExpression
	return p
}

func (*PreDecrementExpressionContext) IsPreDecrementExpressionContext() {}

func NewPreDecrementExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PreDecrementExpressionContext {
	var p = new(PreDecrementExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java9ParserRULE_preDecrementExpression

	return p
}

func (s *PreDecrementExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *PreDecrementExpressionContext) DEC() antlr.TerminalNode {
	return s.GetToken(Java9ParserDEC, 0)
}

func (s *PreDecrementExpressionContext) UnaryExpression() IUnaryExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUnaryExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IUnaryExpressionContext)
}

func (s *PreDecrementExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PreDecrementExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PreDecrementExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.EnterPreDecrementExpression(s)
	}
}

func (s *PreDecrementExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.ExitPreDecrementExpression(s)
	}
}

func (p *Java9Parser) PreDecrementExpression() (localctx IPreDecrementExpressionContext) {
	localctx = NewPreDecrementExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 472, Java9ParserRULE_preDecrementExpression)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2917)
		p.Match(Java9ParserDEC)
	}
	{
		p.SetState(2918)
		p.UnaryExpression()
	}

	return localctx
}

// IUnaryExpressionNotPlusMinusContext is an interface to support dynamic dispatch.
type IUnaryExpressionNotPlusMinusContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsUnaryExpressionNotPlusMinusContext differentiates from other interfaces.
	IsUnaryExpressionNotPlusMinusContext()
}

type UnaryExpressionNotPlusMinusContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUnaryExpressionNotPlusMinusContext() *UnaryExpressionNotPlusMinusContext {
	var p = new(UnaryExpressionNotPlusMinusContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Java9ParserRULE_unaryExpressionNotPlusMinus
	return p
}

func (*UnaryExpressionNotPlusMinusContext) IsUnaryExpressionNotPlusMinusContext() {}

func NewUnaryExpressionNotPlusMinusContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UnaryExpressionNotPlusMinusContext {
	var p = new(UnaryExpressionNotPlusMinusContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java9ParserRULE_unaryExpressionNotPlusMinus

	return p
}

func (s *UnaryExpressionNotPlusMinusContext) GetParser() antlr.Parser { return s.parser }

func (s *UnaryExpressionNotPlusMinusContext) PostfixExpression() IPostfixExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPostfixExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPostfixExpressionContext)
}

func (s *UnaryExpressionNotPlusMinusContext) TILDE() antlr.TerminalNode {
	return s.GetToken(Java9ParserTILDE, 0)
}

func (s *UnaryExpressionNotPlusMinusContext) UnaryExpression() IUnaryExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUnaryExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IUnaryExpressionContext)
}

func (s *UnaryExpressionNotPlusMinusContext) BANG() antlr.TerminalNode {
	return s.GetToken(Java9ParserBANG, 0)
}

func (s *UnaryExpressionNotPlusMinusContext) CastExpression() ICastExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICastExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICastExpressionContext)
}

func (s *UnaryExpressionNotPlusMinusContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnaryExpressionNotPlusMinusContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UnaryExpressionNotPlusMinusContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.EnterUnaryExpressionNotPlusMinus(s)
	}
}

func (s *UnaryExpressionNotPlusMinusContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.ExitUnaryExpressionNotPlusMinus(s)
	}
}

func (p *Java9Parser) UnaryExpressionNotPlusMinus() (localctx IUnaryExpressionNotPlusMinusContext) {
	localctx = NewUnaryExpressionNotPlusMinusContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 474, Java9ParserRULE_unaryExpressionNotPlusMinus)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(2926)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 333, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2920)
			p.PostfixExpression()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2921)
			p.Match(Java9ParserTILDE)
		}
		{
			p.SetState(2922)
			p.UnaryExpression()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2923)
			p.Match(Java9ParserBANG)
		}
		{
			p.SetState(2924)
			p.UnaryExpression()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(2925)
			p.CastExpression()
		}

	}

	return localctx
}

// IPostfixExpressionContext is an interface to support dynamic dispatch.
type IPostfixExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPostfixExpressionContext differentiates from other interfaces.
	IsPostfixExpressionContext()
}

type PostfixExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPostfixExpressionContext() *PostfixExpressionContext {
	var p = new(PostfixExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Java9ParserRULE_postfixExpression
	return p
}

func (*PostfixExpressionContext) IsPostfixExpressionContext() {}

func NewPostfixExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PostfixExpressionContext {
	var p = new(PostfixExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java9ParserRULE_postfixExpression

	return p
}

func (s *PostfixExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *PostfixExpressionContext) Primary() IPrimaryContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPrimaryContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPrimaryContext)
}

func (s *PostfixExpressionContext) ExpressionName() IExpressionNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionNameContext)
}

func (s *PostfixExpressionContext) AllPostIncrementExpression_lf_postfixExpression() []IPostIncrementExpression_lf_postfixExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IPostIncrementExpression_lf_postfixExpressionContext)(nil)).Elem())
	var tst = make([]IPostIncrementExpression_lf_postfixExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IPostIncrementExpression_lf_postfixExpressionContext)
		}
	}

	return tst
}

func (s *PostfixExpressionContext) PostIncrementExpression_lf_postfixExpression(i int) IPostIncrementExpression_lf_postfixExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPostIncrementExpression_lf_postfixExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IPostIncrementExpression_lf_postfixExpressionContext)
}

func (s *PostfixExpressionContext) AllPostDecrementExpression_lf_postfixExpression() []IPostDecrementExpression_lf_postfixExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IPostDecrementExpression_lf_postfixExpressionContext)(nil)).Elem())
	var tst = make([]IPostDecrementExpression_lf_postfixExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IPostDecrementExpression_lf_postfixExpressionContext)
		}
	}

	return tst
}

func (s *PostfixExpressionContext) PostDecrementExpression_lf_postfixExpression(i int) IPostDecrementExpression_lf_postfixExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPostDecrementExpression_lf_postfixExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IPostDecrementExpression_lf_postfixExpressionContext)
}

func (s *PostfixExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PostfixExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PostfixExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.EnterPostfixExpression(s)
	}
}

func (s *PostfixExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.ExitPostfixExpression(s)
	}
}

func (p *Java9Parser) PostfixExpression() (localctx IPostfixExpressionContext) {
	localctx = NewPostfixExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 476, Java9ParserRULE_postfixExpression)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(2930)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 334, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(2928)
			p.Primary()
		}

	case 2:
		{
			p.SetState(2929)
			p.ExpressionName()
		}

	}
	p.SetState(2936)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 336, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			p.SetState(2934)
			p.GetErrorHandler().Sync(p)

			switch p.GetTokenStream().LA(1) {
			case Java9ParserINC:
				{
					p.SetState(2932)
					p.PostIncrementExpression_lf_postfixExpression()
				}

			case Java9ParserDEC:
				{
					p.SetState(2933)
					p.PostDecrementExpression_lf_postfixExpression()
				}

			default:
				panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			}

		}
		p.SetState(2938)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 336, p.GetParserRuleContext())
	}

	return localctx
}

// IPostIncrementExpressionContext is an interface to support dynamic dispatch.
type IPostIncrementExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPostIncrementExpressionContext differentiates from other interfaces.
	IsPostIncrementExpressionContext()
}

type PostIncrementExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPostIncrementExpressionContext() *PostIncrementExpressionContext {
	var p = new(PostIncrementExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Java9ParserRULE_postIncrementExpression
	return p
}

func (*PostIncrementExpressionContext) IsPostIncrementExpressionContext() {}

func NewPostIncrementExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PostIncrementExpressionContext {
	var p = new(PostIncrementExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java9ParserRULE_postIncrementExpression

	return p
}

func (s *PostIncrementExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *PostIncrementExpressionContext) PostfixExpression() IPostfixExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPostfixExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPostfixExpressionContext)
}

func (s *PostIncrementExpressionContext) INC() antlr.TerminalNode {
	return s.GetToken(Java9ParserINC, 0)
}

func (s *PostIncrementExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PostIncrementExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PostIncrementExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.EnterPostIncrementExpression(s)
	}
}

func (s *PostIncrementExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.ExitPostIncrementExpression(s)
	}
}

func (p *Java9Parser) PostIncrementExpression() (localctx IPostIncrementExpressionContext) {
	localctx = NewPostIncrementExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 478, Java9ParserRULE_postIncrementExpression)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2939)
		p.PostfixExpression()
	}
	{
		p.SetState(2940)
		p.Match(Java9ParserINC)
	}

	return localctx
}

// IPostIncrementExpression_lf_postfixExpressionContext is an interface to support dynamic dispatch.
type IPostIncrementExpression_lf_postfixExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPostIncrementExpression_lf_postfixExpressionContext differentiates from other interfaces.
	IsPostIncrementExpression_lf_postfixExpressionContext()
}

type PostIncrementExpression_lf_postfixExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPostIncrementExpression_lf_postfixExpressionContext() *PostIncrementExpression_lf_postfixExpressionContext {
	var p = new(PostIncrementExpression_lf_postfixExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Java9ParserRULE_postIncrementExpression_lf_postfixExpression
	return p
}

func (*PostIncrementExpression_lf_postfixExpressionContext) IsPostIncrementExpression_lf_postfixExpressionContext() {
}

func NewPostIncrementExpression_lf_postfixExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PostIncrementExpression_lf_postfixExpressionContext {
	var p = new(PostIncrementExpression_lf_postfixExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java9ParserRULE_postIncrementExpression_lf_postfixExpression

	return p
}

func (s *PostIncrementExpression_lf_postfixExpressionContext) GetParser() antlr.Parser {
	return s.parser
}

func (s *PostIncrementExpression_lf_postfixExpressionContext) INC() antlr.TerminalNode {
	return s.GetToken(Java9ParserINC, 0)
}

func (s *PostIncrementExpression_lf_postfixExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PostIncrementExpression_lf_postfixExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PostIncrementExpression_lf_postfixExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.EnterPostIncrementExpression_lf_postfixExpression(s)
	}
}

func (s *PostIncrementExpression_lf_postfixExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.ExitPostIncrementExpression_lf_postfixExpression(s)
	}
}

func (p *Java9Parser) PostIncrementExpression_lf_postfixExpression() (localctx IPostIncrementExpression_lf_postfixExpressionContext) {
	localctx = NewPostIncrementExpression_lf_postfixExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 480, Java9ParserRULE_postIncrementExpression_lf_postfixExpression)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2942)
		p.Match(Java9ParserINC)
	}

	return localctx
}

// IPostDecrementExpressionContext is an interface to support dynamic dispatch.
type IPostDecrementExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPostDecrementExpressionContext differentiates from other interfaces.
	IsPostDecrementExpressionContext()
}

type PostDecrementExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPostDecrementExpressionContext() *PostDecrementExpressionContext {
	var p = new(PostDecrementExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Java9ParserRULE_postDecrementExpression
	return p
}

func (*PostDecrementExpressionContext) IsPostDecrementExpressionContext() {}

func NewPostDecrementExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PostDecrementExpressionContext {
	var p = new(PostDecrementExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java9ParserRULE_postDecrementExpression

	return p
}

func (s *PostDecrementExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *PostDecrementExpressionContext) PostfixExpression() IPostfixExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPostfixExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPostfixExpressionContext)
}

func (s *PostDecrementExpressionContext) DEC() antlr.TerminalNode {
	return s.GetToken(Java9ParserDEC, 0)
}

func (s *PostDecrementExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PostDecrementExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PostDecrementExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.EnterPostDecrementExpression(s)
	}
}

func (s *PostDecrementExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.ExitPostDecrementExpression(s)
	}
}

func (p *Java9Parser) PostDecrementExpression() (localctx IPostDecrementExpressionContext) {
	localctx = NewPostDecrementExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 482, Java9ParserRULE_postDecrementExpression)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2944)
		p.PostfixExpression()
	}
	{
		p.SetState(2945)
		p.Match(Java9ParserDEC)
	}

	return localctx
}

// IPostDecrementExpression_lf_postfixExpressionContext is an interface to support dynamic dispatch.
type IPostDecrementExpression_lf_postfixExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPostDecrementExpression_lf_postfixExpressionContext differentiates from other interfaces.
	IsPostDecrementExpression_lf_postfixExpressionContext()
}

type PostDecrementExpression_lf_postfixExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPostDecrementExpression_lf_postfixExpressionContext() *PostDecrementExpression_lf_postfixExpressionContext {
	var p = new(PostDecrementExpression_lf_postfixExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Java9ParserRULE_postDecrementExpression_lf_postfixExpression
	return p
}

func (*PostDecrementExpression_lf_postfixExpressionContext) IsPostDecrementExpression_lf_postfixExpressionContext() {
}

func NewPostDecrementExpression_lf_postfixExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PostDecrementExpression_lf_postfixExpressionContext {
	var p = new(PostDecrementExpression_lf_postfixExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java9ParserRULE_postDecrementExpression_lf_postfixExpression

	return p
}

func (s *PostDecrementExpression_lf_postfixExpressionContext) GetParser() antlr.Parser {
	return s.parser
}

func (s *PostDecrementExpression_lf_postfixExpressionContext) DEC() antlr.TerminalNode {
	return s.GetToken(Java9ParserDEC, 0)
}

func (s *PostDecrementExpression_lf_postfixExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PostDecrementExpression_lf_postfixExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PostDecrementExpression_lf_postfixExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.EnterPostDecrementExpression_lf_postfixExpression(s)
	}
}

func (s *PostDecrementExpression_lf_postfixExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.ExitPostDecrementExpression_lf_postfixExpression(s)
	}
}

func (p *Java9Parser) PostDecrementExpression_lf_postfixExpression() (localctx IPostDecrementExpression_lf_postfixExpressionContext) {
	localctx = NewPostDecrementExpression_lf_postfixExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 484, Java9ParserRULE_postDecrementExpression_lf_postfixExpression)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2947)
		p.Match(Java9ParserDEC)
	}

	return localctx
}

// ICastExpressionContext is an interface to support dynamic dispatch.
type ICastExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCastExpressionContext differentiates from other interfaces.
	IsCastExpressionContext()
}

type CastExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCastExpressionContext() *CastExpressionContext {
	var p = new(CastExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Java9ParserRULE_castExpression
	return p
}

func (*CastExpressionContext) IsCastExpressionContext() {}

func NewCastExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CastExpressionContext {
	var p = new(CastExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java9ParserRULE_castExpression

	return p
}

func (s *CastExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *CastExpressionContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(Java9ParserLPAREN, 0)
}

func (s *CastExpressionContext) PrimitiveType() IPrimitiveTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPrimitiveTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPrimitiveTypeContext)
}

func (s *CastExpressionContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(Java9ParserRPAREN, 0)
}

func (s *CastExpressionContext) UnaryExpression() IUnaryExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUnaryExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IUnaryExpressionContext)
}

func (s *CastExpressionContext) ReferenceType() IReferenceTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IReferenceTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IReferenceTypeContext)
}

func (s *CastExpressionContext) UnaryExpressionNotPlusMinus() IUnaryExpressionNotPlusMinusContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUnaryExpressionNotPlusMinusContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IUnaryExpressionNotPlusMinusContext)
}

func (s *CastExpressionContext) AllAdditionalBound() []IAdditionalBoundContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAdditionalBoundContext)(nil)).Elem())
	var tst = make([]IAdditionalBoundContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAdditionalBoundContext)
		}
	}

	return tst
}

func (s *CastExpressionContext) AdditionalBound(i int) IAdditionalBoundContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAdditionalBoundContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAdditionalBoundContext)
}

func (s *CastExpressionContext) LambdaExpression() ILambdaExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILambdaExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILambdaExpressionContext)
}

func (s *CastExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CastExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CastExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.EnterCastExpression(s)
	}
}

func (s *CastExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.ExitCastExpression(s)
	}
}

func (p *Java9Parser) CastExpression() (localctx ICastExpressionContext) {
	localctx = NewCastExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 486, Java9ParserRULE_castExpression)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(2976)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 339, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2949)
			p.Match(Java9ParserLPAREN)
		}
		{
			p.SetState(2950)
			p.PrimitiveType()
		}
		{
			p.SetState(2951)
			p.Match(Java9ParserRPAREN)
		}
		{
			p.SetState(2952)
			p.UnaryExpression()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2954)
			p.Match(Java9ParserLPAREN)
		}
		{
			p.SetState(2955)
			p.ReferenceType()
		}
		p.SetState(2959)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == Java9ParserBITAND {
			{
				p.SetState(2956)
				p.AdditionalBound()
			}

			p.SetState(2961)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(2962)
			p.Match(Java9ParserRPAREN)
		}
		{
			p.SetState(2963)
			p.UnaryExpressionNotPlusMinus()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2965)
			p.Match(Java9ParserLPAREN)
		}
		{
			p.SetState(2966)
			p.ReferenceType()
		}
		p.SetState(2970)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == Java9ParserBITAND {
			{
				p.SetState(2967)
				p.AdditionalBound()
			}

			p.SetState(2972)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(2973)
			p.Match(Java9ParserRPAREN)
		}
		{
			p.SetState(2974)
			p.LambdaExpression()
		}

	}

	return localctx
}

// IIdentifierContext is an interface to support dynamic dispatch.
type IIdentifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsIdentifierContext differentiates from other interfaces.
	IsIdentifierContext()
}

type IdentifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIdentifierContext() *IdentifierContext {
	var p = new(IdentifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Java9ParserRULE_identifier
	return p
}

func (*IdentifierContext) IsIdentifierContext() {}

func NewIdentifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IdentifierContext {
	var p = new(IdentifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java9ParserRULE_identifier

	return p
}

func (s *IdentifierContext) GetParser() antlr.Parser { return s.parser }

func (s *IdentifierContext) Identifier() antlr.TerminalNode {
	return s.GetToken(Java9ParserIdentifier, 0)
}

func (s *IdentifierContext) TO() antlr.TerminalNode {
	return s.GetToken(Java9ParserTO, 0)
}

func (s *IdentifierContext) MODULE() antlr.TerminalNode {
	return s.GetToken(Java9ParserMODULE, 0)
}

func (s *IdentifierContext) OPEN() antlr.TerminalNode {
	return s.GetToken(Java9ParserOPEN, 0)
}

func (s *IdentifierContext) WITH() antlr.TerminalNode {
	return s.GetToken(Java9ParserWITH, 0)
}

func (s *IdentifierContext) PROVIDES() antlr.TerminalNode {
	return s.GetToken(Java9ParserPROVIDES, 0)
}

func (s *IdentifierContext) USES() antlr.TerminalNode {
	return s.GetToken(Java9ParserUSES, 0)
}

func (s *IdentifierContext) OPERNS() antlr.TerminalNode {
	return s.GetToken(Java9ParserOPERNS, 0)
}

func (s *IdentifierContext) REQUIRES() antlr.TerminalNode {
	return s.GetToken(Java9ParserREQUIRES, 0)
}

func (s *IdentifierContext) EXPORTS() antlr.TerminalNode {
	return s.GetToken(Java9ParserEXPORTS, 0)
}

func (s *IdentifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IdentifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IdentifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.EnterIdentifier(s)
	}
}

func (s *IdentifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java9ParserListener); ok {
		listenerT.ExitIdentifier(s)
	}
}

func (p *Java9Parser) Identifier() (localctx IIdentifierContext) {
	localctx = NewIdentifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 488, Java9ParserRULE_identifier)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2978)
		_la = p.GetTokenStream().LA(1)

		if !(_la == Java9ParserEXPORTS || _la == Java9ParserMODULE || (((_la-34)&-(0x1f+1)) == 0 && ((1<<uint((_la-34)))&((1<<(Java9ParserOPEN-34))|(1<<(Java9ParserOPERNS-34))|(1<<(Java9ParserPROVIDES-34))|(1<<(Java9ParserREQUIRES-34))|(1<<(Java9ParserTO-34))|(1<<(Java9ParserUSES-34))|(1<<(Java9ParserWITH-34)))) != 0) || _la == Java9ParserIdentifier) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

func (p *Java9Parser) Sempred(localctx antlr.RuleContext, ruleIndex, predIndex int) bool {
	switch ruleIndex {
	case 25:
		var t *ModuleNameContext = nil
		if localctx != nil {
			t = localctx.(*ModuleNameContext)
		}
		return p.ModuleName_Sempred(t, predIndex)

	case 26:
		var t *PackageNameContext = nil
		if localctx != nil {
			t = localctx.(*PackageNameContext)
		}
		return p.PackageName_Sempred(t, predIndex)

	case 28:
		var t *PackageOrTypeNameContext = nil
		if localctx != nil {
			t = localctx.(*PackageOrTypeNameContext)
		}
		return p.PackageOrTypeName_Sempred(t, predIndex)

	case 31:
		var t *AmbiguousNameContext = nil
		if localctx != nil {
			t = localctx.(*AmbiguousNameContext)
		}
		return p.AmbiguousName_Sempred(t, predIndex)

	case 224:
		var t *ConditionalOrExpressionContext = nil
		if localctx != nil {
			t = localctx.(*ConditionalOrExpressionContext)
		}
		return p.ConditionalOrExpression_Sempred(t, predIndex)

	case 225:
		var t *ConditionalAndExpressionContext = nil
		if localctx != nil {
			t = localctx.(*ConditionalAndExpressionContext)
		}
		return p.ConditionalAndExpression_Sempred(t, predIndex)

	case 226:
		var t *InclusiveOrExpressionContext = nil
		if localctx != nil {
			t = localctx.(*InclusiveOrExpressionContext)
		}
		return p.InclusiveOrExpression_Sempred(t, predIndex)

	case 227:
		var t *ExclusiveOrExpressionContext = nil
		if localctx != nil {
			t = localctx.(*ExclusiveOrExpressionContext)
		}
		return p.ExclusiveOrExpression_Sempred(t, predIndex)

	case 228:
		var t *AndExpressionContext = nil
		if localctx != nil {
			t = localctx.(*AndExpressionContext)
		}
		return p.AndExpression_Sempred(t, predIndex)

	case 229:
		var t *EqualityExpressionContext = nil
		if localctx != nil {
			t = localctx.(*EqualityExpressionContext)
		}
		return p.EqualityExpression_Sempred(t, predIndex)

	case 230:
		var t *RelationalExpressionContext = nil
		if localctx != nil {
			t = localctx.(*RelationalExpressionContext)
		}
		return p.RelationalExpression_Sempred(t, predIndex)

	case 231:
		var t *ShiftExpressionContext = nil
		if localctx != nil {
			t = localctx.(*ShiftExpressionContext)
		}
		return p.ShiftExpression_Sempred(t, predIndex)

	case 232:
		var t *AdditiveExpressionContext = nil
		if localctx != nil {
			t = localctx.(*AdditiveExpressionContext)
		}
		return p.AdditiveExpression_Sempred(t, predIndex)

	case 233:
		var t *MultiplicativeExpressionContext = nil
		if localctx != nil {
			t = localctx.(*MultiplicativeExpressionContext)
		}
		return p.MultiplicativeExpression_Sempred(t, predIndex)

	default:
		panic("No predicate with index: " + fmt.Sprint(ruleIndex))
	}
}

func (p *Java9Parser) ModuleName_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 0:
		return p.Precpred(p.GetParserRuleContext(), 1)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *Java9Parser) PackageName_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 1:
		return p.Precpred(p.GetParserRuleContext(), 1)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *Java9Parser) PackageOrTypeName_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 2:
		return p.Precpred(p.GetParserRuleContext(), 1)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *Java9Parser) AmbiguousName_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 3:
		return p.Precpred(p.GetParserRuleContext(), 1)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *Java9Parser) ConditionalOrExpression_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 4:
		return p.Precpred(p.GetParserRuleContext(), 1)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *Java9Parser) ConditionalAndExpression_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 5:
		return p.Precpred(p.GetParserRuleContext(), 1)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *Java9Parser) InclusiveOrExpression_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 6:
		return p.Precpred(p.GetParserRuleContext(), 1)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *Java9Parser) ExclusiveOrExpression_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 7:
		return p.Precpred(p.GetParserRuleContext(), 1)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *Java9Parser) AndExpression_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 8:
		return p.Precpred(p.GetParserRuleContext(), 1)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *Java9Parser) EqualityExpression_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 9:
		return p.Precpred(p.GetParserRuleContext(), 2)

	case 10:
		return p.Precpred(p.GetParserRuleContext(), 1)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *Java9Parser) RelationalExpression_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 11:
		return p.Precpred(p.GetParserRuleContext(), 5)

	case 12:
		return p.Precpred(p.GetParserRuleContext(), 4)

	case 13:
		return p.Precpred(p.GetParserRuleContext(), 3)

	case 14:
		return p.Precpred(p.GetParserRuleContext(), 2)

	case 15:
		return p.Precpred(p.GetParserRuleContext(), 1)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *Java9Parser) ShiftExpression_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 16:
		return p.Precpred(p.GetParserRuleContext(), 3)

	case 17:
		return p.Precpred(p.GetParserRuleContext(), 2)

	case 18:
		return p.Precpred(p.GetParserRuleContext(), 1)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *Java9Parser) AdditiveExpression_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 19:
		return p.Precpred(p.GetParserRuleContext(), 2)

	case 20:
		return p.Precpred(p.GetParserRuleContext(), 1)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *Java9Parser) MultiplicativeExpression_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 21:
		return p.Precpred(p.GetParserRuleContext(), 3)

	case 22:
		return p.Precpred(p.GetParserRuleContext(), 2)

	case 23:
		return p.Precpred(p.GetParserRuleContext(), 1)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}
